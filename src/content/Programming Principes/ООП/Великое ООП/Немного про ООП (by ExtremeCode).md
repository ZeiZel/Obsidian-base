# Немного про ООП
#OOP #CSharp

### **Инкапсуляция**

- Инкапсуляция обеспечивает объединение данных и функции и в некоторых случая позволяет ограничить доступ одних объектов к другим.

Инкапсуляция обеспечивает сокрытие данных, но не является самим сокрытием данных. Она не всегда даёт такую возможность, так как некоторые языки представляют механизм рефлексии, который позволяет менять приватные данные
![](_png/8042e9e0588e3c5d04c61924f61589b1.png)![](_png/2d29848e01c4026e3d5db3f63a20a6f5.png)
- Инкапсуляция по Герберту Шилдту
![](_png/c8f2f5d5b92faee8bffb5eecb2b8f818.png)
### **Наследование**

- Механизмы наследования можно заменить с помощью агрегации и композиции, однако эта парадигма нужна для формирования иерархии родственных объектов и создавать более благоприятные условия для реализации полиморфизма.

Однако тут стоит упомянуть, что наследование может быть даже вредно в реальных проектах, ведь можно поломать весь код из одного места и когда у родителя огромное множество наследников – вносить правки становится крайне сложно
![](_png/e8063bd6fe7bf9053d210ed34aa02a2d.png)![](_png/5f7846798adb88820dfaf4299dc68fd6.png)
- Идеальный пример наследования можно увидеть в прототипировании JS. Тут в качестве родителя выступает конкретно сформированный объект и объекты можно сотворять на ходу
![](_png/62ba8fe726c606fb8e6b9113f473f94f.png)
### **Полиморфизм**

- Ad Hoc полиморфизм – который представлен перегрузкой методов
![](_png/15a5bb38e0fdf9648ace99292541087b.png)
- Параметрический полиморфизм – который представлен в C# через Generics

- И полиморфизм подтипов, который мы достигаем через наследование и апкаст. Легче всего его понять, используя паттерн «Стратегия»
![](_png/cedce33614ca395e7829ce78bd4ac1c6.png)
- Ещё один пример полиморфизма в логировании
![](_png/73005250ac332eeb84e87d248794c704.png)
- А таким образом можно показать полиморфизм в JS
![](_png/7398ffd1e929da3e189930ce46f04e87.png)
- А тут пример, когда полиморфизм обеспечивает сокрытие. Тут представлен публичный метод Test, который при вызове в классе Program не позволит скомпилировать программу, так как теперь к нему нет доступа (он стал приватным и вызывается через метод Test2)
![](_png/40ff562c2cc7031bcbcf7f688d281e8a.png)
### **Абстракция**

- Инкапсуляция влияет на формирование интерфейса нашего будущего типа
![](_png/442d2140782b59329573dc7ccf9b7793.png)
### **Посылка сообщения**

- Объект вызывает метод у другого объекта
![](_png/04b4b46cbad93a10a1f3342047f27355.png)
- Если в C такая парадигма может сработать, то уже в C# компилятор за такой подход надаёт по рукам
![](_png/c4909287b73cf70590acf1eb5cfa62c6.png)
### **Повторное использование**

- Парадиигма, которая определяет повторное использование кода в проектах. Обычно и эту парадигму опускают в описании