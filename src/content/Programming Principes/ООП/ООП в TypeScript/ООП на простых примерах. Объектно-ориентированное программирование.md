# ООП в TypeScript
#OOP #TypeScript #JavaScript 

### Отличие процедурного подхода от объектно-ориентированного.

Процедурный подход подразумевал под собой обычно написание функции и определение того, когда функция будет вызваться и с какими параметрами 

![](_png/6c0f97be3160a33a23475e73eb736ea1.png)
```TS
const width = 5;
const height = 10;

function clacRectArea(width, height) {
    return width * height;
}

clacRectArea(width, height);
```

Однако использовать процедурный подход в программировании было тяжело, так как расширять такое приложение было крайне трудозатратным

![](_png/fb17b8ce2b0185b4e7eb4dc27f0887e6.png)

### Классы. Объекты. Свойства. Методы. Конструктор.

>[!info] **Класс** - это описание характеристик будущего объекта. **Объект** - это конкретный экземпляр класса, где характеристики уже имеют свои значения

![](_png/56dbec3d1be8d02376dd4ed957140408.png)

>[!info] Конкретно характеристики в контексте ООП - это *свойства*, а его функции - это *методы*

![](_png/63bb3e6019e632c25a26438caac0ed88.png)

Мы имеем конкретный объект Rectangle. У него есть два свойства: высота и ширина. Объектам обычно прописывается конструктор, который принимает в себя начальные значения для свойств класса. Так же у объекта есть свои методы, которые он может исполнить. 
Мы можем создать столько инстанцев класса, сколько нам нужно. Так же мы можем добавить нужное нам количество методов и свойств. Однако нужно помнить, что мы должны создавать объекты под конкретные задачи без лишних методов и свойств не характерных для данного объекта.
this - это всегда обращение к данному объекту

```TS
class Rectangle {
    width: number;
    height: number;

    constructor(w, h) {
        this.width = w;
        this.height = h;
    }

    clacArea() {
        return this.width * this.height;
    }
}

const rect = new Rectangle(5, 10);
rect.clacArea();
```

В ООП главными парадигмами являются данные три:

![](_png/dcebffd4f7c7ae07f2aa93f8edc7e7dd.png)

### Инкапсуляция и сокрытие. Модификаторы доступа.

>[!Info] **Инкапсуляция** - это парадигма, которая говорит нам, что данные и функции могут быть связаны, а данные внутри класса будут недоступны для изменений вне класса.  

Как пример можно привести человека. Мы знаем, что он имеет публичнодоступные и известные методы и свойства (имеет имя, умеет ходить). Но так же он имеет приватные данные, которые мы можем получить только через метод (связь данных и функций - получить номер паспорта через просьбу достать паспорт) либо, которые мы передали в конструктор при создании и забыли про них. Так же мы не имеем доступа к внутренним методам мышления, переваривания пищи и остальных физиологических функций (кроме врачебных вмешательств - рефлексии) 
![](_png/48ab10de27e7191be7bce49dfe0ef350.png)

>[!Info] **Модификатор** - это определённый элемент, который определяет доступность свойства или метода изнутри класса. Конкретно private - ограничивает область доступности данных полей внутри класса, а public делает поля доступными для просмотра и изменения и вне класса.

Приватные свойства по соглашению в ТС начинают с  " _ " 
Для получения или изменения приватного свойства обычно используют геттеры (получение значения) и сеттеры (помещение значения). Если у нас будет отсутствовать сеттер, то свойство изменить мы не сможем (свойство автоматически станет readonly), если будет отсутствовать геттер, то получить значение свойства у нас так же не получится

```TS
class Rectangle {
    // Приватные поля
    private _width: number;
    private _height: number;

    constructor(w, h) {
        this._width = w;
        this._height = h;
    }

    // Получение и установка этих полей
    get width() {
        return this._width;
    }

    set width(value) {
        if (value <= 0) {
            this._width = 1;
        } else {
            this._width = value;
        }
    }

    clacArea() {
        return this._width * this._height;
    }
}

const rect = new Rectangle(5, 10);
rect.clacArea();
```


Так же стоит упомянуть, что по умолчанию в ТС присваивается всем полям публичный модификатор. Хорошей практикой является явное указание публичных/приватных модификаторов

```TS
public get width() {
	return this._width;
}

public set width(value) {
	if (value <= 0) {
		this._width = 1;
	} else {
		this._width = value;
	}
}
```

Так же ещё один пример. Нам не стоит редактировать таблицу базы данных напрямую. Вместо этого будет правильным решением сделать отдельный метод для заполнения таблицы нашей БД
Если нам потребуется очистить нашу БД, то так же лучше создать отдельный метод для этих действий

![](_png/3e1d6aa144e571c60bf80b30039215f5.png)
![](_png/e13e6f47c965f21cbe8a9b0e27c67a8d.png)

### Наследование.

>[!Info] **Наследование** подразумевает под собой переиспользование кода за счёт передачи его дочернему элементу. 

То есть, например, мы имеем *человека* -> этот человек может быть *работником*, а уже работника можно конкретизировать до программиста

![](_png/62afed4fbd2a47d49a6aa21b13b04ae2.png)

Пример экстенда класса от других классов (персона - рабочий)

![](_png/08e152860d2aa3d081c7738df627d61c.png)

Ну и расширяемся дальше по прямой. Через метод супер вызывается конструктор родителя и уже в него передаются аргументы 

![](_png/6332d4b17af2f720aafd585162347116.png)
![](_png/6629188839dd81cb78e26a86e70fcecd.png)

И вот наследование методов от родительского

![](_png/98e1c50a0d12968abe0efc9a7ce3bd47.png)
![](_png/b050762ebc33600de5ea42c032a8216e.png)

### Полиморфизм. Параметрический и ad-hoc

>[!Info] Полиморфизм - "один интерфейс - множество реализаций".
Выделяют два вида полиморфизма:
-Параметрический (истинный)
-Ad-hoc (мнимый)

==Ad-hoc==. Представляет из себя перегрузку методов, когда мы передаём аргументы разных типов данных. Такой способ не работает в ТС  

```TS
class Calculator {  
    add(a: number, b: number): number {  
        return a + b;  
    }  
  
    add(a: string, b: string): string {  
        return a + b;  
    }  
}  

const calculator = new Calculator();

calculator.add(5, 5);  
calculator.add("5", "5");
```

==Параметрический полиморфизм==. Уже он представляет из себя переопределение унаследованных методов на те, которые подойдут определённому объекту класса 

![](_png/d5e01333c6157a25ca3a44910d6056e7.png)
![](_png/ecd49e30e230a4564eba1e3d856f9680.png)

Тут показана реализация перебора массива персон (который имеет тип массива родительского класса) и вызов у каждого из них метода приветствия

![](_png/418461b5eea6ed1b65ed6b7c157c0f6c.png)

### Агрегация и композиция.

Чуть выше было рассмотрено взаимодействие классов через наследование

![](_png/c5d2eb136a04965d1b3b820a49b1d782.png)

Композиция подразумевает под собой то, что объекты не могут существовать отдельно друг без друга (автомобиль не может существовать отдельно от двигателя и колёс, так как он из них состоит)

![](_png/6639242eaf0d4fe20d0c19a7d50bad90.png)

Агрегация подразумевает под собой то, что объект может существовать отдельно от другого объекта. Ёлочка-освежитель может отдельно существовать без машины (находиться дома, например) и машина может иметь в себе не ёлочку, а качающегося дельфинчика

![](_png/5e05787352e7b2559acb02e73db5c3c2.png)

И вот реальный пример композиции. 
Машина не может существовать без колёс и двигателя (обязательно в конструкторе нужно их создать)

```TS
class Wheel {  
    drive() {  
        console.log("Колесо едет");  
    }  
}  
  
class Engine {  
    drive() {  
        console.log("Двигатель заведён");  
    }  
}  
  
  
class Car {  
    engine: Engine;  
    wheels: Wheel[];  
  
    constructor() {  
        this.engine = new Engine();  
        this.wheels = [];  
        this.addWheels(new Wheel(), 4);  
    }  
  
    addWheels(wheel: Wheel, count: number) {  
        for (let i = 0; i < count; i++) {  
            this.wheels.push(wheel);  
        }    
    }  
  
    drive() {  
        this.engine.drive();  
        for (let i = 0; i < this.wheels.length; i++) {  
            this.wheels[i].drive();  
        }    
    }  
}  
  
const bmw = new Car();  
bmw.drive();
```
![](_png/acb9ff370ecd65544484f7d91acd134d.png)

И вот пример агрегации. Мы отдельно создали класс освежителя и добавили его в качестве  аргумента конструктора. 
Стоит сказать, что при удалении машины, освежитель останется и будет жить своей жизнью. А уже колёса и двигатель исчезнут вслед за машиной.  

![](_png/e1d270b088bba54c4ccf27000b24b74f.png)
И свою жизнь освежитель сможет пролежать в квартире
![](_png/8bd58f96aaa2eef69a7dcc4f43682026.png)

### Интерфейсы и абстрактные классы.

>[!info] **Интерфейсы** представляют собой абстрактное представление функционала будущего объекта (например, класса). Можно представить, что это оглавление, которое описывает, что должно присутствовать в объекте. 

>[!info] **Абстрактный класс** - это уже конкретная схема класса со всеми методами, тем, что они должны возвращать и даже с логикой, которую можно передать через наследование

![](_png/6ba9b21053ae669c961c3d0e41b6fce8.png)

- Интерфейсы позволяют эффективно проектировать систему. 
- Так же это представление работы полиморфизма. 
- Создать класс из интерфейса нельзя - можно только имплементировать существующий класс

![](_png/56e851ada7a541c8aa23d4fd951faedc.png)

И вот пример создания класса из интерфейса
*(тут очень сильно помогает alt+insert, который сам реализует все методы интерфейсов)*

```TS
interface IReader {  
    get(url: string): string;  
    read: (text: string) => void;  
    delete: () => void;  
    create: () => void;  
    update: () => void;  
}  
  
class Repository implements IReader {  
    create(): void {  
    }  
    delete(): void {  
    }  
    read(text: string): void {  
    }  
    update(): void {  
    }  
    get(url: string): string {  
        return "";  
    }  
}
```

Однако если нам нужно будет из интерфейса репозитория сделать репозиторий юзера, то нам нужно будет немного дополнить интерфейс и уточнить его под юзера (хотя интерфейс мы можем создать для многих объектов).
Для исправления ситуации  в интерфейс мы можем передать дженерик (обобщённый/динамический тип)

![](_png/af2f6c91ff89adf6d2b789aeee0d8198.png)

И теперь мы можем использовать репозиторий и для реализации репозитория машин: класс Car, класс CarRepository, интерфейс Repository

![](_png/0fb5c9cddd31eb74b7a5751551bc7500.png)

### Внедрение зависимостей. Dependency injection

На всех тех принципах, что были озвучены выше, строится огромное количество паттернов проектирования

![](_png/836be594bcb531283e919caf2c1117e2.png)

И вот пример реализации паттерна *"Внедрение зависимостей"*. У нас есть два слоя реализации приложения: работа с базой данных и бизнес-логика. Первый слой работает с двумя разными репозиториями БД (реляционная и нереляционная). В идеале, нам нужно, чтобы 2ой слой не знал, с какой БД мы работаем и в нём нам нужно будет реализовать имплементацию

![](_png/df5ffb85bb895e5b2b01b180d2c35831.png)
![](_png/70a9415d2f76daf9bd2b4d612c289699.png)
![](_png/495f65f45aa5c0da57c7ae124e03e997.png)

И вот мы реализовали логику, когда мы в зависимости от разных аргументов получаем разную реализацию. Получаем мы разную реализацию за счёт того, что передаём не какой-то объект, а интерфейс. А из этого интерфейса идут две других реализации работы с БД, что и позволяет нам передать в один класс две разных логики (двух разных БД) 
Реализован опять же полиморфизм, но с использованием интерфейса

```TS
class User {  
  
}  

// Сам интерфейс
interface UserRepository {  
    getUsers: () => User[];  
}  

// Создаём первый репозиторий через интерфейс
class MongoDBRepository implements UserRepository {  
    getUsers(): User[] {  
        console.log("Get users from MongoDB");  
        return [{age: 15, username: "MongoDB"}];  
    }  
}  

// И создаём репозиторий постреса через интерфейс
class PostresRepository implements UserRepository {  
    getUsers(): User[] {  
        console.log("Get users from PostreSQL");  
        return [{age: 15, username: "PostreSQL"}];  
    }  
}  
  
class UserService {  
    userRepository: UserRepository;  

	// Чтобы была возможность передать сюда один из репозиториев БД, нужно передать сюда интерфейс
    constructor(userRepository: UserRepository) { // Агрегация  
        this.userRepository = userRepository;  
    }  
  
    // Эту реализацию на проектах делают через БД  
    filterUserByAge(age: number) {  
        const users = this.userRepository.getUsers();  
        // filter logic ...  
        console.log(users);  
    }  
}  
  
const userServiceMongo = new UserService(new MongoDBRepository());  
userServiceMongo.filterUserByAge(15);  
const userServicePostres = new UserService(new MongoDBRepository());  
userServicePostres.filterUserByAge(15);
```

### Паттерн singleton

Паттерн Singleton заставляет нас от одного класса создавать только один объект. Делать более одного экземпляра класса (а равно и подключения) - нельзя

Вот в примере, у нас создаются две разных БД. Внутри них генерируется уникальный идентификатор - их url. Это два разных поключения

![](_png/f4a016b1b52d95a9a28705ecbab1f51a.png)

Однако мы можем ограничить создание новых объектов. Можно сделать статичное свойство (то есть оно будет доступно без инициализации класса), в котором будет находиться значение нашего класса и этот инстанс будет из себя представлять всегда одинаковое статичное значение (= this). Это гарантирует постоянную одинаковость определённого значения класса Базы Данных

![](_png/d994da8d6f5aef92d1055e8e6a4fcb43.png)

И теперь при каждой инициализации нашего класса, мы будем получать одно и то же значение определённого свойства (оно будет неизменным)

![](_png/2c8b27d9fe274a3f0d3a9554521eaaa8.png)