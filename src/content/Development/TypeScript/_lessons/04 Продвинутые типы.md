
### 020 Union

Юнион – это способ определения типа данных, когда мы в переменную можем поместить один из перечисленных через «`|`» типов данных

Сразу хочется отметить, что при использовании такого типа данных, в обычных условиях, компилятор не понимает, что в нём находится и не предлагает нормальный автокомплит

![](_png/72a0b41fb35da90df4f7f93e584dc54b.png)

Сужение типов. Для того, чтобы использовать методы строк, или чисел, или булеана, нам нужно сузить типы, с которыми мы работаем (потому что юнион объект – это ни рыба, ни мясо)

Сузить можно через условие, в котором мы пропишем, что оно будет срабатывать при равности типа указанному

![](_png/3e163e33e5577c0d3625c318150fb34f.png)![](_png/77ad82e506419c8cee6160916b2030f4.png)

Так же можно увидеть, что мы исключили возможность того, что тип может быть строчным и компилятор нам показывает, что нынешний аргумент у нас либо число, либо булеан значение

![](_png/18bd84223ca64c86a8ec161a2bfb5935.png)

Больше примеров богу примеров. Это пример выборки либо строки, либо массива из передаваемых типов

![](_png/29d8f89bdcce411b395cb5e76a4cbcde.png)

А вот уже пример с типизацией объектов. Тут мы можем проверить в придачу в принципе наличие определённого ключа в объекте + его типа и обработать это всё

![](_png/8682c4f2dba4b88b47bd684aff6ac211.png)

Ну и так же мы можем проверять два разных типа на разные действия при их соответствии

![](_png/166ca0d893c170a31409daa35ee40dc6.png)

### 021 Literal Types

Литеральные типы данных – это типы данных, которые выражаются в определённых значениях. Эти типы определяют, что будет находиться в этой переменной. По умолчанию константы имеют тип данных равный значению. Если let присвоить литеральный тип данных (например, 1), то и хранить сможет только число «1»

![](_png/18fec13ea59ffbba06c5a8cbdd7adb08.png)![](_png/1ef02bed2efccb02082510814adc4568.png)

Используются литеральные типы, чтобы не делать на каждый чих енамы

![](_png/334da118c6688e4dbd34535deda9acde.png)

Литеральные типы принимают в себя только значения, которые мы зададим для этих значений. Так же мы можем задать фиксированные значения на получения таковых из функции

![](_png/58a015b9655e505395ff7839c192e376.png)

Однако тут нужно так же и помнить, что при отправке тех же данных в функцию, где аргумент имеет литеральный тип, может привести к неочевидным результатам. Если мы захотим отправить не чистый аргумент, а переменную, объявленную через let, то мы словим приколыч, так как у нас сравниваюся типы при отправке (аргумент ведь имеет только два типа – тут пост и гет). Лет тут является стрингой, а стринга не является постом или гетом

![](_png/57d4952265bc0e76a22d5d8d4f0d3807.png)

Чтобы исправить ситуацию, нужно будет поменять лет на конст и тогда значение автоматом присвоится в тип данных переменной

![](_png/03ffb82570d62dadeaf7f176db148ea3.png)

Либо можно кастануть переменную и задать ей определённый тип данных. Это уже стоит делать только в том случае, если мы данные получаем не из переменной, а из объекта. Делается каст через оператор `as`

![](_png/786b0ef0fe42bafbee6882ef68ced576.png)

Однако берём в учёт, что мы не должны использовать каст в роли фикса от ТСки. Используем только по надобности, когда нет возможности привести типы

![](_png/a0e1167f6a673009dccccc28c2556099.png)

### 022 Type Aliases

И вот пример тайп элиаса (псевдонима). Через ключевое слово «type» мы можем как обычную переменную задать любой тип и использовать этот псевдоним

![](_png/de38073a69d2533e4f3a73d3e95517d7.png)

Элиасы позволяют сократить достаточно сильно код и делать свои шаблоны типизированных объектов. На первом примере стандартное объявление одного объекта. На втором примере можно увидеть тайп элиас (с помощью которого можно объявить сразу несколько новых объектов)

![](_png/a07838f9fc84b7d2ac998955a29f6672.png)![](_png/3d84b9c3ceb1893a78a024422cc205ac.png)

Так же есть и интерсекшн типы. На первом скрине можно увидеть, как были соединены два типа через юнион «`|`» и теперь мы можем запихнуть в объект либо первый тип, либо второй, либо все вместе. Уже оператор «`&`» определяет интерсекшн, который говорит нам, что в данной переменной должны находиться сразу оба типа вместе и никак иначе

Интерсекшн откидывает повторяющиеся поля

![](_png/d016611580019fded512dfb28fffb4db.png)![](_png/a5dd7273c4ac153f3f757e446f0bc99f.png)

### 023 Interfaces

Интерфейсы – это технология, которая позволяет записать типизацию объекта в виде подобным классам. Так же интерфейсы экстендятся как классы (в тайпах нужно было использовать интерсекшн)

![](_png/d062fc79c7c221f4eea6df8bffdac704.png)

Пометочка: функции так же можно вписывать и в тайпах

![](_png/5d86adbcea1ce574572a89b082941db6.png)

Уже таким образом мы можем создать объект-словарь

1) Неопределённое количество свойств – `[наименование: тип]`
2) Значение – тут Юзер

Однако словари создаются обычно через третью запись (дженерик)

![](_png/09d9a8f205f9b4881d7d9fb5fbf34154.png)

### 024 Types или Interfaces

Первой отличительной особенностью интерфейсов является их возможность мёрджа. Если мы объявим два одинаковых интерфейса, то они слипнутся и будут себя вести как один интерфейс

![](_png/3b0ada4a0c90abd1286a76ae75431fb2.png)

Так же тайпы крайне просто работают с простыми типами и позволяют их быстро задать. Интерфейсы же подходят только для работы с объектами

![](_png/de065232a86df2563167255ad7e15276.png)

Если подытожить, то для создания объектов стоит использовать интерфейсы. Они чаще используются так же вместе с классами. Тайпы стоит использовать для простых типов и быстрой реализации

### 025 Optional

Оператор «`?`», который мы пишем сразу после наименований ключей, свойств, аргументов и так далее говорит нам о том, что этот параметр не обязателен.

Конкретно в примере с интерфейсом нам не обязательно теперь в объекте подобного типа указывать свойство пароля. И, как можно было подумать, записать без «`?`», но пометить, что свойство должно быть андефайндом мы не можем (в объекте придётся явно указать, что значением будет андефайнд)

В функции же «`?`» говорит, что нам необязательно передавать такой аргумент. Однако в функции мы уже можем указать, что второй аргумент может быть неопределённым типом и это будет работать подобно «`?`»

![](_png/1c9ab20a6ed3d1febc54b0e6fd4e55ef.png)

Так же нужно упомянуть, что при обращении к свойству объекта с «`?`», нам нужно обязательно прописывать опциональный чейн, так как значения может и не быть (ТС выдаст ошибку в компайл-тайме)

![](_png/acf97b5119423a0747cf4000106a31c2.png)![](_png/44782458a9beeacaf0a9347df138441f.png)

«`!`» – этот оператор, в свою очередь, говорит, что мы точно знаем, что вернётся не `undefined`, а именно наше значение, которое было задано нашему объекту

![](_png/8552c9e22c205f77e38c2aef42cebc20.png)

Так же мы можем устроить проверку и через короткую запись

![](_png/2cf3d434112a6e0fc211b161b1ec75d8.png)

«`??`» - оператор, который проверяет на `null` или `undefined`. Конкретно тут используется такая конструкция, так как парам – это опциональный аргумент и его мы можем не передать, а значить проверить на его наличие нам нужно

![](_png/d9faaff80a7731136cccb95b1cf28a73.png)

### 026 Упражнение - Типизируем ответ сервера

Это первый способ типизации. Он имеет небольшие минусы в виде того, что нам нужно будет как-то разделять успешный запрос от безуспешного

![](_png/dd29a0d6c1f063bf445a90d0391f0fca.png)

Это уже более удачный вариант запроса, который поделен на два разных интерфейса

![](_png/53474d38567e87aec41e5242aa7263c5.png)

И вот примерно так реализуется вывод удачного и неудачного запроса на сервер (функция возвращает объекты по типу этих двух интерфейсов)

![](_png/3d724c87e7ac43b7b9da4d73a122b7f0.png)

### 027 Void

`void` – это особый тип данных, который нам говорит, что функция ничего не возвращает. Функция может возвращать какое-либо значение, но мы ни в коем случае не будем его принимать и не будем ничего возвращать. 

> `void != undefined`

Конкретно в этом случае, константа «`а`» будет иметь тип `void`

![](_png/fdf13c218c37181b5bf8e9bdb2f928b7.png)

А уже в этом примере вернётся хотя бы `undefined`

![](_png/74b00ca62a4d460782e5487d58079bb3.png)

### 028 Unknown

`unknown` – это более строгий тип `any`. Он запрещает себя присваивать в другие типы, которые не являются такими же `unknown` или `any`. Используется этот тип в тех случаях, когда мы не знаем, что за тип нам предстоит получить в переменную. И вообще, когда не понятно, что мы получаем, этот тип стоит вставлять

![](_png/c359f7193830ce44aeab1130f3e6e1e6.png)![](_png/001b5549579e36aa066e31340039e5b5.png)

Привычное сужение типов указать для переменной не получится (в одном условии получится указать тип, но в остальных так же останется `unknown`)

![](_png/073c213aa7045b3f8907613e3fbee2ef.png)

Ну и дальше идёт кейс по ошибкам. Раньше еррор имел тип эни, но с версии «4.4», `error` – это непонятный тип. Теперь чтобы работать с ошибкой, нужно добавлять дополнительную конструкцию, которая будет проверять нам, что мы работаем конкретно с ошибкой

1) Проверяем ошибку по инстансу объекта
2) Делаем проверку через присваивание переменной к ошибке (не самый лучший вариант)

![](_png/42bb4f7ac57dd3bf43c639aa5e2f4636.png)

И тут нужно пояснить, что или «`|`» выбирает тип для переменной из более общего значения (всегда будет `unknown`), а «`&`» выбирает самое меньшее (`string` более конкретный тип данных)

![](_png/2b9afe6b638529c524fb379b3e860389.png)

### 029 Never

И как можно увидеть по первым примерам, тип данных `never` говорит нам, что функция никогда не возвращает значение. Объекты с таким типом абсолютно никогда ничего не возвращают и ничего возвращать нельзя

![](_png/8b4ce1fe9fb5bc98d8a00fd7eacdd9d4.png)

Если `void` вполне себе может хранить `undefined`, так как `void` – это отсутствие значения, то `never` запрещает возвращать значение

![](_png/ad36374c7cac1d9ed33cf91b737d189d.png)

И вот первый кейс, где можно использовать тип `never`. Он позволяет показать, что программа не заходит в данную ветку

Тут нужно пометить, что если константу назвать «`_`», то компилятор не будет ругаться на то, что в ней нет значений

![](_png/857d3b84e32cdcaa1ffae809deb5269d.png)![](_png/a33bfd66ae360b0b4002766d6ef495ca.png)

И тут представлен пример, когда мы явно задаём аргументу типы строки и числа. На выходе мы должны получить `boolean` значение. Внутри функции мы проверили получаемое значение и видим, что компилятор говорит нам, что может вернуться из функции `undefined` (если нет `return`, то функция возвращает `undefined`, тут - третий `return`)

![](_png/d34dfa9be152772d7ba8e9bf5c3c9a88.png)

Однако, если мы добавим срабатывание функции, которая будет иметь тип невер (никогда ничего не возвращается), то наш третий андефайн будет закрыт этой функцией

![](_png/feb61e76d538e47ecdf13703c8a668bb.png)

> `never` используется для явной блокировки определённых веток выполнения программы

### 030 Null

Первым делом нужно отметить, что в ТС нельзя (в отличие от нативки) присвоить любому типу налл. Мы это можем сделать только изначально наллу или для эни.

![](_png/9b98266dd008c64d18a199d3c6569c3d.png)

Однако это спокойно настраивается из под настроек компилятора ТС

![](_png/7fdef6d2186f859ec22095a0779225a3.png)![](_png/2b968666d2e63e328c239721df80b9e0.png)

Однако эту проверку убирать не стоит. Она может во многом помочь.

Конкретно в данном коде мы возвращаем с вероятностью в 50% либо пустое значение, либо объект (который возвращаем в качестве юзера, так как мы не задали тип для функции)

![](_png/03622a27a3215db616cc4982e7b1c3c1.png)

Однако стоит разграничить между друг другом эти понятия: null и undefined. Первый мы используем осознанно (подставляем самостоятельно) и не можем получить в результате выполнения кода JS. Второй же мы можем получить в результате выполнения кода JS

И примерно так уже должна выглядеть правильное написание кода, когда мы точно знаем, что можем не вернуть значение и впоследствии проверяем на это

![](_png/a641977b8c0a9779745d712208e9d086.png)

### 031 Приведение типов

Обычное приведение типов в нативке

![](_png/e167c01d96a83f5d0c15941c01049713.png)

Тут нужно отметить, что при создании новой переменной через интерфейс конструктора, тип данных будет не «`string`», а «`String`»

![](_png/8a6f10d2e8abd0fc860bf367e18b617f.png)

Типизирование объекта тремя способами:

Последний способ лучше не использовать – он будет конфликтовать с Реактом

![](_png/146d9c4c39c50a719ab0870dfd1655be.png)![](_png/d1272efa9afd0ce069d2bc0b62ceb838.png)
![](_png/a0c60b77eae7e11df2f61b704f0112e1.png)

И так же тут представлен пример создания отдельного пользователя через деструктуризацию прошлого объекта. Однако тут у нас получится объект шире, чем изначальный

![](_png/c3ee9cccedfa407d18d3ebdbf9cdbfee.png)

Рекомендуется возвращать объекты через функцию (тогда в админе останутся только данные свойства)

![](_png/87767426714f20e12a3bb9c9ea52d924.png)

### 032 Type Guard

Это представлено обычное сужение типов, через которое мы можем обратиться к нужному нам типу определённого значения

![](_png/9f471ad27f6c285cfc2df3f5d409bce8.png)

Тут уже показана реализация тайпгуарда. Он всегда возвращает нужный нам тип объекта (проводит проверку на тип). По сути своей он заменяет нам работу булеана на более прозрачную и показывает нам точно, что должна вернуть такая проверка

![](_png/0e6f360f67d2c254bdd8a1d00104bcd3.png)

И вот пример, где мы создали гуардиана для более сложного типа данных

![](_png/977e8e8ca258d1e08a9a49ef5baa91ab.png)

А уже тут проверка идёт через присвоение юзера к админу и если у юзера имеется нужное нам свойство (не = `undefined`), то вернётся админ (нужный интерфейс)

![](_png/ce8a45448f04ad4d6c1176819b761be9.png)

### 033 Упражнение - Делаем typeguard ответа

Отправная точка написания кода

```TypeScript
interface IPayment {  
   sum: number;  
   from: number;  
   to: number;  
}  
  
enum PaymentStatus {  
   Success = 'success',  
   Failed = 'failed',  
}  
  
interface IPaymentRequest extends IPayment { }  
  
interface IDataSuccess extends IPayment {  
   databaseId: number;  
}  
  
interface IDataFailed {  
   errorMessage: string;  
   errorCode: number;  
}  
  
interface IResponseSuccess {  
   status: PaymentStatus.Success;  
   data: IDataSuccess;  
}  
  
interface IResponseFailed {  
   status: PaymentStatus.Failed;  
   data: IDataFailed;  
}
```

Задание. Написать функцию, которая будет возвращать число (`id` ответа от респонса)

```TypeScript
type f = (res: IResponseSuccess | IResponseFailed) => number;
```

Решение. Сразу хочется сказать, что это излишний код для проверки свойства

```TypeScript
type res = IResponseSuccess | IResponseFailed;  
function responseChecker(res: res): number {  
   if (responseGuard(res)) {  
      return res.data.databaseId; // в фейле нет свойства databaseId  
   } else {  
      throw new Error(res.data.errorMessage); // только в фейле есть свойство ошибки  
   }  
}  
  
function responseGuard(res): res is IResponseSuccess {  
   if (res.data === "IDataFailed") {  
      return true;  
   }  
   return false;  
}
```
