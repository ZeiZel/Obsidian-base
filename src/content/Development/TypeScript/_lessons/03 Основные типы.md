## Глава 3 - Основные типы

![](_png/8972c51fc89c2fab984a6a2e2568047d.png)

### 009 Подготовка проекта

Команды для подключения и запуска ТСки:

```bash
npm i -g typescript // устанавливаем ТС глобально

mkdir ts // создание папки с именем «ts»

cd ts // переход в данную папку

tsc --init // инициализация ТС в нашем проекте (пока находимся в нём)
```

И с помощью команды `tsc` мы будем компилировать наш ТС-файл в нативный JS

![](_png/2d129a408fa851894370daba05d6f93b.png)

### 010 Использование типов

Собственно, запись различных типов на примере нативного JS

![](_png/750cfa5141c6419a1e6ea2b08cdebe3c.png)

И, как можно увидеть, так как ТС – это надстройка, то и писать можно в нём спокойно по правилам JS

`tsc` – сначала всегда компиляция

`node app.js` – запустит конкретный файл в консоли (запускаем только скомпилированный JS файл)

```TS
const salary = 1000;
const prem = 1500;

console.log(salary + prem);
```

Нативный JS так же позволяет нам сложить строку с числом и это приведёт к очевидной конкатенации строк, что нам не нужно

```TS
const salary: number = 1000;
const prem = "500";
let res = salary + prem; // 1000500

console.log(res);
```

Если в качестве результата укажем, что мы должны всегда получать число, то тут у нас встанет проблема, потому что одно из значений не является `number` и потому результат присваивается в строковую переменную

![](_png/6e5d240bae64c25a89efc358e8985fc9.png)

Если указать типы вообще всем переменным, то мы увидим, что ошибка находится уже на уровне создания самой переменной

```TS
const salary: number = 1000;
const prem: number = "500"; // error
let res: number = salary + prem;

console.log(res);
```

### 011 Типы в функциях

Изначально мы обязаны писать типы для функции. По умолчанию компилятор предлагает нам устанавливать `any` на все переменные, которые мы не протипизировали 

![](_png/30b59f9b594071ba3c6657885f100489.png)

Чтобы `any` стоял по умолчанию, мы можем в конфиге раскомментировать данную строку:

`tsconfig.json`
```JSON
"noImplicitAny": false
```

И теперь ошибок нет- мы можем не подписывать `any`

![](_png/e0bfce20c602a793f79338a14dd2851d.png)

В обычной ситуации мы можем указать типы как для аргументов, так и для самой функции после объявления аргументов

Запись типов для стрелочной функции выглядит так же

```TS
function getName(name: string, surname: string): string {
	return `${name} ${surname}` 
}

const getNameArrow = (name: string, surname: string): string {
	return `${name} ${surname}` 
}
```

Если убрать типы, то у нас будет работать динамическая типизация по умолчанию

```TS
function getName(name, surname) {
	return `${name} ${surname}` 
}

console.log(getName(true, false)); // выйдет строка true false
```

Однако стоит прописать типы и уже мы не сможем передать другие типы в тут обозначенную строку

```TS
function getName(name: string, surname: string): string {
	return `${name} ${surname}` 
}

console.log(getName('Valery', true)); // Error
```

### 012 Объекты

При обработке объекта мы можем указать типы данных на получаемые строки из этого объекта

![](_png/dc2e896c03a55327a8b5bba42b4d9753.png)

А если мы попытаемся обратиться к свойству, которого нет в объекте, то мы получим ошибку, что позволяет нам обезопасить обращение к получаемому объекту

![](_png/3014e0726ee7fc3aae12bddb70c5d402.png)

### 013 Упражнение - Типизируем объект

При получении объекта с сервера, мы можем указать его типы заранее до получения, чтобы знать, какой тип данных мы будем получать. И тут показана типизация всего объекта и его получение

![](_png/3ba619111aac4beaade00b5e74eff9a2.png)

### 014 Массивы

Массивы указываются как обычные типы, но с квадратными скобками. Так же можно увидеть, что редактор нам отображает типы, с которыми мы работаем (как можно увидеть в редьюсе). Так же можно задать самостоятельно типы для аргументов (только тогда аргумент нужно писать обязательно в скобочках)

![](_png/5ecfe38c13f7498a60fb94566c449309.png)

Если мы дальше по массиву вернём число (мэп вернёт числа в массив), то это число будет работать и дальше. В консоль выйдет строка «2»

![](_png/afd35565fff8e3e1e3edcdda52c14ab5.png)

### 015 Tuples

Tuples или кортежи – это массивы, которым мы задали определённый список на типы данных

1) Массив без определённого типа данных – можно поместить всё
2) Массив из одного элемента (можно через запятую указывать какие типы данных будет иметь каждая позиция)
3) Массив с определённым типом данных
4) Юнион – он хранит определённый разрез типов данных (тут на примере вмещает в себя и стрингу, и число)

![](_png/4a2ac18edd3a60891d16e7a53f310ccc.png)

Конкретно тут был создан ограниченный массив из числа и строки – больше вписать в него не получится. Мы можем получить эти значения. Однако, если мы захотим получить ещё один элемент сверх указанной нормы, то у нас ничего не получится

![](_png/a455bf8fb98cf08721b281072875b748.png)

Запушить новый объект в массив мы сможем (так как в процессе работы массив спокойно может получать новые значения), а получить их напрямую не получится

![](_png/6bbb32dcbd60e325dbc814dec0fe1bd7.png)

Более короткий формат записи создания и получения сразу нескольких переменных по значениям массива

![](_png/6f9e4e72ca06acb5bcc52d98345d70d0.png)

В таплах можно задать как массивы определённых типов, так и добавить этот массив со спредом (чтобы просто вписывать значения массива без вложения его в массив внутри)

![](_png/4281e2ae5ef705f3e91d7c997f0eac44.png)

### 016 Readonly

Кратко опишем проблему. Когда мы пытаемся поменять значение у константы, JS нас бьёт по рукам и запрещает это делать. Когда мы меняем значения под индексами у массивов, то мы спокойно это можем сделать, потому как мы в качестве константы устанавливаем ссылку на массив

![](_png/21fb0a91e41381f5bc62ab5b8d7b77b0.png)

Однако на массив мы можем установить модификатор ридонли и будем получать по рукам при попытке изменения этого массива

![](_png/c03c686f7eb3b2fca68f7bc8e4d652e3.png)

И вот примерно так выглядят массивы с ридонли

1) Тут представлен обычный массив строк
2) Тут уже массив строк, который изменять нельзя. Сколько будет и какие будут базовые значения, такими они и останутся – изменить нельзя
3) Тут показан пример создания массива строк через дженерик. Он работает аналогично первому примеру
4) Это дженерик ридонли массива `<строкового>`. Как видно, запушить в него новое значение так же нельзя и изменять тоже. Это просто ещё одна вариация записи ридонли массива через дженерик

![](_png/f89f7aef94066ccf2efadc34973d2d86.png)

### 017 Enums

Представим такую ситуацию. Мы проверяем запрос от сервера и при успешном выполнении мы должны выполнить определённую логику. Проблема заключается в том, что мы можем допустить ошибку в записи результата объекта и получить неверную логику выполнения программы

![](_png/61f566ed35c382d9f7106f164e6744be.png)

Более правильным вариантом в нативке будет использование отдельной константы

![](_png/7ec9e99e95c8e6f479c71a252232378e.png)

И для решения этой проблемы в ТС используют енамы. Это определённые объектоподобные конструкции, которые хранят в себе фиксированные значения. Тут мы задаём наши параметры статуса и можем спокойно их использовать в любом удобном для нас месте

Хочется дополнить, что енамы активно используются в очень маленьких либо монолитных проектах

![](_png/bb09937331b6dca60702392c509e826f.png)

Есть множество вариантов записи и задания значений для наших енамов. Можно оставить их по умолчанию и тогда присвоение будет идти с 0. Можно начать со своего числа. Можно задать свои значения разным свойствам. Можно задать строковые значения (но это уже будет неудобно)

![](_png/9f8fd0d0453933dd402758bec9e2c925.png)![](_png/746d0fbbee817bbeccc843aa9010d8c6.png)
![](_png/47c4ab738f630d76e0c2585ba9084f5a.png)
![](_png/5280ff796c26d1fe45e24b643e53a3f4.png)

Так же енам может быть гетерогенным и вполне себе состоять из чисел и строк

![](_png/4b76da9b19e90842d08e096ade5395f8.png)

Так же можно в качестве типа данных указать наш енам, чтобы функция могла принять только его. Тут стоит указать такую особенность, что гетерогенный енам (который указан чуть выше) из-за того, что имеет в себе числа до сих пор ведёт себя как числовой, поэтому мы не сможем передать текст, который был присвоен для значения енама

![](_png/b40245ac4c7ebc230d2d42bffc7253ae.png)

В качестве значений для енама можно присваивать спокойно результаты математических вычислений. Однако не стоит использовать для них функции, которые могут отправлять запросы на сервер, так как код может не успеть выполниться и вернуть `undefined`

![](_png/f5fcf94d758f215b35d15a8a08e0cc91.png)

Енамы могут вести себя похоже на объекты

![](_png/73d1297e514a02b5e36b9eedd8a83b53.png)

Так же нужно отметить, что енамы в рабочем проекте существуют ровно до рантайма (так как они находятся только в пределах тайпскрипта, который компилируется в JS). Уже в сам JS они переходят в виде IIFE-функций

![](_png/0ebdfb5482c120b4ce392f93f74f0c4b.png)

Однако, если мы объявим енам в виде константы, то компилятор будет искать все вхождения енама в код и приравнивать только их. То есть мы отказываемся от фукнкции, которая может замедлить наш код

![](_png/3ec15007c07f8103adffdc71eb04c32e.png)
![](_png/53fe80ed098284bf8872188b03b66237.png)

### 018 Упражнение - Типизируем функцию

Сейчас нужно немного разобрать монстра типизации, который за счёт неё съел пространства больше, чем сама функция. Конкретно тут нам показан код, который представляет из себя: мы получили данные -> это должно выйти из полученных данных

Заранее нужно упомянуть, то все такие большие типизации убираются в интерфейсы и типы, а затем уже вызываются отдельно, чтобы не перепрописывать постоянно так много кода.

Так же когда мы в качестве типа указываем енам, нам нужно поставить после имени ключа оператор «?», который скажет, что может быть несколько значений енама

Итак. Первым делом тут описан статус, который может иметь три позиции. Дальше типизируем получаемые данные, которые представляют из себя два свойства: топик и статус. Потом типизируем функцию. Её тип будет сформирован дженериком `Promise<{}[]>` - то есть это будет массив объектов. Объекту мы внутри описали все типы. В идеале эту структуру изнутри промиса нужно описать и для нашей выводимой даты

![](_png/b4cf6f98f3e732f1ae31993040c711fc.png)