## 016 Устройство Node.js

В начале 2000-х годов у нас были стандартный многопоточные серверы. Один поток процессора сервера выполнял один запрос от пользователя. 
Основная проблема заключалась в том, что 1 поток занимал 1 мб памяти и само переключение потоков требовало определённых ресурсов компьютера. 

![](_png/ca3954290c618621c73d4fe5a58a6560.png)

Далее проблема переходила в то, что наш поток блокировался в процессе выполнения своих операций и простаивал пока происходило логирование данных, получение данных из базы и происходил сам рендер шаблона 

![](_png/c536f521a9d2bfb8b8a6a51925717b81.png)

Так же вследствие того, что поток занимал 1 мб памяти, то при выделении большого количества потоков, у нас может появиться стопор в виде недостатка памяти (а на момент начала 21-ого века 10 гб памяти было большой цифрой) 

![](_png/909de34b3bb47744ed3469b627c5e1cd.png)

Поэтому вдальнейшем была придумана система, при которой наш поток не блокируется

![](_png/96bd89d35ac9c23c52c37424d62b5636.png)

Поэтому схема, которая работала раньше, преобразуется уже в другую: 
1) Мы имеем запросы
2) Все они поступают в основной поток, который выполняет задачи запросов
3) Если задача достаточно тяжёлая, то она отправляется на дополнительный поток сервера (например, криптография, чтение файлов и так далее)

![](_png/79d97bfef570b58d88d57cbe16074bdc.png)

Так же в ноде существуют такие понятия как: стек и куча.
1) Куча хранит в себе переменные
2) Стек - это хранилище стека вызова функций

Конкретно тут мы видим ситуацию со схемы выше. Стек - это основной поток, который выполняет все операции. Конкретно функция `setTimeout` не будет блокировать все остальные операции - она вынесется в дополнительный поток, где и обработается.

==node== - это не однопоточный фреймворк. Это фреймворк, который имеет один основной поток (стек вызовов) и множество дополнительных потоков, в котором выполняются более затратные операции.

![](_png/37f49ed67ea593ae51ef35a1a953f7ae.png)

Составляющие ==NodeJS==:
1) Движок ==V8== (виртуальная машина JS), который разрабатывается в ==google== и находится в хроме;
2) Библиотека LibUV. Она реализует концепцию Event Loop, Thread Pool и асинхронный ввод/вывод;
3) Стандартная библиотека. Она содержит в себе функциональность работы с файловой системой, криптографией, ивентами и всеми остальными функциями ноды (аналог - WebAPI);
4) Далее наш код будет биндиться в C/C++ код, который уже будет выполнять эффективные операции над нашими операциями;
5) Так же мы можем подключать C/C++ аддоны к нашему приложению;
6) NodeJS API

![](_png/7f633bfd05d383bdd744f1237c527df2.png)

К нам пришёл на сервер запрос от пользователя, первым делом он попадает в движок V8 откуда попадает в биндер ноды, уже который переводит запрос в очередь событий. В рамках очереди событий, у нас есть Event Loop, который крутится и обслуживает всю нашу систему. После же Event Loop отправляет все задачи в Callstack (тот самый основной поток - Stack), где задача и выполняется на движке V8, либо, если встречается тяжёлая задача, она идёт на выполнение в отдельный поток. После выполнения задачи уже из этого стека результат задачи идёт обратно в ивент луп, откуда и передаётся обратно на входные системы для выдачи ответа.
Если выполнилась тяжёлая задача, то её коллбэки будут передаваться обратно в очередь событий, откуда пройдёт стандартный путь стандартной задачи.

![](_png/836d1160990d01d8d2ea158eda6d3f96.png)

## 017 Event Loop

Event Loop имеет свои фазы, которые описаны в его документации. Самой важной и основной является четвёртая, потому как нода очень быстро работает с вводом/выводом.

![](_png/71a521ceada31c6ef33d4b62352368f4.png)

Так как указаны не все выполняемые элементы языка, то между этими фазами выполняются остальные функции (те же промисы)

![](_png/71db9611e4b2f9383ca70e71a5c8ae11.png)

В полной картине выполнения ивент лупа выполняется в самом начале инициализация всех импортов и функций. Далее по порядку выполяются все элементы ивент лупа. Потом ивент луп проверяет, на закончена ли программа (например, если в моменте совершения лупа таймер был 3 секунды, то луп повторяется до тех пор, пока время таймера не кончится и не выполнится операция).

![](_png/1d1d3c6bc04d60713bc87a9f0a6c651d.png)

## 018 Таймеры

Первое, что нужно отметить это то, что таймер не гарантирует нам выполнение функции ровно в то время, которое мы указали. Он гарантирует нам, что функция сработает не раньше указанного времени. И чем более высоконагруженные задачи будут в стеке, тем на большее время будет отдаляться выполнение функции от таймера  

```JS
const start = performance.now();

setTimeout(() => {
	console.log(performance.now() - start);

	console.log("Прошла секунда");
}, 1000);
```
![](_png/cee3bb2cdcaa6782f0bff393c25dc5c1.png)

Чтобы вызывать таймаут с аргументами, нужно просто перечислить их через запятую

```JS
function myFunc(arg) {
	console.log(arg);
}

setTimeout(myFunc, 1000, "Этот мир");
```

Так же мы можем отменять выполнение таймера через `clearTimeout()`

```JS
const timerId = setTimeout(() => {
	console.log("BOOOOOM!");
}, 5000);

setTimeout(() => {
	clearTimeout(timerId);
	console.log("Таймер очищен");
}, 1000);

```

И так же мы можем отменить работу интервала. Интервал `setInterval()` уже повторяет функцию каждое определённое время.

```JS
const intervalId = setInterval(() => {
	console.log(performance.now());
}, 1000);

setTimeout(() => {
	clearTimeout(intervalId);
	console.log("Интервал очищен");
}, 5000);
```
![](_png/e4f328a4f6219ba035e3a6a00539ca1b.png)

Функция `setImmediate()` мгновенно выполняет функцию сразу в самом конце программы

```JS
console.log("Начало");

setImmediate(() => {
	console.log("Immediate");
});

console.log("Конец");
```
![](_png/c2de61fb7aa794763bdec056c82d14b7.png)

Так же мы можем убрать ссылку из стека на таймер через функцию `unref()` 

```JS
const timerId = setTimeout(() => {
	console.log("BOOOOOM!");
}, 5000);

timerId.unref(); // таймер не отработает
```

Но так же мы можем обратно вернуть ссылку на таймер, чтобы он выполнился через `ref()`

```JS
const timerId = setTimeout(() => {
	console.log("BOOOOOM!");
}, 5000);

timerId.unref(); // таймер отцеплен

setImmediate(() => {
	timerId.ref(); // таймер обратно прицепили и выполнили
})
```

## 019 Пример работы event loop


>[!note] Фазы Event Loop
>- инициализация
>- ---
> #### Фазы
> - таймеры
> - pending callbacks
> - idle, prepare
> - poll
> - check
> - close callback
> ---
> - проверка на окончание

Мы проинициализировали все функции в нашем коде, выполнили все синхронные функции, затем уже приступили к выполнению асинхронных функций. Конкретно тут видно, что функция таймаута задержалась на выполнение последнего `console.log` и поэтому сильно отдалилась в выполнении от начального значения 

```JS
console.log("Начало");

// таймер
setTimeout(() => {
	console.log(performance.now(), " timer 0ms");
}, 0);

console.log("Конец");
```
![](_png/c70c43ac3167bfdd4049fdb23c9649d5.png)

Функция `setImmediate` относится к завершающим, поэтому она выполняется в конце порядка этой фазы ивент лупа

```JS
console.log("Начало");

// таймер
setTimeout(() => {
	console.log(performance.now(), " timer 0ms");
}, 0);

// check
setImmediate(() => {
	console.log("Immediate");
});

console.log("Конец");
```
![](_png/3d6bf252f39f8066234921ebb3c265d5.png)

Дальше мы встречаемся с тем, что `setImmediate` выполнился до нашего таймаута. Почему?
Мы входим в первую фазу ивент лупа, смотрим, что таймер незарезолвен, так как его таймер не вышел, дальше уже идёт пункт `check`, где и вызвается `setImmediate`, и он там и вызывается.
Уже во второй фазе ивент лупа наш таймаут зарезолвен, что даёт нам возможность его выполнить, и вот уже сейчас его результат выведен.

```JS
console.log("Начало");

// таймер
setTimeout(() => {
	console.log(performance.now(), " timer 0ms");
}, 100);

// check
setImmediate(() => {
	console.log("Immediate");
});

console.log("Конец");

```
![](_png/3bbf729717dd75aee3e89426fe4a66a7.png)

Уже тут ивент луп выполняет три круга. Выполняет иммедиэйт. На втором получает ответ от асинхронного прочтения файла через `fs` и выполняет его колбэк-функцию. На третьем резолвится таймер и выполняется его коллбэк

```JS
const fs = require("fs");

console.log("Начало");

// таймер
setTimeout(() => {
	console.log(performance.now(), " timer 100ms");
}, 100);

// check
setImmediate(() => {
	console.log("Immediate");
});

// poll
fs.readFile(__dirname, () => {
	console.log("File was read(?)!");
});

console.log("Конец");
```
![](_png/9b5657b613a48ede20dc4ea14dca2614.png)

Тут уже нужно описать несколько моментов:
1) ==Большая операция==. Мы имеем крайне тяжеловесную операцию, которая выполняется самой первой, так как по времени она зарезолвлена сразу. Из-за неё фаза стопорится и прошлый таймер, так как он уже проверен был, выполнится намного позже - только на следующем заходе в новую фазу.
2) ==Промис==. Он выполнился на этапе `microtask, nextTick`, который выполняется сразу **после каждого** этапа нашей фазы ивент лупа!

```JS
const fs = require("fs");

console.log("Начало");

// таймер
setTimeout(() => {
	console.log(performance.now(), " timer 100ms");
}, 100);

// check
setImmediate(() => {
	console.log("Immediate");
});

// poll
fs.readFile(__dirname, () => {
	console.log("File was read(?)!");
});

// большая операция
setTimeout(() => {
	for (let i = 0; i < 1000000000; i++) {}
	console.log("Big operation done")
});

// microtask, nextTick
Promise.resolve().then(() => {
	console.log("Promise");
});

console.log("Конец");
```
![](_png/9cfab44a4ab705e0c1e100ecd283e629.png)

И примерно так выглядят фазы, если мы включим в схему выполнение промисов

```md
- инициализация

## Фазы
// microtask, nextTick
- таймеры
// microtask, nextTick
- pending callbacks
// microtask, nextTick
- idle, prepare
// microtask, nextTick
- poll
// microtask, nextTick
- check
// microtask, nextTick
- close callback

- проверка на окончание
```

Ну и так же если мы воткнём в большую операцию промис, то он начнёт выполняться сразу после неё:

```JS
// большая операция
setTimeout(() => {
	for (let i = 0; i < 1000000000; i++) {}
	console.log("Big operation done");
	// microtask, nextTick
	Promise.resolve().then(() => {
		console.log("Promise timeout");
	});
});
```
![](_png/7004c0746ca91f42df2cee25165dcc26.png)

Ну и так же `process.nextTick()`, который выполняется вместе с промисом после каждой фазы. 
Сама тиковая операция очень важна, когда мы совершаем те же htttp-реквесты или для регистрации обработчиков некоторых событий.

```JS
const fs = require("fs");

console.log("Начало");

// таймер
setTimeout(() => {
	console.log(performance.now(), " timer 100ms");
}, 100);

// check
setImmediate(() => {
	console.log("Immediate");
});

// poll
fs.readFile(__dirname, () => {
	console.log("File was read(?)!");
});

// большая операция
setTimeout(() => {
	for (let i = 0; i < 1000000000; i++) {}
	console.log("Big operation done");
	// microtask, nextTick
	Promise.resolve().then(() => {
		console.log("Promise timeout");
	});
});

// microtask, nextTick
Promise.resolve().then(() => {
	console.log("Promise");
});

// nextTick
process.nextTick(() => console.log("Tick"));

console.log("Конец");
```
![](_png/86a5711a2035ef1a77f683bf64e95f82.png)

## 020 Stack вызова

==Стек вызовов (Call Stack)== в JS устроен по принципу LIFO (Last In, First Out — последним вошёл, первым вышел). Цикл событий постоянно проверяет стек вызовов на предмет того, имеется ли в нём функция, которую нужно выполнить. Если при выполнении кода в нём встречается вызов некоей функции, сведения о ней добавляются в стек вызовов и производится выполнение этой функции.

Конкретно тут в примере мы видим по шагам, как выполняется логирование результата функции и куда попадают и где сохраняются наши результаты внутри системы стека. 

![](_png/bf747e0f995604a5d1235c66203a538f.png)
![](_png/28c226b86318cb1fa2a2d8818a6f91f5.png)
![](_png/ff9b777e70a8a426f583a7e46cf81118.png)
![](_png/1cded64d2ca66577729ebe1032b04d37.png)
![](_png/307a2364970dfe8ad0634cc66c43fd2e.png)
![](_png/586d097bc41af680dd922f60c4917852.png)
![](_png/5ab0185148b0ae029e5d9a0418a7e799.png)

Уже в этом примере можно увидеть, что таймер после инициализации в стеке сразу из него выходит, чтобы не стопорить стек, и чтобы тот продолжал свою работу в стандартном режиме 

![](_png/2286652884dc6f23913a1fd2ad2f5244.png)
![](_png/a9e64ab9c7752d762f8c6c805e36d238.png)
![](_png/5214643ea04be649a1a79969de55c35e.png)
![](_png/92cf67a1c0b41232a800589232e4398d.png)
![](_png/f11cffc641ca2464bc36a5d09d5af4ee.png)
![](_png/4ff4997a9fc86f932cdae5bcb1528793.png)

Чтобы просмотреть стек вызова, мы можем зайти в отладчик внутри VSCode и в нём просмотреть все полученные значения стека вызова

![](_png/924511bf3cf0a3170e76019450911f0a.png)

>[!info] Особенности стека
> - Стек может быть переполнен (err: StackExided). Произойти ошибка может, если была запущена рекурсивная функция без явного конца

## 021 Worker threads

Это упрощённая схема работы воркера. Из стека тяжёлые задачи попадают в воркер, а уже из него возвращаются колбэки тех тяжёлых задач. Однако не все задачи попадают в отдельные воркеры.

![](_png/454943cf87b73956b4b095120b6213b4.png)

На самом деле рабочий поток предоставляется нашим задачам, если на то будут оправданы ресурсы. В основном процессе все наши функции очень тесно соприкасаются с ==C++==, который и обрабатывает запросы на выполнение от ==JS==, либо отправляет задачу в один из рабочих процессов. 
По умолчанию рабочих процессов всего 4 (как установлено в ==libuv==)

![](_png/0008f9a59574e26a0b2a1877b3aef9c4.png)

Каждый поток, грубо говоря - это одно ядро процессора. 4 треда - это условный четырёхядерный процессор, который может без потери производительности выполнять операции. Если мы хотим выделить 8 воркер тредов на 4-хядерном процессоре, то эти потоки будут выполняться последовательно.  
Конкретно под воркер тред выделяются задачи по работе с файловой системой, днс.лукап, редкие пайпы и тяжёлые для ЦПУ задачи (то же шифрование) 

![](_png/17fbfb53d7dce64d1714956e8d077664.png)

Сейчас мы можем чётко увидеть, что у нас выделено всего 4 воркер треда по умолчанию на выполнение тяжёлых задач 

```JS
// подключение библиотеки шифрования
const crypto = require("crypto");

// фиксируем начало выполнения
const start = performance.now();

// выполняем шифрование
for (let i = 0; i < 50; i++) {
	crypto.pbkdf2("test", "salt", 100000, 64, "sha512", () => {
		console.log(performance.now() - start);
	});
}
```
![](_png/2a867094fa54809fc24e829d5bdd3b69.png)

Так же мы можем выделить большее количество ядер для выполнения операции. 
Зачастую такая настройка не нужна, так как мы запускаем сервер в контейнере на виртуальных процессорах.

```JS
// подключение библиотеки шифрования
const crypto = require("crypto");

// фиксируем начало выполнения
const start = performance.now();

// увеличиваем количество воркер тредов до 8
process.env.UV_THREADPOOL_SIZE = 8;

// выполняем шифрование
for (let i = 0; i < 50; i++) {
	crypto.pbkdf2("test", "salt", 100000, 64, "sha512", () => {
		console.log(performance.now() - start);
	});
}
```

Ну и так же мы можем отправлять запросы на сервер с такой же проверкой времени

```JS
// подключение библиотеки запросов
const https = require("https");

// фиксируем начало выполнения
const start = performance.now();

// выполняем отправку запросов
for (let i = 0; i < 50; i++) {
	// отравляем запрос яндексу на получение данных
	https.get("https://www.yandex.ru", (res) => { // получаем результат
		// если мы получаем данные, то что-то делаем
		res.on("data", () => {});
		// срабатывает, когда получаем последний байт данных
		res.on("end", () => {
			console.log(performance.now() - start);
		});
	});
}
```
![](_png/0236cf0c66712bee5bcd2d0ed8fe51f5.png)

## 022 Измерение производительности

Стандартный способ измерения производительности производится через `performance.mark()` + `performance.measure()`, которые нам позволяют отмерить промежуток выполнения определённых операций

```JS
function slow() {
	// делаем отметку по времени - начало
	performance.mark("start");
	const arr = [];
	for (let i = 0; i < 100000000; i++) {
		arr.push(i * i);
	}
	// делаем отметку по времени - конец
	performance.mark("end");

	// и тут будет происходить подсчёт времени нашей производительности
	performance.measure("slow", "start", "end");

	// получает все наши измерения
	console.log(performance.getEntries());
	// получает только одно наше измерение по имени
	console.log(performance.getEntriesByName("slow"));
}
slow();
```
![](_png/573ae19c4b05eb80450c32d3a657653f.png)

Ну и есть второй способ: используя хуки производительности

```JS
// импортируем хук производительности
// хук - это элемент, который позволяет на что-то подписаться
const perf_hooks = require("perf_hooks");

// оборачиваем функцию теста в хук проверки затраченного времени, чтобы определить затраты
test = perf_hooks.performance.timerify(test);

// и тут инстанциируем сам обзёрвер
const performanceObserver = new perf_hooks.PerformanceObserver(
	(items, observer) => {
		// получаем все элементы
		console.log(items.getEntries());
		// получаем последний элемент нашей нужной нам функции
		const entry = items.getEntriesByName("slow").pop();
		// имя вхождения и время выполнения
		console.log(`${entry.name}: ${entry.duration}`);
		// отключаем сам обзёрвер
		observer.disconnect();
	}
);

// и тут указываем откуда получаем время выполнения
performanceObserver.observe({ entryTypes: ["measure", "function"] });

function test() {
	const arr = [];
	for (let i = 0; i < 100000000; i++) {
		arr.push(i * i);
	}
}

function slow() {
	// делаем отметку по времени - начало
	performance.mark("start");
	const arr = [];
	for (let i = 0; i < 100000000; i++) {
		arr.push(i * i);
	}
	// делаем отметку по времени - конец
	performance.mark("end");

	// и тут будет происходить подсчёт времени нашей производительности
	performance.measure("slow", "start", "end");

	// получает только одно наше измерение по имени
	console.log(performance.getEntriesByName("slow"));
}

slow();
test();
```
![](_png/62e34a890883a4b5cece03d46b2b12f1.png)

>[!faq] Когда какие измерения нужно проводить?
> - Если нужно измерить кусок кода, то нужно использовать `performance.mark()`
>- Если нам нужно измерить время выполнения функции, то уже её нужно декорировать