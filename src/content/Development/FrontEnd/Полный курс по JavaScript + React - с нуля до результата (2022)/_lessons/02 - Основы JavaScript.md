
## 001 Что такое JS и как его подключить к странице

Подключается скрипт к сайту таким образом. Больше никаких тегов внутри прописывать не надо. Если присутствует тег «type», то его нужно будет убрать. Скрипт мы помещаем в самый конец, так как он работает только с существующей вёрсткой на сайте и так же может долго загружаться, что застопорит загрузку сайта

![](_png/53ffe82b8bd765f5a8c6cd074fbac72b.png)


## 003 Переменные и строгий режим

Объявлять переменные через `var` – **нельзя**. В современных структурах она может принести очень много вреда. Дело в том, что такая переменная не учитывает своё положение в коде и видна во всех областях видимости. Приведённый ниже код сработает и вернёт `undefined`:

![](_png/4fb217fc8e6b614cab9d100d61014912.png)

Данная директива позволяет писать код только по современному защищённому стандарту, исключая старый

![](_png/48601b9670f45351d5071becdef68eb7.png)![](_png/e89e4870d6fb5d37003ac96230de1e93.png)

Стиль написания кода JS:

![](_png/40326346e27bd183cf1cdd88c8a3047d.png)

## 004 (д) Правила и типы названия переменных


Наименования названий переменных должны быть понятны для любого человека, который читает наш код

![](_png/a7cea8124022c33ab626003ad36a769a.png)![](_png/fc4d569a91c341b181cdc0dee1e70d59.png)

Стиль наименования переменной «snake_case» или написание в камеле, но с нижнего подчёркивания используется для написания константы (которую точно не стоит менять в коде)

![](_png/d21e47c587b3a2783c48f788c6e4ba3e.png)


## 005 Классификация типов данных в JavaScript


В первом столбце – примитивные типы данных, во втором – комплексные (могут хранить в себе разные типы данных)

![](_png/cd72aba9b568578d19998f161eb146b1.png)

Так же мы можем получить при определённых операциях `Infinity` (когда получаем бесконечность) и `NaN` (когда ожидаем выполнение числовой операции, но вступают в расчёт другие числа)

![](_png/eef0f0319c70b03c626c85d4e7ba38fc.png)![](_png/9226f4bafdc7f77a06af475087b97b6c.png)

Объект представляет из себя набор свойств (ключ + значение). Массив – это частый случай от типа данных объект (в качестве ключа используется индекс). Поэтому работа с массивом и объектом достаточно похожа

![](_png/f8ae0c93ba986502a88a1c8e83ed63b1.png)


## 006 (д) Разница между объектами и массивами и неочевидные синтаксические возможности

Разница между объектом и массивом заключается в разных прототипах (которые определяют функционал)

![](_png/dc9a01b52ba1befb308c3dd88c5b8f88.png)


## 007 Простое общение с пользователем


Самый простой способ общения с пользователем – это `alert()`, `confirm()` и `prompt()`. Последняя функция всегда возвращает строковое значение от пользователя

![](_png/1c3b905e41907959b900c5f1173eb249.png)

Так же можно вернуть и число (динамическая типизация в число)

![](_png/4e7f58d97e1e2c7f1c57031f56c19c4b.png)

Так же можно сделать серию вызовов диалоговых окон и предоставить их пользователю.

`Document.write()`- перезатирает страницу и выводит нашу переменную

![](_png/6eb7021c1fccb94794ad776fb20c748d.png)![](_png/4aaa0a2a77d609fc80cbae345bcb2936.png)


## 008 Интерполяция (ES6)


Интерполяция в JS реализуется с использованием `${действия}`, либо через сложение строк

![](_png/53ddbe5a3341bb47606a23b8284512c6.png)![](_png/f3e4c31005aa254298842fd461952d21.png)

## 009 Операторы в JS


Все операторы присутствуют на MDN

![](_png/b06c6c8041976ac7d9a4a34a3953c1b0.png)![](_png/3e7f4f4504dd0095c6a52f103b9a8863.png)

## 013 Практика, ч.1. Начинаем создавать приложение

Задание:

![](_png/9c2064c248f38a3c697e2f99570a265a.png)

Реализация:

![](_png/522e5a59e4bdc1c5f62184f568bdaad6.png)
![](_png/1ec59b643f5607d1e1ce4a1d40ff80c4.png)


## 014 Условия



![](_png/9532caa7a011e1fcdffc7729a6061f5a.png)

![](_png/689f236a96ee23bf54b635eebee81037.png)

## 015 (д) Логические операторы



![](_png/d1d4810a893445b7639b216bb57f22fb.png)![](_png/0058aba227a91b3ec4ee0487266cf5b7.png)

## 016 Циклы

![](_png/d00afc13262d7b41ccdf696f9e99577d.png)

## 017 (д) Цикл в цикле и метки


Реализация вложенного цикла:

![](_png/bfb13858216273a5a70aa058f55c0c44.png)

**Метки.** Можно отправить цикл выполнять другой цикл, который является его частью (тут если `k === 2`, то будет выполняться самый первый цикл). 

`continue` и `break` работают похожим образом как и в других языках

![](_png/47482f3705dbcce34b49a64b8fcc2bcb.png)![](_png/68655b7ea32e00e95eac569485a234be.png)

## 018 Практика, ч2. Применяем условия и циклы


Тут стоит отметить, что если пользователь нажал на «отмену» при вводе значения в `prompt`, то к нам вернётся `null`

![](_png/c379725b709f7aeeb7a4b874b0dee742.png)

```JS
'use strict';  
  
let numberOfFilms = +prompt('Сколько фильмов вы посмотрели?')  
  
  
const personalMovieDB = {    
	count: numberOfFilms,    
	movies: {},    
	actors: {},    
	genres: [],    
	private: false,  
}  
  
	while (true){    
	if (numberOfFilms >= 0) {    
	    if(personalMovieDB.count < 10){   
			alert('Просмотрено довольно мало фильмов') 
			break 
		} else if(personalMovieDB.count >= 10 && personalMovieDB.count <= 30){    
			alert('Вы классический зритель')   
			break     
		} else if(personalMovieDB.count > 30){     
	          alert('Вы киноман')
	          break
		}
	} else {
		alert('Вы ввели не число или неверное число')    
	}  
}  
  
let name, mark;
  
cycle: for (let i = 0; i < 5;){  
	name = prompt('Один из последних просмотренных фильмов?');
	mark = prompt('На сколько оцените его по десятибальной шкале?', '5'); 
	if (name != null && name != '' 
		&& name.length < 50 
		&& mark != '' 
		&& mark != null 
		&& mark >= 0 
		&& mark <= 10) {       
		personalMovieDB.movies[name] = mark;
		i++; 
	} else {     
		alert('Одно из введённых вами значений неверно');      
		continue cycle;
	}  
}
```

И стоит отметить, что если мы тут оставим «+», то при отмене ввода значения пользователем, данный оператор переведёт значение `null` в `0`

![](_png/e63aaecd996785376f6d4a46ffedf78d.png)


## 019 Функции, стрелочные ф-ции (ES6)

Виды функций:

![](_png/685f8bfd067e31d1248bfa88a72b2bc5.png)


## 020 (д) Еще раз про аргументы функций


![](_png/28c9b9269dafc96fb8adc1427598eca7.png)

## 021 (д) Про важность return

Оператор `return` в первую очередь нам нужен для того, чтобы вернуть результат из функции (например в переменную, которая вызвала эту функцию)

![](_png/5bb08c3d5576dc0e629bdca08c1850fa.png)

Так же можно вернуть значение из цикла (и цикл сразу же завершится)

![](_png/7c60c48dfc896051596c0b11a07dd3eb.png)

Но так же важно сказать, что функция (когда она не имеет `return`) всегда возвращает undefined. И `console.log()` тоже всегда возвращает `undefined`

![](_png/324ebbc600014ddfc83b269323170ec5.png)


## 022 Методы и свойства строк и чисел

Основные методы строк и чисел:

![](_png/8dc02a793f981a9fa2b2b1c5a7ddb2e3.png)

## 023 Практика , ч3. Используем функции

Тут хочется показать не очевидное условие. Нам нужно, чтобы пользователь в любом случае ввёл число. Чтобы функция работала, как надо, нужно сформулировать такое условие:

```JS
let numberOfFilms;

function numberChecker() {
	numberOfFilms = +propmpt('Сколько фильмов вы посмотрели?');
	while (numberOfFilms == '' || numberOfFilms == null || isNan(numberOfFilms)) {
		numberOfFilms = +propmpt('Сколько фильмов вы посмотрели?');
	}
}

numberChecker();
```


## 024 (д) Метод trim()

Метод `trim()` стоит использовать почти везде, где есть ввод данных пользователем. Это позволяет избегать пустых строк и огромного количества пробелов, так как данный метод убирает лишние пробелы из строки

![](_png/32c218cd49aa9455c0adaaf5893e29a4.png)


## 025 Callback- функции

**Callback-функция** - это функция, которую мы передаём в другую функцию и выполняем там же

Сюда мы передаём анонимную функцию (исчезнет после использования):

![](_png/b4241245a8a4819110e0e53f411b92ee.png)

А сюда мы передаём стрелочную:

![](_png/a96c15b36f3d8d4f7d20a2e9f6527b03.png)


## 026 Объекты, деструктуризация объектов (ES6)

Тут мы получаем ключ и его значение из объекта, а так же проходимся по объектам внутри объекта

![](_png/a09ee1c38024cdf851e1970763a885ea.png)

Это пример части деструктуризации объекта, где мы получаем из вложенного объекта `movies` его внутренние свойства

![](_png/e86bbee6b5176ba9042c15a5bea2567e.png)

## 027 Массивы и псевдомассивы

![](_png/583db7b2b6af68fdb45071f91c521b99.png)

## 030 Основы ООП, прототипно-ориентированное наследование

Тут описывается цепочка наследования и особенности ==ООП== в ==JS==, где все элементы языка являются объектами

![](_png/a461870fe3bf0df2b156c3a85364f4e4.png)

```JS
const car = {
  model: 'Bentley',
  ride: () => {
    console.log('врум-врум');
  }
} 

const Bentley = {
	model: 'H720P',
}

// Bentley.__proto__ = car; // устаревший способ указать прототип
// Object.setPrototypeOf(Bentley, car); // более современный способ создания прототипа

const Proshe = Object.create(car); // тут сразу реализован прототипно-наследуемый объект

Proshe.ride(); 
```

![](_png/40327bbf4a7ae59a255d81c272cec22c.png)


## 031 Практика , ч4. Используем объекты

Очень важный мем! Чтобы проверить, что наш пользователь ввёл число, нужно проверять не само равенство введённого значения к типу (`count === Number`), а тип введённого числа к типам, которые выдаёт typeof (пример на рисунке)

![](_png/32068dd7ff08e583ec83cd91a2c3db8f.png)

Выводим любимый жанр и его номер

![](_png/afd34f7d0babc14e79b51381000e7615.png)

Так же есть ещё один интересный способ, как можно принять значения от пользователя в виде массива. Метод `split(‘, ’)` позволяет указать разделитель для строчки и по этому разделителю разложить значения в массив.

Тут впринципе показана реализация, когда мы приводим сначала строку к нижнему регистру (потому что сортировка, которая идёт дальше, будет производиться по юникоду, а в юнкоде сначала идут заглавные буквы)

![](_png/7899c41f5bd5f559d80997d029d4b9af.png)

## 032 Отлавливаем ошибки в своем коде при помощи консоли разработчика. Breakpoints

На данной вкладке нашего инструмента разработчика находится инструмент просмотра сурсов и дебаггинга

![](_png/a8cb900525d2797634d26b3708360738.png)

На номерах строк мы ставим маркеры. Справа находятся кнопки стартаа программы, перехода в другую функцию (вызванную), входа внутрь функции, выхода из функции (она выполнится) и выполнения одного шага. Так же есть снятие маркера и паузы на ошибках

![](_png/d28698377bd65bcf8fc32bbdba014db3.png)


## 033 Динамическая типизация в JS


![](_png/d17172059aa1422e93ce9b1011168d11.png)

Способы перевода в другие типы данных:

![](_png/0b8f5fb7890727b99889348319db8e0c.png)

## 034 Замыкание и лексическое окружение


В данном примере кода мы доходим до такого понятия как **лексическое окружение** или **область видимости**. Любая переменная – это свойство объекта лексического окружения. И мы имеем внутреннее лексическое окружение (например, область той же функции) и внешнее (всё, что находится на глобальном уровне).

Тут стоит пояснить, что бОльший приоритет имеют свойства внутренней области, но так же внутреннее окружение может брать значения из внешнего. Так же те же функции берут самое последнее значение переменной, которая может изменяться далеко дальше по коду

![](_png/e0be3c52c2a7463ad58131c421caa4b2.png)

![](_png/100c782b8326a647f83db7d9d3ab2d0f.png)

Тут функция так же будет брать только актуальное значение переменной (6, а затем уже 8). Так же тут же отметим, что при каждом вызове функции, у нас создаётся разное лексическое окружение, что говорит нам о том, что в функции в разных местах кода спокойно могут находиться разные значения переменных. Но так же эти пространства удаляются, когда они выполняются и полностью исчезают из выполненного программного кода

![](_png/7a22e9d65ddea1e11710606265d81794.png)

Тут так же можно увидеть, что при вызове функции у нас создаётся определённая область видимости, где сохраняются ссылки на переменные, которые были им доступны на время создания этих функций (создание == вызов)

![](_png/fcacc80d621897d747d2b013c4f7b7e7.png)

## 035 Задачи с собеседований на понимание основ


![](_png/412044a41b27695f33f26b13df2d6505.png)
![](_png/6f8836229b5405530bd615b55deaf273.png)

## 036 Получение элементов со страницы


На нашей странице располагается бокс. Через метод `getElementById` мы можем получить (*один*) элемент по его `id`, указанному в HTML-вёрстке, и выводим его в консоль разработчика. 

Обращаемся мы к `document`, так как это наша страница, с которой мы работаем.

![](_png/d5df781855d3aa7718b317a48f547e7f.png)

![](_png/37228b2dd17befca9c9ccc1db702952f.png)

Метод `getElementsByTagName` позволяет получить псевдомассив элементов по их тегу (`div`, `button`, `li` and etc...)

Здесь мы получаем уже не один элемент, а *псевдомассив* - это массив, который не имеет методов высшего порядка массивов

![](_png/a3e7b1f975b3a593b2db67d57df8664f.png)

![](_png/c5cc8ac3be784c211cc8ce5546521932.png)

Но мы так же можем обратиться к определённому элементу этого псевдомассива и получить нужное нам значение через массивное указание индекса элемента (`[число]`)

>[!note] Тут стоит отметить, что даже если у нас на странице будет всего один элемент, то на выходе мы так же получим `HTMLCollection` (псевдомассив), но из одного элемента

![](_png/b6c38aad2d766e772a2476b248460c4e.png)

![](_png/06393d047a4af4f4d73e1806f48fb23c.png)

![](_png/ec3a252ec8407d4feb24c9f6a315c72d.png)

Тут уже псевдомассив элементов вызываем по имени класса с помощью метода `getElementsByClassName()`

![](_png/341a8230d2ab999bf8a03b2679d6cb9c.png)

![](_png/4e96fe4700b1cfb102d6930408c89ed0.png)

Все вышеописанные методы являются устаревшими. Сейчас для получения элементов со страницы используются два современных метода: `querySelector` и `querySelectorAll`. Они позволяют обращаться к элементам как при использовании CSS-селекторов. То есть тут уже для указания элемента нам нужно будет прописывать `.`, `#`, `:`, `*` и так далее. Такой способ рекомендуется к использованию и является более правильным. Так же он имеет один из методов массива - `forEach()`

![](_png/f3b68328407c1698a76073d2be86c97f.png)

![](_png/d2165ac6358ab6921b5f3c41d083a270.png)


## 037 Действия с элементами на странице


Так же мы можем добавить инлайновые стили определённому элементу страницы через `имя_элемента.style.стиль = 'значение[px]'`.

Тут так же нужно отметить, что мы в основном имеем дело в псевдомассивами, поэтому нужно не забывать обращаться к элементам по индексу.

Так же нужно отметить, что на элемент можно повесить стили через обращение к элементу `cssText`, который представляет из себя просто набор текста стилей элемента `элемент.style.cssText = 'стили'`

![](_png/83546579b0524160265e37ea90b0e741.png)

![](_png/07347627266f40890ac4064d5938e596.png)

И вот тут представлено создание нового элемента нашей страницы с классом black (в CSS заранее прописаны свойства цвета, ширины и высоты данного блока по названию класса):
- `createElement()` - позволит создать элемент на странице по тегу
- `classList` - свойство объекта, которое позволяет производить манипуляции над классом элемента на странице
	- `add()`- метод добавления класса элементу
	- `remove()` - метод, который позволит удалить определённый стиль с элемента
- `append()` - добавляет определённый элемент в конец
- `querySelector().append()` - такая конструкция позволит добавить элемент в конец определённого блока кода

![](_png/044c060047dc7e5f85c76d38833a3132.png)

Это второй вариант записи обращения к элементу (тут мы запихиваем див во враппер)

![](_png/5634aad162d96f7a22a67971b46ab588.png)

![](_png/63b773b3d0b7d80f07c6235df9df8296.png)

Так же у нас есть возможность добавить элемент в начало объекта, но через другой метод: `prepend()`

![](_png/241fad0a78f74d0b49a980a4b6fc7c00.png)

![](_png/bb380dd74f0681f6eb6db343de695fd7.png)

Так же мы можем поместить элемент на страницу через метод `before()` до того элемента, на котором мы вызвали данный метод

![](_png/c40aa49b8fddf7c80858a71d11f59395.png)

![](_png/82f5300131e144a5595ab4d43c89aac9.png)

Так же мы можем поместить элемент после того, на котором вызвали функцию `after()`

![](_png/3da37493f106fa29c3f972185ce2d4fc.png)

![](_png/cf88fad269b16369c7e456ac4208945c.png)

Но есть куда более старый метод, который тоже подойдёт для вставки элемента - `insertBefore()`. Ему нужно передать в качестве аргументов два объекта: вставляемый объект и тот, перед которым вставляем

![](_png/5190bbe94b6126791b3dc312d5786c79.png)

![](_png/eebf88c88572da7c270bc046fead83ed.png)

Тут уже представлено удаление одного из трёх кружков. Осуществляется удаление элемент через вызов на нём метода `remove()`

![](_png/35daa8a24d9304ec58407adb30b19849.png)

![](_png/1c47a0ab0be26402d12fa62ba8348c6c.png)

Раньше был актуален метод `removeChild()`, который позволял удалить дочерний элемент из родительского

![](_png/2d675a5abf6f278410ddd1fa6f9fb624.png)

Так же мы имеем возможность крайне просто и быстро поменять объекты местами между друг другом с помощью метода `заменяемый.replaceWith(заменяем_на)`

![](_png/def059b04daf1b2dbfcc37e706175d75.png)

![](_png/ab87d1e94cc125ef17caea1a35970801.png)

И вот ещё один абсолютно аналогичный по логике выполнения код, но более старый по записи `replaceChild()`

![](_png/95bea7910d3a714b9ac1622d4b8e90db.png)

И вот тут уже нужно познакомиться с двумя свойствами `innerHTML` и `innerText`.

Первый добавляет на страницу код HTML, а второй добавляет только текст (который мог ввести, например, пользователь)

![](_png/4c2e1ffdf7064ad641af6afeafcc3c5f.png)

![](_png/256b00a306c97a0d0e01444c28328c2b.png)

Метод `insertAdjacentHTML(позиция, значение)` позволяет вставить HTML-код несколькими заранее определёнными способами. В качестве первого аргумента мы передаём способ вставки, в качестве второго – сам код.

- `afterbegin` - вставит код в самом элементе, на котором вызываем данную функцию
- `afterend` - вставит после блока
- `beforebegin` - вставит до блока
- `beforeend` - вставит как и первый в самом элементе, на котором вызываем данную функцию

![](_png/4b216366756be4cf760fd3de659d514f.png)

![](_png/bd2f036da247ea969d258528f7b274d0.png)

Так же при инициализации HTML элемента в JS можно указывать откуда мы будем конкретно брать вложенные элементы. То есть, мы можем искать элементы не по всему документу, а внутри враппера, который мы импортнули в JS

![](_png/70a7f7705bfb3a4afd3e4f0b57c3f9dc.png)


## 038 Практика. Задание на отработку действий со страницей


Дано 5 задач и начальный объект, внутри которого располагается массив

![](_png/9cf95733cbf8aca23136f0d7a14ac76b.png)

Приведены мои решения и решения преподавателя

Тут хочется обратить внимание на textContent. Он позволяет обратиться к контенту внутри блока

![](_png/6c9a6e796431b4d75890535506e369cb.png)![](_png/81d0512313116266484fce2a3ab3e7e0.png)


## 039 События и их обработчики



Существует огромное количество событий в JS. Все они применяются при взаимодействии пользователя и нашей формы

![](_png/5044984c3c3b2184f93f97fb19e0a5ab.png)

Самое первое и простое взаимодействие – это нажатие кнопки пользователем, которое мы можем прописать прямо в теге (но так делать не рекомендуется)

![](_png/b06c22525f7c3f4683b8d0ef58223ad8.png)![](_png/316c07df09026fffa58a75f07a5478eb.png)

Так будет правильнее писать событие, но всё равно этот метод достаточно устаревший. Этот код плох тем, что мы можем забыть и переназначить кнопке другое действие далее в коде. А это уже точно приведёт к сбою логики программы

![](_png/1927c44b0cdaa58548f7a498a62f989f.png)

Это уже современная форма записи через `addEventListener()`. Первым делом записывается название самого события (нажатие -> `'click'`), уже потом вставляем колбэк-функцию, которая сработает при этом событии

![](_png/cf3beef52886d4ed231f1d95b0355bf6.png)

`'mouseenter'` – вызывает срабатывание ивента при наведении мыши на элемент

![](_png/1555c25a86aef3a3823f1e35f2e8befa.png)![](_png/d78f1fb24005e194cf8bc927101da046.png)

Выводим сам ивент (так же можно ввести `event.target` – выведет элемент (на котором произошло событие), `event.type` – тип ивента)

![](_png/95006f69b945527b4cb9c5e784e735fd.png)![](_png/61cc9b3cdf3eecb3222e1c2fe31ef543.png)

Удаляет блок кода (сам элемент), на который навелись мышкой

![](_png/4a20d4db3fde3fad601ac4582d542fbd.png)![](_png/ea18290f13851bb3a0d43f29540def50.png)

Так же мы имеем `removeEventListener(событие, функция)`, которая позволяет удалить само событие с элемента 

Тут логика нашей программы описывается так: у нас есть чекер кликов, после нажатия на первую кнопку – она пропадает и вместе с ней удаляется чекер кликов со второй кнопки

![](_png/6f025ed25b89d5c5d172a1ac93610a7a.png)

Тут показаны **вложенные события**. Когда на родительсском и дочернем элементе находится один и тот же обработчик. Сначала всегда срабатывает вложенное событие

![](_png/a70410f4ec53d4f56c63de5846a48ba5.png)![](_png/9523b537d3a1ed9c11da89799fbeecf3.png)
![](_png/3639be2057604c00688a280111fa752e.png)

Свойство `currentTarget` указывает на событие каждого конкретного элемента по отдельности (сработали отдельно дочерний, потом родительский элементы)

![](_png/63ecc8fbc4bce26bc075e1571afda26e.png)
![](_png/41bcaf7359338b88245d62fc00bf997c.png)

`event.preventDefault()` – позволяет отменить выполнение стандартной логики для определённого элемента (например, отменяет перезагрузку страницы при нажатии на кнопку-сабмит (отправка) формы)

![](_png/d6377b2091085a362072233d696d110b.png)
![](_png/2d7067e10e689b3987577257122ae545.png)

Так же мы можем через `forEach()` повесить событие сразу на все элементы псевдомассива

![](_png/5973ad233d15537b4cd66e38fd119cac.png)

Так же в mdn можно увидеть, что метод, добавляющий ивенты, может принимать в себя до трёх значений, последний из которых - модификатор

![](_png/06ff1d28f63c064bb420766cb86bb278.png)
![](_png/17194388f2659754be82df909b8e9ea4.png)

Пример использования опции:

![](_png/bfba84eb2e3dafbb515cf7a1f9b6e581.png)
![](_png/6e4432bd8bb9b559055ade820061a2ae.png)


## 040 Навигация по DOM - элементам, data-атрибуты, преимущество forof

Мы можем легко вывести и увидеть элементы через JS. Тут хочется выделить такую особенность, что `documentElement` – это `<html></html>` тег, внутри которого всё находится.

Так же, когда мы используем `childNodes` (вывод всех дочерних элементов), мы можем увидеть очень много разных объектов. В качестве `text` выступает перенос строки, который мы можем увидеть в коде, но который не отображается

И тут уже стоит пояснить, что в ДОМ-дереве не всё является элементами или узлами. **Элемент** – это видимая часть HTML, а **узел**, в свою очередь, – это та связующая часть между элементами и текст. Например, кнопка – это элемент, а текст в кнопке – это узел (нода)

![](_png/0c2c0eb1d5398715daa0d6f35ba616d0.png)
![](_png/8ade73d7754efa570b111db99e0a5005.png)

`parentNode` выводит родительский узел и повторять его можно много раз

![](_png/d82f72c660ed6f54905409359d9f3a7e.png)
![](_png/d097d22570e7cade89a33482aa6d6d6e.png)

Так же мы можем обращаться к определённым атрибутам в HTML-коде (тут так же работает логика CSS, так как обращение к атрибуту там идёт через `[такой синтаксис]`)

![](_png/ae0a3ed04f349eacc0ff1cba76f744dd.png)![](_png/5273232f90f3d3e626d197108dce1481.png)

Используя предыдущий синтаксис, мы можем обратиться к предыдущему и следующему объекту (тут как предыдущий, так и следующий объект – это текстовая нода переноса строки)

Но такими методами неудобно пользоваться, так как мы можем попасться на ноду переноса строки, что нам может быть и не нужно

![](_png/dd9ed0b093714925998bd541a7674f38.png)![](_png/21e4ff7a19afebfc8f929e77cfc321bd.png)

Выводит предыдущий/следующий **элемент** после того, к которому обратились

![](_png/fe27637567a3a7b9b4a23babb418abab.png)![](_png/4e30b85b46050199553107cf4bbdfae8.png)

`firstElementChild` - выводит первого ребёнка в выбранном элементе
`parentElement` - выводит родителя выбранного элемента

![](_png/8ad47aba44dba9cdbe4717d71a464cae.png)![](_png/51f9f82585fd5fe9380c9d69ae827a32.png)

И вот как данный функционал пишется: мы перебираем все элементы объекта `body`, и если имя элемента `text`, то данная итерация цикла пропускается (`continue` – пропускает итерацию цикла, `break` – завершает цикл досрочно)

![](_png/249a81fa624bbb6a58214d4c2b9fda77.png)![](_png/9c68c89e198a5195a82a8cafb67173c7.png)

## 041 Рекурсия


Рекурсия - это функция, которая выполняет саму себя конечное количество раз.

Рекурсия позволяет множество раз перевыполнять код до выполнения поставленной задачи.

Так же имеются основные понятия как: база рекурсии, шаг рекурсии и глубина рекурсии

Нужно сразу упомянуть, что рекурсии менее производительны, нежели чем стандартные функции языка по перебору информации. Однако рекурсии более удобны в большинстве остальных методов

![](_png/a5645cc2d47e38cdc58c1a47a2098d73.png)

Первый метод `Object.values()` переводит объект в массив, второй метод `Array.isArray()` проверяет является ли объект массивом

![](_png/2864e4881666e7892331b6473d2bf668.png)![](_png/b06f49a6a95329939e46dceb253bb465.png)

Тут представлен объект, который хранит в себе данные о студентах и завершённости прохождения курса

![](_png/ead15c2e492bbabe102a41d02ff49160.png)

И нам нужно создать переборщик объекта, который выведет общий процент прхождения курсов. Основная проблема этого переборщика заключается в том, что при переборе объекта он не зайдёт в ещё более вложенные объекты кроме тех, что мы описали – это и есть ограничение нерекурсивных методов

![](_png/b030a3eef0166954f1d0891cd9c2e70b.png)

И вот представление кода с рекурсией. Он уже может обработать объекты любой сложности и вложенности, так как при каждой встрече объекта, он переходит во второй условный блок кода, где располагается `else` и там запускает массив заново, чтобы дойти до массива, где сработает блок кода `true`

![](_png/b6adf930d0feeb700edbd59e597220b0.png)

С представленным выше объектом оба массива справляются одинаково

![](_png/26029615af70f7fb504c0a6bfb3987b3.png)

Но если немного изменить структуру

![](_png/64dfa75d942e2d3bd333084e4b3395fb.png)
![](_png/bce49ea92b8f02fd66974501bbc8d3b9.png)


## 042 Практика. Используем события на странице проекта


Задание:

![](_png/d6ab091b96876bcb32df15adfbe4e299.png)

`DOMContentLoaded` – браузер полностью загрузил HTML, было построено DOM-дерево, но внешние ресурсы, такие как картинки `<img>` и стили, могут быть ещё не загружены

![](_png/d18603dc9bac4f820e5bb249799175c3.png)
[Статья по событию DOMContentLoaded](https://learn.javascript.ru/onload-ondomcontentloaded)

обращение ко всем изображениям внутри класса

```JS
const ads = document.querySelectorAll('.promo__adv img');
```

Тут находятся все переменные в проекте (и необычные селекторы вызова)

![](_png/0f661bbd683cf47c159cda4263f97eba.png)

Это одна из самых сложных частей данного сайта – формирование списка фильмов. Первым делом, в текст вкладываемого родителя мы вставляем пустую строку, которая нам позволит очистить имеющиеся айтемы списка `<li>`. Дальше мы сортируем массив. Потом мы заменяем элемент списка, и именно вставляем новый айтем включая добавление HTML-структуры. Добавляем структуру через «+=», так как мы добавляем айтем списка - `<li>`.

Потом мы добавляем функционал удаления фильма из писка элементов. Сначала вызываем иконки с классом `delete`, в которые через `forEach` вставляем ивент, который будет срабатывать при нажатии `click`. Внутри ивента будем обращаться к родителю иконки и удалять его. Удалять уже фильм из массива будем через метод splice, в который поместим номер элемента (второй аргумент `forEach`) и количество элементов. Потом уже вызовем рекурсией наш фонрмировщик списка (для формирования обновлённой структуры)

![](_png/0a102afb6e30cc74342d30f1508c36bc.png)

Это дополнительные методы. Первый удаляет рекламу со страницы. Второй вносит изменения в жанре и фоне. Третий сортирует массив. Четвёртый проводит проверку наличия фильма в массиве (вызываем тоже при нажатии кнопки)

![](_png/486f4d4147d39e1c4db4e40f964c1179.png)

Это полное описание события `‘submit’`, которое хранит в себе порядок действий при нажатии на кнопку в форме

![](_png/ca6d09f957144519a0b7b28e12bd31ea.png)

А тут мы вызываем методы для изменения нашего списка (внутри него и сортировка тоже), внесения изменений (смена жанра и заднего фона) и удаления рекламы

![](_png/03bc7f1fb34acbdb6520fde063de2e83.png)

## 043 События на мобильных устройствах


На телефоне в основе своей нет кликов мышкой – есть тачи. Однако события с кликами нормально отрабатывают и в мобильных версиях браузеров

Мобильных событий всего 6:
- `touchstart` – возникает при соприкосновении
- `touchmove` – возникает при перемещении пальцем
- `touchend` – палец отпускается от элемента с данным ивентлистенером
- `touchenter` – срабатывает как только палец при скольжении попадает на элемент с данным ивентом
- `touchleave` – срабатывает когда палец выходит за пределы элемента
- `touchcancel` – срабатывает тогда, когда точка соприкосновения не регистрируется на поверхности (если палец выйдет за пределы браузера)

И вот примеры отображения ивентов в браузере. Первый ивент срабатывает при первом клике на объект, второй ивент срабатывает когда мы тыкаем по объекту и водим по нему, третий срабатывает, когда мы отпускаем палец с объекта

![](_png/dde601a2753cfc5e5049445f4b00ba91.png)![](_png/8457c511c7cb987eeb2214066582de1b.png)

Так же стоит упомянуть, что у ивентов есть свои методы. И вот три из них, которые позволяют отслеживать тачи относительно объекта:

![](_png/2fc0944b7b702d7c55f5e5d2c8168f04.png)

Сама информация о тачах представляет из себя: положение в пространстве, поворот, радиус, количество пальцев и так далее

![](_png/94f657f3d9c943aee89b4ef8097a01c5.png)

Вот пример вывода всех методов о клике и вывода положения по X пальца, который перемещается по боксу

![](_png/f94dcd53321561aadae0516c7d3e92b7.png)![](_png/f29c1e0dded25bbbce55e4c34490750f.png)

_Ресурс, который позволит немного упростить работу с тачами_ - [https://hammerjs.github.io/](https://hammerjs.github.io/)


## 044 Async, defer, динамические скрипты


Тут нужно упомянуть, что при расположении скрипта в `<head>` страницы у нас вылазит две проблемы:

1) Так как скрипт загрузился, а страница нет, то скрипту не с чем будет работать и он выдаст ошибку
2) Сам по себе скрипт стопорит загрузку HTML-страницы и при большом его весе у нас страница может долго загружаться

![](_png/ccbe57a890d57702edf81dc48be4de8d.png)

Но так же перед нами может встать другая проблема: очень большой проект. Сайт может содержать в себе тысячи элементов, которые могут очень долго загружаться. Это приведёт к тому, что скрипт может не сработать в тех местах, где нам это нужно было

![](_png/59dc286a5e8fe765614e7239531a1c6f.png)

Атрибут `defer` сообщает браузеру, чтобы он продолжал загружать страницу, но так же браузер должен загружать и скрипт в фоновом режиме, а затем запустить скрипт, когда он загрузится.

1) Скрипты с `defer` никогда не блокируют страницу
2) Скрипт запустится только тогда, когда DOM-дерево уже готово

![](_png/5b5a19f9306834449c1fe899f0f2ad6e.png)

Так же ещё одной особенностью является то, что скрипты выполняются последовательно друг за другом, даже если какой-то загрузился раньше.

Это позволяет нам закинуть те же скрипты в хедер сайта, но гугл сео-тест будет ругаться на такое расположение скриптов

![](_png/b9a69c7d44c8f3e9a3b95401dcca381e.png)

![](_png/4f18e02ccb113383ce3c8c6fb200a9d1.png)

Ещё один атрибут, который модифицирует работу скриптов – это `async`.

1) Страница не ждёт асинхронных скриптов – содержимое загружается и обрабатывается
2) Событие `DOMContentLoaded` и асинхронные скрипты не ждут друг друга

Тут уже нужно убедиться, что скрипты не зависят от DOM-структуры, так как выполняются они сразу же

![](_png/d53f995b5ac8b9b07b44dabd40bff38c.png)

И вот пример подключения скриптов по нужному порядку к сайту

![](_png/b79352255f4c6f49b771999f4a0d70f1.png)

![](_png/9047adcb533735a48bd978094f46233c.png)

![](_png/a560c6a9ad76d756e42ab8ecf8aab864.png)


## 045 Ресурсы для оттачивания навыков программирования

СсылОчки:

[Freecodecamp](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/)
[Hackerrank](https://www.hackerrank.com/)
[Leetcode](https://leetcode.com/)
[Codewars](https://www.codewars.com/)
