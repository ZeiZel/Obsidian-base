### 5.2 Препроцессор SASS ч.1
#SASS 

Чтобы у нас была возможность компилировать sass-файлы, нам нужно установить сасс-компилятор. После его установки снизу нажимаем на кнопку Watching

![](_png/4a72a2feeb0e13df575edda6fc95bd39.png)![](_png/87b9a8ee94159dc77e014173ff1062d9.png)

**Нужно взять за правило проверять настройки плагинов, если что-то не устраивает!** В настройках программы находим плагин нашего компилятора и указываем путь до изменяемых файлов

![](_png/e67ca2cf98754749e18541a97498e74e.png)![](_png/64baf5856109aac0ba2893d42cda4494.png)

И дальше тут у нас должен появиться технический документ

![](_png/d9e250650b724eef685b27d802dd1161.png)

И чтобы у нас появился нормальный сас-синтаксис в вскоде, нужно установить Sass

![](_png/f5329f7383fba18ab0b1f538a081b2ec.png)

### 5.3 Препроцессор SASS ч.2

У технологии САСС есть ряд преймуществ. Первое из них – ненадобность использовать скобки. Вместо них за отображение вложенности (инструкции или элемента в другом элементе) используется таб (именно таб, а не 4 пробела).

Так же слово `block` можно заменить одним знаком `&`, что тоже ускоряет написание кода и позволяет более эффективно использовать методологию БЭМ. Слово block берётся из верхнего названия родителя, т.е. если класс родителя будет называться box, то амперсанда будет обозначать box 

![](_png/6439fd47aed52a1f7c7149460c2fc940.png)![](_png/8c3a756b25444750a21887d0a2ad02a7.png)

т.е. амперсанд = класс, к которому он применён

![](_png/ecde862e710c2b80c8b09c4303d680ae.png)

Так же есть очень крутая особенность в сасе: переменные и миксины.

Переменные позволяют в себе хранить заданные значения и использовать их во всём проекте (например, вставлять основные цвета и при изменении офис-дизайна у заказчика можно быстро поменять цвет из одного места)

Миксины – это переменные, которые хранят в себе целые инструкции. Это очень удобно для стилизации различающихся на малость блоков

![](_png/0c4fd76ec92e32698a6722f19f4e703b.png)

Дальше идёт наша оптимизация кода. Теперь можно выкинуть нормалайз и ресет `css`, ведь теперь мы можем сохранить «`.scss`» их версию (не сасовскую, так как в этих файлах есть кавычки) и подключать эти файлы к нашему `style.css` через импорт, что будет куда удобнее (однако при каждом сохранении `css` версия файлов всё равно будет генерироваться)

![](_png/f9d2406bd89d15df6a7862b24e67bf2e.png)![](_png/fcfa8df1f9440fa086dde787d1a348e8.png)

И вот таким вот образом создаются комментарии

![](_png/8c22316c4d8625b36c616ede5efd4d7e.png)

### 5.2-3 Препроцессор SASS - Full

#### Пререквизиты

Существует 5 CSS-препроцессоров: Sass, SCSS, Less, Stylus и PostCSS.

Эта статья по большей части охватывает SCSS, который похож на Sass. Детальнее об этих препроцессорах можете прочитать на [Stack Overflow](https://stackoverflow.com/questions/5654447/whats-the-difference-between-scss-and-sass) (оригинал) или на qaru (перевод на русский).

SASS  —  (.sass) **S**yntactically **A**wesome **S**tyle **S**heets.

SCSS  —  (.scss) **Sass**y **C**ascading **S**tyle **S**heets.

Расширения `.sass` и `.scss` похожи, но всё-таки не одинаковы. Для фанатов командной строки приводим способ конвертации:

```bash
# Конвертация из Sass в SCSS
$ sass-convert style.sass style.css

# Конвертация из SCSS в Sass
$ sass-convert style.scss style.sass
```

Sass — первая спецификация для SCSS с расширением файла `.sass`. Её разработка началась ещё в 2006 году, но позже был разработан альтернативный синтаксис с расширением `.scss`.

Обратите внимание Другие препроцессоры функциональностью похожи на SCSS, но синтаксис может отличаться. А ещё, всё то, что работает в CSS, будет также прекрасно воспроизводиться и в Sass, и в SCSS.

#### Переменные

Sass/SCSS позволяет работать с переменными. В CSS они обозначаются двойным тире (`--`), а в препроцессорах знаком доллара (`$`).

```css
$number: 1;
$color: #ff0000;
$text: "tproger forever.";
$text: "IT forever." !default;
$nothing: null;
```

Вы можете присваивать значение по умолчанию переменным, у которых ещё нет значения, добавив метку `!default` в конце значения. В таком случае, если переменной уже было присвоено значение, оно не изменится; если же переменная пуста, ей будет присвоено новое указанное значение.

```css
#container {
  content: $text;
}
```

Переменные в Sass могут быть присвоены любому свойству.

#### Вложенные правила

Стандартные вложенные CSS-элементы с использованием пробела:

```css
/* Вложенные правила */
#A {
  color: red;
}
#A #B {
  color: green;
}
#A #B #C p {
  color: blue;
}
```

Те же вложенные элементы с помощью SCSS:

```scss
/* Вложенные правила */
#A {
  color: red;
  #B {
    color: green;
    #C p {
      color: blue;
    }
  }
}
```

Как видно, синтаксис выглядит более чистым и менее повторяющимся.

Это особенно полезно при управлении перегруженными макетами. Таким образом, выравнивание, в котором вложенные свойства записаны в коде, полностью соответствует действительной структуре макета приложения.

За кулисами препроцессор всё ещё компилирует его в стандартный код CSS (показано выше), чтобы он мог быть отображён в браузере. Мы лишь изменяем способ написания CSS.

#### Амперсанд

В SCSS используется директива `&`.

```scss
#p {
  color: black;
  a {
    font-weight: bold;
    &:hover {
      color: red;
    }
  }
}
```

С помощью символа `&` вы можете явно указать, где должен быть вставлен родительский селектор.

Результат компиляции Sass (из предыдущего примера) в CSS ниже.

```css
#p {color: black;}
#p a {font-weight: bold;}
#p a:hover {color: red;}
```

В итоге амперсанд был компилирован в название родительского элемента `a` (`a:hover`).

#### Миксины (они же примеси)

Миксины объявляются [директивой](https://sass-scss.ru/documentation/miksini/) `@mixin`. После неё должно стоять имя миксина и, опционально, его параметры, а также блок, содержащий тело миксина. Например, можно определить миксин `flexible()`, который далее будет включён, например, в класс `.centered-elements` следующим образом:

```scss
@mixin flexible () {
    display: flex;
    justify-content: center;
    align-items: center;
  }

.centered-elements {
    @include flexible ();
    border: 1px solid gray;
  }
```

Теперь каждый раз после применения класса `.centered-elements` к HTML-элементу, последний будет преобразован во [Flexbox](https://tproger.ru/translations/how-css-flexbox-works/).

Миксины могут также содержать селекторы, в том числе со свойствами. А селекторы могут содержать ссылки на родительский элемент через амперсанд (`&`), вы ведь помните про него?

#### Пример работы с несколькими браузерами

Некоторые вещи в CSS весьма утомительно писать, особенно в CSS3, где плюс ко всему зачастую требуется использовать большое количество вендорных префиксов( `-webkit-` или `-moz-`).

Миксины позволяют создавать группы деклараций CSS, которые вам придётся использовать несколько раз на сайте. Хорошей практикой будет использование миксинов для вендорных префиксов. Пример:

```javascript
@mixin border-radius($radius) {        // Префиксы для:
    -webkit-border-radius: $radius;    // Chrome и Safari
       -moz-border-radius: $radius;    // Firefox
        -ms-border-radius: $radius;    // Internet Explorer
         -o-border-radius: $radius;    // Opera
            border-radius: $radius;    // Стандартный CSS
  }
// Пример использования миксина border-radius после его создания
.box { @include border-radius(10px); }
```

#### Арифметические операции

Как и в реальной жизни, вы не можете работать с числами, у которых несовместимы типы данных (например, сложение `рх` и `em`).

##### Сложение и вычитание

```javascript
p {
    font-size: 10px + 2em;  // ОШИБКА!
    font-size: 10px + 6px;  // 16px
    font-size: 10px + 2;    // 12px
}
```

Всегда обращайте внимание на тип складываемых данных. То есть пиксели к пикселям, слоны к слонам. Таким же образом работает вычитание, но со знаком минус.

Пример вычитания:

```css
div {
    height: 12% - 2%;
    margin: 4rem - 1;
}
```

##### Умножение

Выполняется точно так же, как в CSS, с помощью `calc(a * b)`, но без `calc` и круглых скобок. Кроме того, можно ещё отделять знак умножения пробелами от чисел (`5*6 == 5 * 6`).

Исключение Нельзя умножать пиксели между собой. То есть, `10px * 10px != 100px`. `10px * 10 == 100px`.

```javascript
p {
    width: 10px * 10px;           // ОШИБКА!
    width: 10px * 10;             // 100px
    width: 1px * 5 + 5px;         // 10px
    width: 5 * (5px + 5px);       // 50px
    width: 5px + (10px / 2) * 3;  // 20px
}
```

##### Деление

С делением дела обстоят немного сложнее, но разобраться можно, ведь в стандартном CSS косая линия (слэш) зарезервирована для использования краткой формы записи свойств. Пример ниже.

```css
/* краткая форма записи свойств */
font: italic bold .8em/1.2 Arial, sans-serif;

/* стандартная форма записи свойств */
font-style: italic;
font-weight: bold;
font-size: .8em;
line-height: 1.2;
font-family: Arial, sans-serif;
```

Есть три помощника, которые намекнут на возможность деления:

1. Значение (или любая его часть) хранится в переменной или возвращается функцией.
2. Значения заключены в круглые скобки.
3. Значение используется как часть другого арифметического выражения.

Пример:

```scss
$var1: 20;
$var2: 4;

p {
    top: 16px / 24px;          // Отображается без изменений в стандартном CSS
    top: (20px / 5px);         // Производится деление (но только при использовании скобок)
    top: #{$var1} / #{$var2};  // Выводится как обычный CSS-код, деление не выполняется
    top: $var1 / $var2;        // Деление выполняется
    top: random(4) / 5;        // Деление выполняется (если использовать в паре с функцией)
    top: 2px / 4px + 3px;      // Деление выполняется, если добавлена ещё одно арифметическое действие
}
```

Результат компиляции в CSS:

```css
p {
  top: 16px / 24px;
  top: 4;
  top: 20 / 4;
  top: 5;
  top: 0.6;
  top: 3.5px;
}
```

##### Остаток

Остаток вычисляет остаток от операции деления. Ниже рассмотрим, как создать «зебру» для HTML-списка.

```scss
@mixin zebra() {
    @for $i from 1 through 7 {
        @if ($i % 2 == 1) {
            .stripe-#{$i} {
                background-color: black;
                color: white;
            }
        }
    }
}
* {
  @include zebra();
  text-align: center;
}
```

Создание миксина `zebra` показано во вставке кода сверху. Директивы `@for` и `@if` описаны в секции ниже.

Для создания образца надо написать несколько HTML-элементов.

```html
<div class="stripe-1">zebra</div>
<div class="stripe-2">zebra</div>
<div class="stripe-3">zebra</div>
<div class="stripe-4">zebra</div>
<div class="stripe-5">zebra</div>
<div class="stripe-6">zebra</div>
<div class="stripe-7">zebra</div>
```

Результат в браузере:

[![](https://media.tproger.ru/uploads/2019/01/zebra-sass-1-1540x221.png)](https://media.tproger.ru/uploads/2019/01/zebra-sass-1.png)

Зебра успешно сгенерирована миксином `zebra`

#### Операторы сравнения

[![](https://media.tproger.ru/uploads/2019/01/Comparison-operators-scss-1.jpg)](https://media.tproger.ru/uploads/2019/01/Comparison-operators-scss-1.jpg)

Директива `@if` принимает выражение SassScript и использует вложенные в неё стили в случае, если выражение возвращает любое значение, кроме `false` или `null`.

Ниже показано, как работают директивы `@if` и `@else`, вложенные в миксин.

```scss
@mixin spacing($padding, $margin) {
    @if ($padding > $margin) {
        padding: $padding;
    } @else {
        padding: $margin;
    }
}

.container {
    @include spacing(10px, 20px);
}
```

Сравнение в действии. Миксин `spacing` выберет размеры `padding`’а, если тот будет больше, чем `margin`.

После компиляции в CSS:

```css
.container { padding: 20px; }
```

#### Логические операторы

[![](https://media.tproger.ru/uploads/2019/01/L-operators-sass-1540x251.jpg)](https://media.tproger.ru/uploads/2019/01/L-operators-sass.jpg)

Описание логических операторов

Использование логических операторов Sass для создания кнопки, у которой будет меняться фон в зависимости от её ширины.

```javascript
@mixin button-color ($height, $width) {
    @if (($height < $width) and ($width >= 35px)) {
        background-color: blue;
    } @else {
        background-color: green;
    }
}

.button {
    @include button-color(20px, 30px)
}
```

#### Строки

В CSS определено 2 типа строк: с кавычками и без. Sass распознаёт и то, и другое. В итоге вы получите в CSS тот тип строк, который использовали в Sass.

В некоторых случаях можно добавить строки в допустимые значения CSS без кавычек, но только если добавленная строка является завершающим элементом.

```scss
p {
    font: 50px Ari + "al"; // Компилируется в 50px Arial
}
```

Пример ниже демонстрирует, как делать не надо.

```scss
p {
    font: "50px" + Arial; // ОШИБКА!
}
```

Можете складывать строки разных типов, если в них нет пробелов. Пример ниже не будет скомпилирован.

```javascript
p:after {
    content: "Верните Линуса " + Торвальдса!; // ОШИБКА!
}
```

Строки, содержащие пробелы, должны быть отделены кавычками. Решение проблемы:

```javascript
p:after {
    content: "Верните Линуса " + "Торвальдса!"; // обратите внимание на "Торвальдса!"
}
```

Пример сложения нескольких строк:

```javascript
p:after {
    content: "Удел " + "человечества " + "—" + "итерация.";
}
```

Сложение строк и чисел:

```javascript
p:after {
    content: "Рекурсия " + 2013 + " удел небожителей";
}
```

Обратите внимание Свойство `content` работает только с псевдоселекторами `:before` и `:after`. Рекомендуется не использовать `content` в CSS-документе, а напрямую использовать его между тегами в HTML.

#### Операторы управления потоками

В SCSS есть функции (`function()`) и директивы (`@directive`). Чуть выше мы уже рассматривали пример функции, когда изучали передачу аргументов внутри миксинов.

Функции обычно заключаются в скобки, следующие сразу за её именем. А директива начинается с символа `@`.

Подобно JavaScript, SCSS позволяет работать со стандартным набором операторов управления потоками.

##### if()

`if()` — это функция (и иногда основа искусственного интеллекта).

Её использование выглядит довольно примитивным: оператор вернёт одно из двух обозначенных в условии значений.

```javascript
/* Использование функции if() */
if (true, 1px, 2px) => 1px;
if (false, 1px, 2px) => 2px;
```

##### @if

`@if` — это директива, использующаяся для разветвления на основе условия.

```javascript
/* Использование директивы @if */
p {
    @if 1 + 1 == 2 { border: 1px solid;  }
    @if 7 < 5      { border: 2px dotted; }
    @if null       { border: 3px double;  }
}
```

Результат компиляции:

```javascript
p { border: 1px solid; }
```

Ниже показано комбо-разветвление с добавлением директивы `@else`.

```javascript
/* Создание переменной $type */
$type: river;

/* Окрашивание контейнеров в синий в случае, если значение для переменной $type — river */
div {
    @if $type == river {
        color: blue;
    }
}

/* Условные цвета для текста в теге <p> */
p {
    @if $type == tree {
        color: green;
    } @else if $type == river {
        color: blue;
    } @else if $type == dirt {
        color: brown;
    }
}
```

#### Проверка на наличие родительского элемента

Амперсанд выбирает родительский элемент, если тот существует. В ином случае вернёт `null`. Поэтому может использоваться совместно с директивой `@if`.

В следующих примерах рассмотрим создание условных CSS-стилей в зависимости от наличия родительского элемента.

```javascript
/* Проверка на наличие родительского элемента */
@mixin does-parent-exist {
    @if & {
        /* Применение голубого цвета родительскому элементу, если он существует */
        &:hover {
            color: blue;
        }
    } @else {
        /* Родительский элемент отсутствует, применение голубого цвета к ссылкам */
        a {
            color: blue;
        }
    }
}
```

#### Директива @for

Директива `@for` выводит набор стилей заданное число раз. Для каждого повторения используется переменная-счётчик для изменения вывода.

Директива `@for` итерируется 5 раз.

```javascript
@for $i from 1 through 5 {
    .definition-#{$i} { width: 10px * $i; }
}
```

Результат компиляции в CSS:

```css
.definition-1 { width: 10px; }
.definition-2 { width: 20px; }
.definition-3 { width: 30px; }
.definition-4 { width: 40px; }
.definition-5 { width: 50px; }
```

#### Директива @each

Директива `@each` устанавливает `$var` в каждое из значений списка или словаря и выводит содержащиеся в ней стили, используя соответствующее значение `$var`.

```javascript
@each $animal in platypus, lion, sheep, dove {
    .#{$animal}-icon {
        background-image: url("/images/#{$animal}.png")
    }
}
```

Результат компиляции в CSS:

```css
.platypus-icon {
    background-image: url("/images/platypus.png");
}
.lion-icon {
    background-image: url("/images/lion.png");
}
.sheep-icon {
    background-image: url("/images/sheep.png");
}
.dove-icon {
    background-image: url("/images/dove.png");
}
```

#### Директива @while

Директива `@while` принимает выражение SassScript и циклично выводит вложенные в неё стили, пока выражение вычисляется как `true`. Она может быть использована для создания более сложных циклов, чем таких, для которых подходит `@for`, хотя она бывает необходима довольно редко. Например:

```javascript
$index: 5;
@while $index > 0 {
    .element-#{$index} { width: 10px * $index; }
    $index: $index - 1;
}
```

Результат компиляции:

```css
.element-5 { width: 50px; }
.element-4 { width: 40px; }
.element-3 { width: 30px; }
.element-2 { width: 20px; }
.element-1 { width: 10px; }
```

#### Функции в Sass/SCSS

Используя Sass/SCSS можно использовать функции так же, как и в других языках.

Создадим функцию `three-hundred-px()`, возвращающую 300px.

```javascript
@function three-hundred-px() {
    @return 300px;
}

.name {
    width: three-hundred-px();
    border: 1px solid gray;
    display: block;
    position: absolute;
}
```

После применения класса `.name` ширина элемента будет равна 300 пикселям.

```html
<div class = "name">Hello.</div>
```

Результат в браузере:

[![](https://media.tproger.ru/uploads/2019/01/browser-pic-sass-1540x131.png)](https://media.tproger.ru/uploads/2019/01/browser-pic-sass.png)

Функции в Sass могут возвращать любое корректное значение CSS и могут быть назначены любому свойству. Они даже могут быть рассчитаны на основе переданного аргумента.

```javascript
@function double($width) {
    @return $width * 2;
}
```

#### Тригонометрия

Тригонометрические функции `sin()` и `cos()` часто встречаются в виде встроенных классов во многих языках, таких как JavaScript, например.

Их работу стоит изучать, если нужно сократить время, затрачиваемое на разработку анимаций пользовательского интерфейса, например для создания [троббера](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%BE%D0%B1%D0%B1%D0%B5%D1%80). Мы, кстати, уже [говорили](https://tproger.ru/translations/custom-web-animation-guide/) об этом в одной из статей. Но в данном случае это будет код, а не gif-картинка, вставленная в HTML-документ.

Ниже рассмотрим пару примеров для создания интересных анимационных эффектов с помощью функции `sin()`, в которых количество кода сведено к минимуму. Далее можете масштабировать эти знания на создание интерактивных элементов пользовательского интерфейса (движение по кругу, волнистая анимация).

Преимущество использования тригонометрии в сочетании с CSS выражается в отсутствии дополнительных HTTP-запросов, как это происходит с gif-изображениями.

Можно писать тригонометрические функции на Sass. Об этом читайте далее.

#### Написание собственных функций

В тригонометрии многие операции основаны на функциях. Каждая функция строится на основе другой. Например, функция `rad()` требует использования `PI()`. Функции `cos()` и `sin()` требуют использование `rad()`.

```javascript
@function PI() { @return 3.14159265359; }
```

Написание функций на Sass/SCSS очень похоже на написание функций в других языках.

Использование функции `pow()`:

```javascript
@function pow ($number, $exp) {
    $value: 1;
    @if $exp > 0 {
        @for $i from 1 through $exp {
            $value: $value * $number;
        }
    }
    @else if $exp < 0 {
        @for $i from 1 through -$exp {
            $value: $value / $number;
        }
    }
    @return $value;
}
```

Использование функции `rad()`:

```javascript
@function rad ($angle) {
    $unit: unit ($angle);
    $unitless: $angle / ($angle *0 + 1);
    //Если значение angle (угла) указано в градусах ('deg'), нужно конвертировать его в радианы.
    @if $unit == deg {
        $unitless: $unitless / 180 * PI();
    }
    @return $unitless;
}
```

Для вычисления тангенса функцией `tan()` нужно применить функции `sin()` и `cos()`.

Пример:

```javascript
@function tan($angle) {
    @return sin($angle) / cos($angle);
}
```


[https://tproger.ru/translations/complete-sass-guide/#sass-preprocessor](https://tproger.ru/translations/complete-sass-guide/#sass-preprocessor)

### 5.4 FlexBox. Новый способ позиционирования элементов
#FlexBox 

И сейчас наконец-то будет описана технология, которая позволяет нормально выравнивать объекты на странице. Дело в том, что прошлые попытки выровнять через марджин или текст-алайн имели достаточно костыльную реализацию расположения контента на странице. Однако придумали и добавили в CSS такую технологию как FlexBox.

Чтобы применить её, нужно воспользоваться `display: flex;`

Помочь с изучением данной технологии может сайт ==Flexbox Froggy==

Используя свойство `justify-content`, мы выравниваем элементы горизонтально, а также оно принимает следующие значения:

- `flex-start` -  Элементы выравниваются по левой стороне контейнера.
- `flex-end` - Элементы выравниваются по правой стороне контейнера.
- `center` - Элементы выравниваются по центру контейнера.
- `space-between` - Элементы отображаются с одинаковыми отступами между ними.
- `space-around` - Элементы отображаются с одинаковыми отступами вокруг них.

![](_png/7f113ef14ab68fe6a59672eb36b5059b.png)

Теперь используем `align-items` - это CSS свойство выравнивает элементы вертикально и принимает следующие значения:

- `flex-start` - Элементы выравниваются по верхнему краю контейнера.
- `flex-end` - Элементы выравниваются по нижнему краю контейнера.
- `center` - Элементы выравниваются вертикально по центру контейнера.
- `baseline` - Элементы отображаются на базовой линии контейнера.
- `stretch` - Элементы растягиваются, чтоб заполнить контейнер.

![](_png/c1422fab0972309c1cacccd441690aa8.png)

`flex-direction` - это CSS свойство задает направление, в котором будут расположены элементы в контейнере, и принимает следующие значения:

- `row`: элементы размещаются по направлению текста.
- `row-reverse`: элементы отображаются в обратном порядке к направлению текста.
- `column`: элементы располагаются сверху вниз.
- `column-reverse`: элементы располагаются снизу вверх.

![](_png/ff3c6298f4976828018a0162c9302789.png)

![](_png/d49078f3ea00394c12eab7f62b9320e2.png)
![](_png/6e3b7bbfe89e0a9f747ba4accdbf91bd.png)
![](_png/99340cb846888de769a13162292ddbe6.png)

Иногда изменения порядка отображения элементов в контейнере недостаточно. В таких случаях мы можем применить свойство **order** для конкретных элементов. По умолчанию, значение этого свойства у элементов равно **0**, но мы можем задать положительное или отрицательное целое число этому свойству.

![](_png/00535c2b7a99ba940a5dfe80d5df042c.png)
![](_png/0ae2c7e51814ad178ebcad54e48c56c4.png)
![](_png/21f8405ca16b185231eed7069b2aff99.png)

Еще одно свойство, которое можно применить к определенному элементу это `align-self`. Это свойство принимает те же значения, что и `align-items`.

![](_png/faf2a2fc25bce9937444146867c287ae.png)
![](_png/5129f3c39681b78d25c937898c30fdfe.png)
![](_png/0e32f9caa1d41e76c53f12b49f852660.png)

Если объектов слишком много и их сплющило на одном ряду лилий, то раздвинуть их можно помощью свойства **flex-wrap**, которое принимает следующие значения:

- `nowrap` - Размеры элементов устанавливаются автоматически, чтоб они поместились в один ряд.
- `wrap` - Элементы автоматически переносятся на новую строку.
- `wrap-reverse` - Элементы автоматически переносятся на новую строку, но строки расположены в обратном порядке.

![](_png/34333789988582e7c13e22ba1da0821e.png)
![](_png/80cb98289dccf4f63949f3d2931ddef3.png)

Два свойства `flex-direction` и `flex-wrap` используются так часто вместе, что было создано свойство `flex-flow` для их комбинирования. Это свойство принимает значения двух этих свойств, разделеные пробелом.

Например, можно использовать `flex-flow: row wrap`, чтоб элементы располагались в ряд и автоматически переносились на новую строку.

![](_png/8c6a78a225e756f8475c8267957de748.png)
![](_png/e4e82a6d52771eebbbaa1442b3b7b4a2.png)

Лягушат раскидало по всему пруду, но лилии сгруппированы в верхней части. Можно использовать `align-content`, чтобы указать, как несколько рядов должны отделяться друг от друга. Данное свойство принимает следующие значения:

- `flex-start` - ряды группируются в верхней части контейнера.
- `flex-end` - ряды группируются в нижней части контейнера.
- `center` - ряды группируются вертикально по центру контейнера.
- `space-between` - ряды отображаются с одинаковыми расстояниями между ними.
- `space-around` - ряды отображаются с одинаковыми расстояниями вокруг них.
- `stretch` - ряды растягиваются, чтоб заполнить контейнер равномерно.

Это может запутать, но `align-content` отвечает за расстояние между рядами, в то время как `align-items` отвечает за то, как элементы в целом будут выровнены в контейнере. Когда только один ряд, `align-content` ни на что не влияет.

![](_png/11debfc5e3243edd873bf0226916f879.png)

В последнем примере стоит обратить внимание на `wrap-reverse`

![](_png/0579d4c4e345a5f38a370b4d1a852b50.png)![](_png/13ab3ef7a8080bcaffe769a97e7b7a09.png)

Шпаргалка по FlexBox

![](_png/609222bdb962754d27a7d7d224dc3957.png)

### 5 Что такое Grid и как его использовать
#CSSGrid 

Кратка шпаргалка по всем свойствам гридов

![](_png/e5a975a011ee53f883262c81a05c57e5.png)

Очень классная шняга. `$` - подставит число в класс, `{$}` – впишет число внутрь тега (или любой другой текст)

![](_png/9286ff0cc5918f58b871c05d4dd618b4.png)![](_png/53a042a3dde85ff3b33488d03054627c.png)

Для начала инициализируем несколько объектов нашей сетки

![](_png/ecba4ea2da62f2298169528806881e62.png)

Первым делом, чтобы у нас всё заработало, нужно воспользоваться `display: grid`, который включит сеточное отображение

Дальше, чтобы были видны изменения, нам нужно создать шаблон через `grid-template-columns`, в котором мы укажем размеры наших колонок. Сколько размеров мы укажем, столько размеров и будет. Единицы измерения поддерживаются любые

![](_png/cf11227cd18cec8ee5e3c3b7ffb46856.png)![](_png/db510ea7d134f0eeea8385c12f02ad63.png)
![](_png/76b0cc09f163537fce4a350c3da2203f.png)

Но чтобы равномерно поделить колонки, используются фракции – `fr`. Они определяют какую часть будет занимать колонка от всей части таблицы

![](_png/891c8bced2974dc87dd357b78585b73b.png)

Так же можно описать куда больше колонок (число колонок, размер)

![](_png/49eb6c785046e495c7a7cdd5449e5aba.png)

Так же можно вписать несколько размеров и они будут чередоваться

![](_png/8b98ea9a53458c597ab40a05d3432ec9.png)

Когда мы задаём теплейт на строки, то мы меняем их размер (сколько значений – столько и размер каждой отдельной строки)

![](_png/909029faa8ee4c59d4507a55be66818a.png)

Так же мы можем добавить gapы по колонкам или строкам отдельно

![](_png/627d5f557d34a6fa15f4618c338d2f8e.png)

Либо мы можем просто добавить гэпы сразу для всех одинаковые

![](_png/b2145eb46bbaf95664a6933f91d97e70.png)

`grid-auto-rows` указывает размер для тех строк, для которых он явно не задан

![](_png/4399e05a07c7b7fb59dbe7ed4098dc4b.png)

Для задания размера строки так же рекомендуется использовать функцию `minmax()`, которая позволяет задать размер для них и расширять строки под размер контента

![](_png/32ebf3fd98e13a3524cfa61833426f95.png)

Данные два параметра работают только если их родителю (тут - контейнеру) заданы фиксированные параметры размеров

`justify-content` – выравнивает элементы колонки по оси Y
`align-content` - выравнивает элементы колонки по оси X

![](_png/9406a8a57d20846cf28f034adad153ef.png)

`align-items` позволяет сделать выравнивание относительно ячейки и она будет подстраиваться под контент, который в контейнере

`justify-items` же выравнивает колонки по икс-координате

![](_png/b44688d6ddaeb87b0855508ad5c09c6e.png)
![](_png/bcb06e4dcacacd312e1a6d175385346f.png)

И при комбинировании инструкций `align-self` и `justify-self`, которые влияют на сам объект отдельно, мы спокойно можем создавать макеты любой сложности

![](_png/69617f6e5f96908c745c9964f8834c58.png)

Данные инструкции уже конкретно показывают, какое положение будет занимать определённый блок грида в таблице.

1) Указывает, с какой колонки начинается элемент
2) Указывает окончание колонки (последняя видимая колонка в таблице + 1)
3) Указываем номер строки, с которой начинается объект
4) И на которой заканчивается

![](_png/0b1cfe76450aa34768e5cc56c2ca7d14.png)

И вот пример. Мы можем менять положение объектов из одного места в другое

![](_png/49edd4c36fd40d7e9924379df8dbfb8d.png)

А вот пример короткой записи прошлых значений, где через слэш мы пишем: откуда начинается/где заканчивается.

![](_png/d30c2c56496652a4c611b9011dc3d3ae.png)

Так же девтулз спокойно отображает количество занимаемых строк и столбцов

![](_png/56844fa4914c50f38f4fc7930b7a2354.png)

Так же есть ещё один крайне полезный инструмент – это `grid-template-areas`

![](_png/1ae7451b80390c10cfa0bacdb3fe2d80.png)

### 5.5 Методология БЭМ и как ее использовать
#BEM 

- БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste».

> БЭМ – это:

- Блок
- Элемент
- Модификатор

Используется БЭМ, чтобы реализовать методологию, по которой мы будем переиспользовать элементы много раз и не разводить копи-пасту

![](_png/9024e865adbbdff936ed7164afb526d6.png)

Блок – это заранее заготовленный элемент, который хранит в себе контент. Ему можно определить размер, расположение контента внутри него и всё остальное, что влияет только на контент внутри него.

Внутри блока находятся либо его дочерние элементы, либо другие блоки.

Блоки создаём, когда один и тот же элемент повторяется на странице несколько раз

![](_png/fea1b05d7e00dc0ce83e2786d833106b.png)![](_png/98b7ffc7ca40b552ebc64aa698e5b869.png)

Элемент показывает нам, что перед нами находится. Данный класс позволяет стилизировать и работать с определённым элементом блока отдельно. Ему позволяется задавать отступы и размеры. Стилизовать же желательно через миксы (например, создать класс `text`, которым мы будем модифицировать только текст)

Элементами блока называем все вложенные элементы, которые принадлежат родителю. Например, блок навигационного меню `nav` и его дочерние элементы `nav__item`, внутри дочерних элементов ссылки `nav__link` (вкладывать родительские элменты – нельзя `nav__item__link` - неправильно**)

![](_png/47d9c9c01b1e56b90cc432841d230031.png)

Если описывать более конкретно, то слева у нас Блок – Блок – Элемент – это **неправильно**. У нас идёт Блок – Элемент – Элемент и пример справа нам показывает это. Справа мы видим привязку элемента к блоку, а не элемента к элементу (как слева, где элемент выражается как блок)

![](_png/84c5b73c2b8a3455149724485ca2bd75.png)

Модификатор уточняет сам объект. Если у нас несколько блоков текста внутри блока, то мы прописываем первым классом – `блок__элемент`, а вторым классом – `блок__элемент_модификатор`

Модификатор отдельно выделяет один конкретный объект среди многих, чтобы задать этому отдельному элементу уникальные стили

![](_png/3fcd1c96c755581fd815a4cda84f002c.png)![](_png/b49dc9567f40a1a641f3a9ef43adb6df.png)

Миксы позволяют совмещать поведение и стили

В данном примере `header-button__text` является как элементом блока `header-button`, так и отдельным независимым элементом за счёт класса `text`

Такой подход позволяет задать внешнюю геометрию или позиционирование в `header-button__text`, а сами стили прописать в `text`, что позволяет использовать класс `text` для стилизирования отдельных таких же элементов на странице

![](_png/2b06ab8cf8c541b3b4b9cfb235c6251a.png)

### 5.6 Используем FlexBox и БЭМ в новом проекте

Нормализаторы кода закидываем в таком порядке

![](_png/fbca8b8beb86309f50651315626e912c.png)

Ну и включаем все отступы (паддинги и марджины) в счёт размеров наших блоков

![](_png/66e0d7c6b191931842e32866ae454d73.png)

И сразу нужно объяснить, какую роль тут играет методология БЭМ.

Во-первых, мы сделали `main-section`, который будет отвечать за содержимое только нашей основной секции, в которой будет располагаться контент первого отдела.

Во-вторых, мы сделали внутри отдельный контейнер, который уже будет отвечать за центрирование и ограничение в ширину всего контента, который будет в нём находиться. Так же мы дописали ещё один класс (описательный - БЭМ), чтобы работать конкретно с ним (потому как класс контейнер мы будем переиспользовать по всему сайту)

Ну и дальше в хедере мы будем хранить то, что будет располагаться в хедере

![](_png/0b91b7a8696d34f3e8f57f13075db3c1.png)![](_png/46352456e4b10ff39aefa86dfaec6582.png)

Ну и тут мы уже описываем наше навигационное меню.

Во-первых, мы добавили после хэдера секцию нав, которая будет иметь БЭМовский класс (в котором у нас указано где находится и кому принадлежит навигационная строка) и отдельный класс для стилизации (он поможет сделать шаблон стиля навигационного меню, который в дальнейшем получится переиспользовать)

Во-вторых, мы сделали сам список. Для ul мы прописываем флекс-бокс свойство для расположения списка в строку. Каждому элементу списка приписываем отступ справа (по правилу право-низ) и описываем размер шрифта. Далее так же удобно прописываем псевдокласс через амперсанду и для последнего элемента убираем отступ.

В-третьих. В классе мэин-секшн делаем отступ сверху 16 пикселей (чтобы отодвинуть навигационное меню). Дальше обращаемся к контейнеру, который будет у нас регулировать расположение header и nav. Располагаем хедер и футер в строку (row) и через джастифай располагаем их в разных концах страницы (space-between – располагает элементы на равном удалении, равномерно заполняя строку, в которой элементы находятся). Далее выставляем высоту данного меню и центрируем лого и список

![](_png/e8f6154bfbd954293b4f772b48923bfa.png)![](_png/f87b8f8b5bf1f1c9fecbf1cf6e83230a.png)

Конкретно этими двумя строчками мы задаём высоту контейнера с навигационным меню и располагаем элементы относительно друг друга по центру (текст становится вровень с логотипом)

![](_png/301c11db716332cbcdd626d2150278da.png)![](_png/fda7d47ecac90918cc0bdb28231d9767.png) ![](_png/5b9d2ee5a4caba73cf3d2f649771495b.png)

### 5.7 Как превратить растровый логотип в векторный с помощью Illustrator

Если нам отправили некачественное изображение, да ещё и в png (несжатый формат с альфаканалом), то оно во-первых весит много и во-вторых имеет свойство пикселизироваться. Поэтому стоит заиметь его `.svg` версию. Сделать её мы можем сами в иллюстраторе

![](_png/dab48343173249995e7b80d2b467afac.png)![](_png/6f17a6993b0b73daf4423efa79ef909a.png)

Ну и для того, чтобы отобразить логотип на сайте, нам нужно задать ему хотя бы минимальный размер (взять ширину из нашего макета). Вписать размер нужно, так как данный формат может бесконечно скейлиться

![](_png/52ff721d4b62d2bef6f52e37d4eded57.png)

### 5.8 Закругление, поворот и тени для элементов

Закругление: `border-radius: 100px`

Тени: `box-shadow: 0px 4px 4px 4px rgba(0, 0, 0, 0.25)`
Отступ по горизонтали, по вертикали, ширина тени, растяжение тени и последнее значение – цвет тени

Поворот:
Тут уже стоит отдельно зайти на справочник и взглянуть на множество вариантов использования [transform](https://html5book.ru/css3-transform/)

![](_png/95c3fad9cdce02dcbafadfa53f19210f.png)

Реализация самого контента первого блока уже будет поделена на две части: левую и правую.

Во-первых, мы создадим второй контейнер и дадим ему второй класс по БЭМу. В этом контейнере зададим два дива, где поделим блок пополам (гитарист с блоками – слева, текст - справа). В левый блок закинем картинку с нашим гитаристом. Под картинку закинем три дива, которые будут представлять у нас блоки позади гитариста (их мы будем стилизовать так же, как в фигме)

Во-вторых, приступаем к вёрстке стилей. Первым делом нашему родителю назначим позиционирование `relative` (для того, чтобы абсолютно спозиционированные объекты отталкивались от него, а таких объектов у нас будет 3 – и это блоки). Дальше нам нужно накинуть `relative` на нашу картинку. Позиционировать абсолютно мы её не будем, но нам нужно задать ей индекс, чтобы позиционированные блоки оказались под гитаристом.

В-третьих, стилизуем блоки. Большинство стилей, а именно цвет, поворот, размер и тени – берём из фигмы (задать им обязательно размер, чтобы они в принципе отображались на странице). Обязательно позиционируем их абсолютно на странице (топ и лефт определяем экспериментальным способом). И так же не забываем указать им правильный `z-index`

![](_png/b1b3156641596f3083eba1e006d57c06.png)![](_png/ba81ab25b6632e7c80debe0f2e4f9286.png)

### 5.9 Что такое иконочные шрифты

И далее воспользуемся сервисом, который предоставляет иконки в виде шрифтов. Первым делом добавим js код к нам после стилей

![](_png/964096cf97f965300ffb176fe622e361.png)![](_png/35eaca88d2ddc52ad417308743eb7ebf.png)

Далее находим нужную иконку и копируем её код в наш блок

![](_png/3f9acd8a7ad242e44b8c14b351c637c7.png)![](_png/bdb41f65d40c757324176049084dbb54.png)

Основной особенностью этих иконок является то, что они представляют собой текст и редактируются как текст, но так как мы поместили их в блочные элементы, то и работать мы будем с текстом в блоках

![](_png/eecfbf5bd04987dde0a5a6d0c7e02add.png)

Далее опишем бордеры для наших иконок (высота, ширина **блока**, бордер и закругление)

![](_png/72cbc24c9d772f1c9e3c22bbe88355e9.png)![](_png/d79bee6b7d2d6d1f4e7cebd171edc166.png)

Далее к нашему контейнеру применим расположение объектов в ряд (левый и правый враппер будут находиться в одной строке)

![](_png/dbabcef708a560defff4afb662efa2de.png)![](_png/6f1f03244955322f81360f04a8ed3db6.png)

Две эти записи идентичны и дают одинаковый результат. Однако стоит пользоваться первым способом для выравнивания только мелких объектов. Выравнивать целые блоки (например, наш правый и левый враппер) не стоит, так как могут возникнуть конфликты с тем же марджином (у нашего контейнера может обнулиться марджин, выравнивающий его по центру страницы)

![](_png/1b325ffad48a653044b139b04b6c650f.png)![](_png/63d7fa94b7cb1d67bce5937427f9a88a.png) ![](_png/51308c9bd7400380d1724e550ff76809.png)

Данный код позволит выровнять иконки (текст) внутри блоков по центру

![](_png/d62dfbcc301dfd206351fd23c0dc5142.png)![](_png/407e5585c175ef9d958d7ec0358f5e46.png)

Через фонт-сайз меняем размер иконки (так как она - текст). Ну и делаем отступы между иконками

![](_png/74075ac55699a89a1e92ecb42a1783db.png)![](_png/4c3b9901f0044310c58c65ad3f3f1c2f.png)

### 5.10 Создаем первую кнопку

В первую очередь под нашими социальными сетями прописываем новый заголовок и прямо внутри заголовка можно прописать тег `hr`. Далее основная наша проблема: позиционирование элементов, а именно – текстовый блок над фотографией. Делается это через накидывание релэйтива на нашего родителя и через абсолют на наш райт-враппер (так же допишем ширину блока и положение от абсолюта)

![](_png/eeb0b358412374d419f2c89b649f39f2.png)![](_png/88fab6b6a2499aec1fdf456df1508af3.png)![](_png/bd2b18e10cf2dc01c4e44bb2cc0eb38d.png) 

Чтобы оттолкнуть иконки от блока райт-враппер, можно сделать внутренний паддинг. Так же нам нужно оттолкнуть текст от иконок, но уже через марджин-боттом

![](_png/cf37dff76892079a8122455a180c3225.png)![](_png/ef3f449cda581b458f6de47627b74050.png)

Сам тайтл уже преобретает больший шрифт и релэйтив позиционирование, так как нужно указать положение hr относительно нашего текста. Hr указываем позиционирование, ширину, положение снизу, уберём марджины, сбросим внешний вид линии и с одной стороны настраиваем линию (потому что если будем менять через просто бордер, то у нас задастся по всем 4ём сторонам он)

![](_png/5ad11f376ce25e8a2903ccbd7d17f6a0.png)![](_png/41608fb14346785059aff70e324138ca.png)

Текст под тайтлом добавляем с небольшим отступом от нашего основного тайтла. В качестве отталкивающего элемента мы выбираем бэм-блок (стилизуем все элементы через модификаторы)

![](_png/83e4f78c462fb01de3492acefa75bd2a.png)![](_png/4f355ba83c12dde1dde6039c0a86f57b.png)

И таким образом мы выравниваем кнопки и элементы внутри них в линию

![](_png/b9ced27c650f8df0f6156703bcaf6df6.png)![](_png/71646927cec73eff2f1957a3fb29e509.png)

Далее мы стилизуем нашу кнопку

![](_png/1fa61914ff8455c77eccddf5e09c61ca.png)![](_png/5015f1cb82811226bcf98ee5517b681f.png)

Выравниваем, отодвигаем

![](_png/eb00ff2720d8ff242a1d3e1f8ac821e4.png)![](_png/ba729d2e65023c25324aaa47b32dd291.png)

### 5.11 Используем модификатор БЭМ. Новое свойство overflow

Тут мы уже вспомним про использование модификаторов БЭМ. Стилизация и БЭМизацция элементов.

В основных стилях мы описали размеры, градиент и закругление блока. Выравнивание сделали для внутреннего круга (который имеет цвет фона), который будет у нас отвечать за вырез в круге.

Первым делом мы создали первый блок кругов внутри контент-контейнера (располагаются под текстом).

Второй уже блок кругов мы расположили в мэйн-секшн, который отвечает впринципе за все элементы в основном блоке. 

![](_png/c4cd313b56fbeac2ef633bc14fbee926.png)

Данный фрагмент кода отвечает за позиционирование круговых элементов на сайте. Спозиционировали круги мы относительно нашей основной секции на странице

![](_png/cb2a44fa2443fd5ca9e2a0d7809edd27.png)

Так же дополнительно стоит обратить внимание, что при изменении ширины страницы, у нас появляется данное выползание круга из-за границы. Это нужно исправлять

![](_png/516ee8781bea768c3cf89a020368a4d2.png)

**Важно!** Существует такая инструкция как `overflow`, которая регулирует отображение элементов за краями блока. С помощью данной инструкции мы можем скрыть всё, что находится вне блока

![](_png/9cff3481c90c45e641aac9f621f8e3bf.png)![](_png/fb7152012483acc29ebd45e9be141680.png)

### 5.12 MinMax – HeightWidth

Тут представлен код с `max-width`. Данный пераметр указывает, что максимально размер элемента может растянуться до 1000 пикселей, но при уменьшении страницы, он будет уменьшаться

![](_png/62d74e10716d9e8e48077dfcfe7953fd.png)![](_png/943f1c4c78dae8f5f74144ed2b9f502a.png)

Это уже работа `min-width`. Минимально – 1000 пикселей, но растягивается до максимального значения

![](_png/1a9826d2f16cfcc9c6d65de468cf0add.png)

Но как мы можем увидеть, если наш элемент помещается в максимум 1000 пикселей, то он может и не вместиться в родительский элемент

![](_png/7b223956fc28f5b0be2fa97afb1ffd8c.png)![](_png/9f960dd5fbdb819720e0ef423a4dc775.png)

Но так же минимальную высоту можно установить и для родительского элемента и тогда он будет размером с занимаемое пространство с два этих бокса

![](_png/96e643cdb723ea006c4d6ca2853b6ffd.png)![](_png/bf4fcd1ea51707ea7c1db7991ba09582.png)

Такой подход с размерами для элементов страницы нужен, например, чтобы не угадывать с размерами блоков сайта. Потому что заказчик может вместо текста рыбы вставить свой текст

![](_png/3b758b8f9fa99218899e41f61bacbe30.png)

### 5.13 Практика. Создаем вторую секцию сайта

**Лайфхак!** Так же в браузере есть интересный лайфхак, который позволяет в реальном времени двигать объекты на странице, что позволяет их нормально спозиционировать без подгадываний и высчитываний

![](_png/116c70e340c31b98e9abb5cc7cbc9c19.png)

А чтобы быстро найти класс, не забываем пользоваться поиском

![](_png/b586d37e6922f4f8f16223aa8c1f2ede.png)

Секции лучше именовать секциями

![](_png/61f8e7589bc3fcc721594648d7d36771.png)

Перед использованием изображений, лучше их кропнуть и потом выгрузить в таком формате

![](_png/641b3a1b72d97f9895912ccdc95d149c.png)

Пример структуры:

![](_png/ed82ec2d0d7a2dcb0ab1e45180225720.png)![](_png/1dc472f8f317c931c9ee173e51f32270.png)

> Лайфхак! Так же в консоли разработчика имеется подсказка флекс-расположений. Если на неё нажать, то можно выбрать предустановки отступов и посмотреть на них, что крайне удобно

![](_png/1bacefab1e50cf230ffddf66a8a9a2f2.png)![](_png/b5225e233a5ad544b69d86bdfd9cab23.png)

Так же если нам нужно сделать равномерное расстояние между объектами (без привязки к `margin-right`), то можно воспользоваться данным свойством

![](_png/612a55cfd71a0ba541507b3bd570a6b2.png)![](_png/e3b33f93deebf9104dbe703d2142a5ea.png)

### 5.14 Практика. Создаем третью секцию сайта

Небольшое пояснение. Если мы хотим расположить абсолютно-спозиционированный элемент под обычным, то нам достаточно просто указать `z-index: -1`. Однако если у нас прописан бэкграунд, то родительскому элементу нужно указать не просто релативную позицию, но и указать `z-index: 0`

![](_png/5e751934903ffa729d4ca4977381cec8.png)

### 5.15 Практика. Создаем footer сайта

Сейчас нужно пояснить за структуру и почему стоит пихать высоту блока в контейнер, если мы выравниваем положение через флексы всего одного элемента. Дело в том, что фотографию тут мы абсолютно спозиционировали и теперь нам нужно отодвинуть один текстовый блок в бок и если мы не зададим высоту внутри блока, то он будет иметь размеры сугубо равные нашему текстовому блоку

![](_png/1547ced23115c817fb2d30e74cdb7690.png)![](_png/d09446f40b38f9ac0f5eb3a47ba1fe4f.png)

Ну и так же можно подключить шрифты таким способом

![](_png/329274b3244c39f9d56188de455d4554.png)

### 5.16 Добавляем якорные ссылки на навигационное меню

Якорные ссылки добавляются через `id` элемента и позволяют создать связь между ссылкой и элементом на странице

![](_png/4495b5c968ed23b85db0c7dbd8ede7c1.png)![](_png/9ff8cb3b48eb989b0e49b7a296559334.png)

### 5.17 Что такое fav-icons, и как их установить в свой проект

Фавиконки генерируются из изображений 512 на 512 пикселей.

![](_png/396d57ecee5eb7cb3b260cee3cf2db47.png)![](_png/dfeb6797329b51ec9c7cfffac561c824.png)

И подключаются через линки

![](_png/bd5fc2d152ff31c9f4e79678c681201f.png)