#nvim #neovim #console #IDE

>[!summary] Писать в виме - это как использовать определённый язык программирования. Мы общаемся с Вимом, используя определённый синтаксис. `d2w` может расшировываться, как `delete 2 words`, что является понятным путём для редактирования текста. Каждое сочетание в виме переводится определённым полноценным словом, которое описывает действие клавиши. 

## Введение

Vim - это консольный редактор

Его можно как запустить удалённом сервере и уже поднять внутри него свою конфигурацию, так и просто импортировать конфигурацию удобно и быстро на любой другой компьютер 

![](_png/Pasted%20image%2020240901115145.png)

Стоит различать, что vim-motions и vim-редактор - это две разные сущности, которые можно отделить друг от друга. Те же моушены можно использовать в любой IDE или редакторе через плагины, потому что это целый подход к работе с текстом.

![](_png/Pasted%20image%2020240901115203.png)

## Настройка окружения

### Vim или NVim

Vim:
- присутствует из коробки во многих системах
- у него только один простой конфигурационный файл

NeoVim:
- Конфигурируется на lua, который проще vimscript и предоставляет возможность разнести разные группы по разным файлам 
- Является многопоточным и ускоренным за счёт libuv
- Имеет больше плагинов
- Имеет широкую базу различных удобных сборок

![](_png/Pasted%20image%2020240901123734.png)

### Выбор терминала

Самый универсальный вариант - Alacritty. Он работает под любой ОС.

![](_png/Pasted%20image%2020240901125018.png)

### Настройка терминала

По пути нам нужно будет создать конфиг для alacritty

`~/.config/alacritty/alacritty.toml`
```bash
[env]
TERM = "xterm-256color"

[font]
size = 13.0

[font.normal]
family = "JetBrainsMono Nerd Font"
style = "Regular"

[window]
decorations = "Buttonless"
opacity = 0.92
blur = true

[window.padding]
x = 0
y = 0

[selection]
save_to_clipboard = true
```

Далее устанавливаем zsh на нашу систему, если не установлен и указываем в качестве дефолтного терминала

```bash
sudo apt install zsh
chsh -s $(which zsh)
```

Далее нужно добавить данный конфиг для zsh

`~/.zshrc`
```bash
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi


# Path to your oh-my-zsh installation.
export ZSH="$HOME/.oh-my-zsh"
export KUBECONFIG=/Users/alaricode/.kube/purple-cluster_kubeconfig.yaml
export NVM_DIR="$HOME/.nvm"
  [ -s "/usr/local/opt/nvm/nvm.sh" ] && \. "/usr/local/opt/nvm/nvm.sh"  # This loads nvm
  [ -s "/usr/local/opt/nvm/etc/bash_completion.d/nvm" ] && \. "/usr/local/opt/nvm/etc/bash_completion.d/nvm"
ZSH_THEME="powerlevel10k/powerlevel10k"

plugins=(git z docker fzf thefuck zsh-autosuggestions history)

source $ZSH/oh-my-zsh.sh

if [ -f '/Users/alaricode/vk-cloud-solutions/path.bash.inc' ]; then source '/Users/alaricode/vk-cloud-solutions/path.bash.inc'; fi

# bun completions
[ -s "/Users/alaricode/.bun/_bun" ] && source "/Users/alaricode/.bun/_bun"
alias ls="eza --tree --level=1 --icons=always --no-time --no-user --no-permissions"

export PATH="/usr/local/opt/openjdk/bin:$PATH"
export PATH="/Users/alaricode/.cargo/bin"
export PATH=/bin:/usr/bin:/usr/local/bin:/sbin:${PATH}
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"

eval "$(fzf --zsh)"
function yy() {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
	yazi "$@" --cwd-file="$tmp"
	if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
		cd -- "$cwd"
	fi
	rm -f -- "$tmp"
}

function htt() {
  httpyac $1 --json -a | jq -r ".requests[0].response.body" | jq | bat --language=json
}

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh
```

И склонировать репозитории с плагинами `git z docker fzf thefuck zsh-autosuggestions history` (строчка `plugins = (...)`) в папку `~/.oh-my-zsh/custom/plugins`

```
https://github.com/nvbn/thefuck?tab=readme-ov-file#installation
https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#homebrew
https://github.com/agkozak/zsh-z
https://github.com/unixorn/fzf-zsh-plugin?tab=readme-ov-file#oh-my-zsh

https://github.com/romkatv/powerlevel10k?tab=readme-ov-file#oh-my-zsh
```

Далее устанавливаем [brew](https://brew.sh/)

````
brew install eza
````

### Установка NVim

```bash
sudo [apt install | dnf install | pacman -S] neovim
brew install neovim
```

### Создание первого файла

Так же мы можем создать новый файл через вим, передав имя и расширение файла. Если такой файл в папке уже существует, то вим просто откроет его.

```bash
nvim [название файла]
```

Для ввода данных, нужно будет перейти в режим ввода `i`

![](_png/Pasted%20image%2020240904190417.png)

Изначально файл создастся в нашем буфере и потом, когда мы запустим команду `:w`, он запишется к нам на диск

![](_png/Pasted%20image%2020240904190450.png)

Если мы уже вошли в вим, но не открыли файл, то это сделать мы можем через команду `:edit` куда передадим имя целевого файла

![](_png/Pasted%20image%2020240904190513.png)

## Базовые motion

### Режимы

>[!danger] NVim не воспринимает русскую раскладку во время работы с коммандами! Нужно перключаться на английскую.

Сама работа в симе поделена на несколько режимов, которые определяют доступный пул действий, которые мы можем выполнять в редакторе.

В Vim существует 5 режимов:
- *normal* - просмотр кода. Это основной режим для навигации, который является стандартным и используется для перемещения по файлу.
- *insert* - вставка. Позволяет вводить текст.
	- `i` - войдёт в режим вставки перед текущей позицией курсора.
	- `I` - войдёт в режим вставки в начале строки.
	- `a` - войдёт в режим вставки после текущей позиции курсора.
	- `A` - войдёт в режим вставки в конце строки.
	- `o` - создаст новую строку ниже текущей и войдите в режим вставки.
	- `O` - создаст новую строку выше текущей и войдёт в режим вставки.
	- `r` - заменит текущий символ (без перехода в режим вставки).
	- `R` - войдёт в режим замены, где можно будет заменять символы непосредственно.
- *visual* - выделение кода
	- `v` - войдёт в режим визуального выделения для выделения текста.
	- `V` - войдёт в режим визуального выделения для выделения строк.
	- `Ctrl + v` - войдёт в режим блочного выделения для выделения прямоугольных областей текста.
- *replace* - ввод с перезаписью существующего текста.
- *command* - позволяет работать с коммандами vim
	- `:` - вызывает режим команд

![](_png/Pasted%20image%2020240904190709.png)

### Базовые перемещения

#### Базовые движения

Для базовых перемещений по коду:
- `j/k` - вверх-вниз
- `h/l` - влево-вправо

#### Горизонтальные перемещения:

- `0` - перемещает в начало строки
- `$` - перемещает в конец строки
- `w/b` - переход вперёд/назад по словам с учётом пробелов
- `W/B` - переход по словам без учёта пробелов (помогает, если перемещаемся по большому количеству спецсимволов `<title>Слова внутри тега</title>`)
- `e` - переходит в конец текщего слова
- `E` - игнорирует символы, кроме пробела, перемещаясь к концу слова.

#### Вертикальные перемещения:

- `число + G` - перемещение на определённую строку (перейдёт на выбранную по числу строку)
- `число + jk` - перемещение вверх/вниз на определённое число строк
- `gg` - перемещение в начало файла
- `G` - перемещение в конец файла

### Как практиковаться

Даже если пока не получается сидеть в виме, можно установить плагин для работы с Vim Motions в любом редакторе

![](_png/Pasted%20image%2020240907135304.png)

### Комбинации движений

Комбинации - это последовательность действий. которые мы можем выполнить за счёт объединения сочетаний в виме

Operator - это действие, которое нужно выполнить над текстом
Count - это количество Motion (так же есть альтернатива в виде указания места)
Motion - это действие передвижения, в рамках которой будет выполнен оператор

![](_png/Pasted%20image%2020240904191102.png)

`d3w` удалит 3 слова (aka *delete 3 words*)

![](_png/Pasted%20image%2020240908095804.png)

`d3j` удалит уже 3 строки вниз

![](_png/Pasted%20image%2020240908100123.png)

`di(` - удалит текст внутри скобок

![](_png/Pasted%20image%2020240908100347.png)

Все те движения, что мы совершаем в виме - мы можем откатить. Если нам нужно будет откатиться на прошлое движение, то мы можем воспользоваться `ctrl + o`. Может это быть полезно, например, если мы зашли внутрь типа и нам нужно быстро вернуться обратно либо в случае, когда мы перешли не в ту часть файла. 

### Продвинутое перемещние

`$` - переход в начало строки
`0` - переход в начало строки
`gg` - переход в начало файла
`G` - переход в конец файла

`:set nu` вызовет номера строк

![](_png/Pasted%20image%2020240908101512.png)

`:set relativenumber` вызовет относительные номера строк, которые позволят нам не считать количество строк, на которое мы можем переместиться, например, той же командой `5j`

![](_png/Pasted%20image%2020240908101714.png)

`f` ищет определённую букву в строке вперёд, а `shift+f` ищёт назад

`f` + `o` - найдёт первую найденную букву `o` в строке
`2fo` - перейдёт сразу ко второй названной `o` в строке

![](_png/Pasted%20image%2020240908102400.png)

Если нужно продолжать передвигаться дальше по найденной букве, то мы нажимаем `;`

![](_png/9265fdd14432504666790112c4bc5dcd.png)

### Перемещение по блокам

`{` / `}` - позволяют перемещаться между разрывами строк

![](_png/Pasted%20image%2020240908104202.png)

`%` - позволяет нам передвигаться между открывающей и закрывающей скобками (любыми)

![](_png/Pasted%20image%2020240908104715.png)

![](_png/8cc92ac09ccb25ccbb38d65b924d84db.png)

![](_png/Pasted%20image%2020240908104926.png)

`[` / `]` + определённый тип скобки - позволит переместиться к ближайшей скобке

`[}` переместит изнутри блока к ближайшей фигурной скобке. А уже комбинация `]}` сделает то же самое, но к закрывающей скобке. Так же это работает и с любыми другими скобками.

![](_png/Pasted%20image%2020240908105220.png)

`ctrl + d` / `ctrl + u` - перемещение на страницу вниз/вверх

`_` - позволит нам перейти к первому символу строки. В отличе от `0`, который переносит нас в целом в начало строки (даже включая табы).

![](_png/Pasted%20image%2020240908105705.png)

`-` / `+` уже будут переводить к началу/концу следующей строки

![](_png/Pasted%20image%2020240908105835.png)

### Файлы и buffers

Как уже и упоминалось ранее, vim работает с буфферами - он загружает файл в ОЗУ и редактирует его в нём.

Открыть файл мы можем через команду `:edit <file>`

Открыть директорию с файлами мы можем через `:edit .`. Тут у нас появится напрямую файловый менеджер из вима. Все команды указаны сверху и, например, `R` позволит переименовать файл.

![](_png/Pasted%20image%2020240908113245.png)

Команда `:buffers` позволит выписать список буфферов. В первом столбце идёт идентификатор буффера. Для перехода в определённый буффер, мы можем воспользоваться `:buffer <id_буфера>` для перехода в нужный 

`:bnext` / `:bprevious` позволят переместиться к следующему/предыдущему буферу

![](_png/Pasted%20image%2020240908113531.png)

`:buffer {` позволяет перейти в доку и узнать, что делает определённое сочетание на случай того, если мы забыли, что делает определённая команда 

![](_png/Pasted%20image%2020240908113809.png)

## Удаление и копирование

### Удаление текста

За удаление отвечает операцтор `d`. Он включает операцию удаления, которая позволит по моушену удалить нужный нам участок текста.

![](_png/Pasted%20image%2020240904191149.png)

Чтобы откатить изменения вместо `ctrl + z` в Vim работает `u`. Сам же вим хранит все изменения, которые мы совершали в файле, поэтому можно откатываться даже до тех изменений, которые были до входа в файл
Чтобы вернуть отменённые изменения, нам нужно использовать `ctrl + r`

#### Основные комбинации

- **d**: удаляет текст и остается в нормальном режиме.
- **c**: удаляет текст и переходит в режим Insert.

#### Работа с операторами и motion

- **dw**: удалить слово.
- **dd**: удалить строку.
- **db**: удалить назад до начала слова.
- **de**: удалить до конца слова.

#### Примеры комбинирования

- **d2w**: удалить два слова.
- **d$**: удалить до конца строки.
- **d10j**: удалить 10 строк вниз.

#### Переходы в режим Insert

- **cw**: удалить слово и сразу перейти в режим Insert.
- **cb**: удалить назад до начала слова и перейти в режим Insert.

#### Упрощенные операции удаления

- Используемые команды для удаления могут быть комбинированы с count (числом удаляемых объектов) и motion (движением курсора), что позволяет эффективно удалять большие участки текста.

### inside и around

Так же вместо *Count* мы можем использовать специальные операторы, которые будут выполнять действия в рамках определённых границ либо только за ними

- `d` – удалить
- `i (inside)` – внутри границ
- `a (around)` – вокруг границ
- `t` – тег

![](_png/Pasted%20image%2020240904191216.png)

Например, мандой `diw` мы можем выполнить действие внутри слова и удалить его целиком. То есть мы можем не переходить в его начало, а просто сделать действие удаления в самом слове. `daw` удалит и всё, что вокруг слова (пробелы).

`di"` удалит слово внутри кавычек `"example"` -> `""`

Команда `dit` удалит всё внутри тегов: `<title>Школа разработки</title>` → `<title></title>`

`di{` удалит всё внутри фигурных кавычек

Мы можем вместо удаления скорректировать текст с помощью `ci(` для круглых скобок с последующим вводом нового значения

### Копирование и вставка

#### Удаление текста и регистры

При удалении текста в Vim с помощью команды `d` (например, `dd` для удаления строки), текст автоматически попадает в регистр, который действует как временное хранилище или буфер обмена.

В зависимости от настроек, регистр может интегрироваться с буфером обмена нашей операционной системы.

#### Вставка текста:

Команда `P`  / `p` вставляет текст из регистра ниже / выше текущей строки.

Эти команды помогают вернуть удаленный или скопированный текст в нужное место.

![](_png/Pasted%20image%2020240915160743.png)

Если вырезана не вся строка, то `P` и `p` всталяют до/после курсора

![](_png/Pasted%20image%2020240915160828.png)

#### Копирование текста:

Команда `y` копирует текст, аналогично удалению, но не удаляя его. Этот процесс в Vim называется "yanking".

`yy` копирует всю строку.

Можно использовать комбинации, аналогичные удалению, для копирования отдельных частей текста (например, `yi"` для копирования текста внутри кавычек).

![](_png/Pasted%20image%2020240915161159.png)

#### Модификаторы движения и копирование

Они работают аналогично тем, что используются при удалении:

- `yw` копирует слово.
- `y$` копирует текст до конца строки.
- `yi<тег>` копирует текст внутри HTML-тега.

### Регистры

Проблема: мы скопировали одно значение, удалили другое, вставляем и получаем то, что у нас вставилось из регистра последнее значение в виде удалённого только что текста (скопировали *Блог*, удалили *Курсы* и вставили *Курсы*, хотя хотелось *Блог*)

Дело в том, что мы помещаем все скопированные и удалённые значения в **дефолтный регистр**

![](_png/Pasted%20image%2020240915162206.png)

Просмотреть ВСЕ регистры (включая дефолтный) и их содержимое можно командой `:registers`

`Type` - говорит нам о типе данных, который присутствует в регистре (`Character`, `Line`, `Block`) 

`Name` - имя регистра

`Content` - контент регистра

![](_png/Pasted%20image%2020240915162708.png)

Чтобы вставить и прочитать значение из именованного регистра, нужно перед началом команды записать индекс используемого регистра:
- `"2yiw` - запишет слово во второй регистр
- `"2p` - вставит последнее значение из второго регистра

`"` - это префикс регистра

И такое использование вполне можно комбинировать с использованием дефолтного регистра, когда мы копируем одного, второе, третье, четвёртое слово в разные регистры и потом достаём значения из них по очереди.

>[!info] Использование регистров
>- **Дефолтный и нулевой регистр** всегда обновляются автоматически, используйте их для повседневных задач.
> - **Именованные регистры** удобны для хранения полезного текста, который не должен быть перезаписан.

## Преобразование текста

### Замена текста

#### 1. Удаление одного символа

- Чтобы удалить один символ, достаточно нажать клавишу `X`.
- Например, для удаления символа `#` в определенной строке, переместитесь на эту строку и нажмите `X`.

#### 2. Замена текста

- **Режим замены (Replace Mode)**
    - Активируется нажатием `Shift + R`.
    - В нижней части экрана появляется надпись "Замена", каретка подчеркивается.
    - В этом режиме каждый вводимый символ будет замещать текущий, а каретка будет перемещаться на следующий символ.
    - Полезно, когда нужно переписать текст непосредственно поверх существующего.
    - Например, замена "header" на "footer":
        1. Переместите каретку на начало слова "header".
        2. Нажмите `Shift + R`.
        3. Введите `footer`, замещая каждый символ поочередно.

#### 3. Практическое применение Replace Mode

- Иногда Replace Mode используется редко, так как в некоторых случаях может повредить форматирование.
- Пример, когда он может пригодиться:
    - Дописать текст в конце строки.
    - Например, в режиме замены (`Shift + R`), вводите новый текст и корректируете его форму.

### Поиск по буферу

#### Основные методы поиска:

1. **Поиск по текущему слову (звездочка** `*`**):**
    - Перейдите курсором на слово (например, "stealth shade").
    - Нажмите `*`.
    - Все вхождения слова подсветятся, и курсор переместится к следующему совпадению.
    - Используйте `n` для перехода к следующему совпадению и `Shift+n` для перехода к предыдущему.
2. **Снятие выделений:**
    - Чтобы убрать подсветку поиска, используйте команду `:nohighlight`.
    - Подсветка исчезнет, и перемещение с помощью `n` перестанет работать до нового поиска.

#### Ввод поиска вручную:

1. **Команда поиска (/):**
    - Нажмите `/` и введите слово или фразу, которую нужно найти (например, "styles").
    - Совпадения подсветятся при вводе, переходите к ним `Enter`.

#### Использование регулярных выражений:

1. **Простейший пример:**
    - Вы можете использовать регулярные выражения для поиска сложных паттернов.
    - Например, для поиска строки в кавычках: `\/".*?"`.
    - Все совпадения подсвечиваются, и вы можете перемещаться между ними.

#### Примеры использования:

- **Поиск и переход к конкретному элементу:**
    - Например, если знаете, что нужно отредактировать "header":
        - Введите `/header`, нажмите `Enter`.
        - Перемещайтесь с помощью `n` между всеми "header".

#### Замена в файле

В предыдущих лекциях мы научились осуществлять поиск. Теперь рассмотрим, как корректировать или заменять найденный текст — будь то отдельные строки или целый буфер.

1. **Поиск и корректировка:**
    - Найдите текст, например, "styles".
    - Переместите курсор к первому вхождению и скорректируйте его:
        - `C` для корректировки
        - `Gn` для перемещения к последнему найденному вхождению
2. **Поиск и удаление:**
    - Найдите текст, например, "styles".
    - Удалите найденное вхождение:
        - `DELETE Gn`

#### Команда замены

1. **Замена в одной строке:**
    - Начните с `:`, затем команда `s` для замены, через слэш введите что ищем и на что заменяем.
    - Пример: `:s/styles/aaa/` — заменяет первое вхождение "styles" в текущей строке на "aaa".
2. **Глобальная замена в одной строке:**
    - Пример: `:s/styles/aaa/g` — заменяет все вхождения "styles" в текущей строке на "aaa".
3. **Замена по всему буферу:**
    - Используйте `%s` для поиска и замены по всему буферу.
    - Пример: `:%s/styles/aaa/g` — заменяет все вхождения "styles" на "aaa" во всех строках буфера.

#### Регулярные выражения

- Используйте регулярные выражения для более сложных поисков и замен:
    - Пример: `:%s/\s+/ /g` — заменяет все пробелы на одиночный пробел.
    - Флаг `i` для игнорирования регистра: `:%s/styles/aaa/gi` — заменяет "styles" и "Styles" на "aaa".

#### Локальные сервера протоколов (LSP)

- В случае переименования переменных в рамках нескольких файлов, используются LSP сервера.
- Это тема для следующих лекций.

## Visual mode и макросы

### Visual Mode

#### Введение

- Визуальный режим дополняет другие режимы, такие как Insert, Replace и Command.
- Ускоряет выполнение задач редактирования.

#### Типы визуальных режимов

1. **Простой визуальный режим (v)**
    - Активируется клавишей `v`.
    - Текст выделяется при перемещении курсора.
    - Выделенный текст можно удалять, копировать, корректировать.
    - Переход в нормальный режим выполняется клавишей `Escape`.
2. **Режим визуального выделения строк (Shift + v)**
    - Активируется комбинацией `Shift + v`.
    - Выделяются целые строки.
    - Удобен для копирования больших блоков текста.
3. **Визуальный блок-режим (Ctrl + Shift + v)**
    - Активируется комбинацией `Ctrl + Shift + v`.
    - Выделяется прямоугольный блок текста.
    - Полезен для операций с текстом в столбцах.

#### Основные команды в визуальном режиме

- **Копирование (y)**
    - Например, `yy` — копировать строку, `yw` — копировать слово.
- **Удаление (d)**
    - Например, `dw` — удалить слово, `dd` — удалить строку.
- **Корректировка (c)**
    - Например, `cw` — изменить слово.

#### Использование регистров

- При вставке поверх текста удалённый текст попадает в регистр.
- Регистры помогают сохранять текст для последующего использования.
- Можно обратиться к другому регистру для вставки определенного текста.

#### Примеры

1. **Копировать и вставить строку**
    - Выделить строку с помощью `Shift + v`.
    - Копировать строку `y`.
    - Вставить `p`.
2. **Заменить слово**
    - Выделить слово с помощью `v` и перемещения.
    - Вставить новое слово `p`.
3. **Работа с регистрами**
    - Скопировать текст в регистр: `"ayy` (копировать строку в регистр a).
    - Вставить текст из регистра: `"ap` (вставить текст из регистра a).


### Изменение регистра

1. **Отмена изменений (обычный режим vs визуальный режим)**:
    - `U` в обычном режиме — отменяет изменения.
    - `U` в визуальном режиме — имеет другое значение.
2. **Изменение регистра слова**:
    - Для выбора слова:
        - `v` — активация визуального режима.
        - `ve` — выбор слова.
    - Для изменения регистра:
        - `Shift+U` (большая буква) — меняет на верхний регистр.
        - `u` (маленькая буква) — меняет на нижний регистр.
3. **Пример с константами**:
    - Выбор и изменение регистра:
        - `ve`
            - `Shift+U` — для констант, которые должны быть в верхнем регистре.
4. **Использование тильды**:
    - Тильда `~` также меняет регистр, но без дополнительного выделения.
5. **Изменение конкретной буквы**:
    - Для выделения символа:
        - `v` — активация визуального режима.
        - Выбор символа.
    - Для изменения регистра отдельной буквы:
        - Переместить каретку на символ.
        - `Shift+U` — для верхнего регистра.
    - Пример с фразой "Purple School":
        - Меняем `P` и `S`:
            - Переместить каретку на символ.
            - `Shift+U` для верхнего регистра.


### V-Line Mode

#### Основные возможности Visual Line Mode:

1. **Выделение строк**:
    - Нажмите `Shift + V`.
    - Для выделения строк вверх/вниз используйте стрелки.
2. **Операции со строками**:
    - **Удаление**: команда `d`.
    - **Копирование**: команда `y`.
    - **Вставка**: команда `p`.
3. **Перемещение строк**:
    - **Классический метод**:
        1. Удалите строку: `dd`.
        2. Переместитесь в нужное место.
        3. Вставьте строку: `Shift + P`.
    - **Метод с командой** `move`:
        - Включите относительные номера строк: `:set relativenumber`.
        - Перемещение строк:
            - С конкретной строки на первую: `:m1`.
            - Относительно текущей строки: `:m-2` или `:m+10`.
4. **Комбинирование с визуальным выделением**:
    - Выделите строки: `Shift + V`.
    - Введите команду: `:` и затем `m + N` (например, `m + 2` для перемещения на 2 строки вниз).

#### Пример:

1. Выделите две строки с помощью `Shift + V`.
2. Нажмите `:`, затем введите `m + 2` для перемещения на 2 строки вниз.





### V-Block Mode

#### Введение в Визуальный Блочный Режим

- Вход в режим: **Control + Shift + V**
- Направления выделения: вверх, вниз, влево, вправо

#### Основные Особенности

- **Мультикурсор**: Позволяет редактировать несколько строк одновременно
- **Выделение блока**: Создание прямоугольного или квадратного выделения

#### Шаги для Редактирования

1. **Вход в визуальный блок:** Control + Shift + V
2. **Выделение нужного текста**: Нахождение нужного блока текста
3. **Переход в режим редактирования**: Shift + I (важно: просто I не работает)
4. **Внесение изменений**: Например, добавление "ABC"
5. **Применение изменений к выделенным строкам**: Выход из режима вставки

#### Дополнительные Возможности

- Удаление блока текста: Выделить блок → Нажать D
- Вставка текста в несколько строк: Текст вставляется во все строки ниже




### Макросы

#### Введение в Макросы

- Макросы позволяют автоматизировать повторяющиеся действия.
- Это особенно полезно для однотипных задач, которые нужно выполнять многократно.

#### Пример с JavaScript

- Задача: Преобразовать обычные функции в стрелочные функции.
- Исходный формат: `function myFunction() {}`
- Целевой формат: `const myFunction = () => {}`
- Примеры функций можно писать в любом произвольном буфере.

#### Инструкция по Записи Макроса

1. **Начало записи макроса:**
    - Нажмите `Q` для входа в режим записи макроса.
    - Нажмите `Q` второй раз, чтобы выбрать ячейку для записи (например, Q-Q).
2. **Запись последовательности действий:**
    - Все действия выполняемые после начала записи будут включены в макрос.
    - Удалите ключевое слово `function` с помощью команды `CIV` (correct inside word).
    - Добавьте `const` и измените структуру функции:
        - Выйдите из режима редактирования: `Escape`.
        - Найдите первую скобочку и добавьте `=` и `=>`.
        - Выйдите из режима редактирования снова: `Escape`.
3. **Завершение записи макроса:**
    - Нажмите `Q` снова, чтобы остановить запись.

#### Применение Макроса

- Нажмите `@` и затем укажите ячейку макроса, например `@Q`, чтобы применить макрос к текущей функции.





## Основы lua

### Установка

Установить lua достаточно легко можно через brew

```bash
brew inatall lua
```

Далее нам нужно будет создать файл с небольшим примером кода на lua

`demo.lua`
```lua
print("Привет!")
```

Далее нам нужно запустить терминал. Сделать это можно так же прямо в виме через команду `:terminal`. Начать писать можно через переход в режим *terminal* через `i`

И запускаем файл

```bash
lua demo.lua
```

![](_png/Pasted%20image%2020240908124724.png)

Из терминала можно выключить через стандартный `exit`

### Переменные

Переменные в lua делятся на локальные и глобальные.
Создать локальную переменную можно с помощью конструкции `local`.

Основные типы: числа, строки, булевы значения, таблицы, массивы (таблицы с числовыми индексами), nil

Конкатенация строк происходит через `..`
Вывести текст через `print()`
Вывести тип можно через `type()`

```lua
local a = 50
local b
b = 30
c = 80

local greeting = "Привет"
local excl = "!"

local isAdmin = true

-- Привет!
print(greeting..excl)
-- boolean
print(type(isAdmin))
-- 80 80
print(a + b, c)
```

### Циклы

Массивы в lua - это таблицы (объекты), ключами которых являются числовые значения. Значения индексов идут с 1, а не с 0.

Перебор по собственным нашим индексам, которые мы добавим в таблицу можно совершить через `for-i`. А пройти целиковый массив можно через `for-in`.

```lua
local array = {"london", "moscow"}
array[0] = "paris"
array[-1] = "denver"

-- Цикл for с числовыми индексами
for i = 0, 2 do
  print(array[i])
end

-- Итерация с помощью ipairs
for key, value in ipairs(array) do
  print(key, value)
end
```

![](_png/Pasted%20image%2020240908132100.png)

### Ветвления

Операции ветвления в lua представлены следующим образом:
- старт условия - `if`
- вставка дополнительного условия - `elseif`
- иначе - `else`
- `||` и `&&` выглядят как `and` и `or`

```lua
local a = 20

if a < 20 then
	print("a is less then 30")
elseif a > 20 and a < 30 then
	print("a is between 20 and 30")
else
	print("a is more then 30")
end
```

### Функции

Функция — это изолированный кусочек кода.

- Их можно вызывать в различных частях приложения.
- Функции имеют наименование, аргументы и могут возвращать значение.

```lua
function max(num1, num2)
	if num1 > num2 then
		return num1
	else
		return num2
	end
end

local res = max(5, 7)

-- 7
print(res)
```

### Tables

Таблица в lua представляет из себя то же самое, что и объект в JS. Она хранит набор различных значений 

Ключи мы можем записывать под индексами, под строчными записями, записывать через dot notation и обращаться ко всем записанным значениям таким же образом.

```lua
table = {}
table[0] = "test"
table["a"] = "avalue"
table.b = "bvalue"

table2 = {
	c = "cvalue"
}

table3 = {
	d = {
		e = "evalue"
	}
}

print(table3.d.e)
```

### Модули

Модули - это удобный инструмент декомпозиции кода по разным файлам. Они нам предоставляют:

- Декомпозицию код на отдельные файлы
- Изоляцию кода для последующего переиспользования
- Повышение читабельности приложения

Создаём таблицу с нужными данными и для неё создаём функцию. Чтобы таблица не попадала в глобальный скоуп, создадим её локальной (чтобы она реально оставалась только внутри своего файла).
Саму таблицу мы экспортируем из файла через `return`.

`lib/mymath.lua`
```lua
local mymath = {}

function mymath.add(a, b)
	print(a + b)
end

return mymath
```

И далее через `require` и абсолютный путь до файла мы можем получить наш экспортированный модуль

`demo.lua`
```lua
mymathmodule = require("lib/mymath")
mymathmodule.add(1, 3)
```

## Конфигурация

### Путь конфигурации

#### 1. Расположение конфигурационного файла

- **Платформозависимость:**
    - **Windows**: конфигурация может иметь другое местоположение.
    - **Mac и Linux**: конфигурация может находиться в папке config.
- **Несколько конфигураций:**
    - Можно иметь несколько конфигураций для одной машины.

#### 2. Поиск пути конфигурации

- **Команда для поиска пути:**
    - Используйте команду `echo $XDG_CONFIG_HOME/nvim` для вывода пути.
- **Пример пути:**
    - Обычно конфигурация располагается в `~/.config/nvim`.

#### 3. Инициализация конфигурационного файла

- **Создание папки:**
    - Если нужно, создайте папку командой `mkdir -p ~/.config/nvim`.
- **Создание файла:**
    - Создайте файл `init.lua` в директории: `~/.config/nvim`.

#### 4. Проверка конфигурации

- **Тестирование:**
    - Напишите в файле `init.lua` команду `print("Привет")`.
    - Сохраните и закройте файл.
    - Откройте `nvim` и проверьте вывод: если видите "Привет", значит, всё работает корректно.

#### 5. Обработка конфигурационного файла

- **Что происходит при старте:**
    - Neovim при запуске ищет файл `init.lua` в своем конфигурационном пути.
    - Если файл найден, его содержимое выполняется.
- **Точка входа:**
    - `init.lua` служит точкой входа для всей конфигурации.
    - Этот файл можно использовать для импорта модулей, настройки плагинов и др.



### Структура конфигурации

#### 1. Введение

- Обсудим структуру конфигурации приложения.
- Структура может различаться у разных команд, но предложенный подход удобен для поддержки.

#### 2. Разделение кода

- Конфигурация будет разделена на две части:
    - **core**: ключевые вещи (цвета, маппинги, конфигурации).
    - **plugins**: отдельные файлы для каждого плагина.

#### 3. Структура папок

- Папка `init.lua` создается с подкаталогом для конфигураций.
- Структура папок:
    - `init.lua`
    - `lua`
        - `core`
        - `plugins`

#### 4. Создание папок

- В терминале командой `mkdir lua/core lua/plugins` создаем необходимые каталоги.

#### 5. Первичный тест конфигурации

- Создаем файл `configs.lua` в папке `core`.
    - Команда: `nvim lua/core/configs.lua`
    - Записываем строку `"configs"` и сохраняем.

#### 6. Импорт конфигурации

- Открываем файл `init.lua` и добавляем импорт:
    - Комментарий `-- Basic config`.
    - Команда `require('core.configs')`.
- Сохраняем изменения.

#### 7. Проверка работы конфигурации

- Запускаем `nvim` из корневой папки и проверяем, что конфигурация работает.
- Повторяем проверку, находясь вне корневой папки, чтобы убедиться, что работа корректна независимо от местоположения.



### Базовые настройки

#### 1. Изменение глобальной таблицы конфигурации nvim

- Редактирование файла `configs.lua`.
- Глобальная табличка конфигурации nvim.

#### 2. Включение номеров строк

- Дополнение конфигурации: vim.wo.number = true vim.wo.relativenumber = true
- Сохранение и перезапуск для активации изменений.

#### 3. Поддержка мыши

- Включение и настройка мыши: vim.opt.mouse = "a" vim.opt.mousefocus = true

#### 4. Настройка системного клейборда

- Настройка дефолтного клейборда: vim.opt.clipboard = "unnamedplus"

#### 5. Настройки отступов

- Создание блока для отступов: vim.opt.shiftwidth = 4 vim.opt.tabstop = 4 vim.opt.softtabstop = 4

#### 6. Другие опции

- Скорректируем скролл: vim.opt.scrolloff = 8 vim.opt.wrap = false vim.opt.termguicolors = true



### Сочетания клавиш

#### 1. Создание Файла для Настроек

1. **Создать файл** `mappings.lo` внутри директории `Core` для описания сочетаний клавиш.

#### 2. Понимание Клавиши Leader

1. **Клавиша Leader** — префикс для команд (обычно backslash `\`).
2. **Рекомендуется** использовать пробел как Leader, так как он не используется в нормальном режиме.

#### 3. Настройка Клавиши Leader

1. **Сделать комментарий** `Leader` и изменить конфиг: `vim — глобальные параметры — map Leader = пробел`
2. **Обновить файл** `init.lua`: `добавить mappings`
3. **В файле** `/lua/core/mappings` внести измененные настройки.

#### 4. Примеры Сочетания Клавиш

##### Быстрое Сохранение Файла

1. Настроить буфер для сохранения файла по `Leader + w`: `lua vim.keyMap.set('n', '<leader>w', ':w<CR>')`
2. **Проверить**: Модифицировать файл и нажать `<leader>w`.

##### Выход из Инсерт Режима

1. Настроить выход с помощью `jj` в режиме Insert: `lua vim.keyMap.set('i', 'jj', '<ESC>')`
2. **Проверить**: Войти в инсерт режим, нажать `jj`.



### Split окон


#### Введение

- В реальной работе часто нужно одно­временно открывать несколько файлов или буферов.
- В Vim это реализуется через сплиты (разделенные окна), в отличие от вкладок в классических блокнотах.

#### Открытие Сплит-Окон

- Команда: `:split` (или коротко `:sp`) — разде­лит экран горизонтально.
- Перемещение между окнами: `Ctrl-W`
    - `J` (вниз), `K` (вверх), `H` (влево), `L` (вправо).

#### Виды Сплитов

- **Горизонтальный сплит**: `:split`
- **Вертикальный сплит**: `:vsplit` (или коротко `:vsp`)

#### Примеры использования

- Открытие буферов в разных сплитах, можно использовать для редактирования разных файлов одновременно.
- Например: `:e file1.txt :vsplit file2.txt :split file3.txt`

#### Закрытие Сплит-Окон

- Команда: `:q` (или просто `:wq`, если нужно сохранить изменения).

#### Упрощение навигации между сплитами

- Можно настроить перемещение через одни клавиши: `Ctrl-H`, `Ctrl-J`, `Ctrl-K`, `Ctrl-L`.


### Менеджер плагинов

#### 1. Введение

- **Цель**: Превратить NeoVim в полноценную IDE.
- **Необходимость**: Использование плагинов.
- **Инструмент**: Плагин-менеджер LazyNvim.

#### 2. Установка LazyNvim

- **Шаг 1**: Переход на сайт LazyNvim.
- **Шаг 2**: Создание файла конфигурации `lazy.lua` в папке `core`.
- **Шаг 3**: Копирование конфигурационного кода в `core/lazy.lua`.

#### 3. Настройка Bootstrap

- **Суть**: Проверка и клонирование Lazy с помощью Git.
- **Требование**: Установленный Git версии 2.8 и выше.

#### 4. Дополнительная конфигурация

- **Лидер-ключ**: Предварительно настроен.
- **Цветовая схема**: Установка и настройка.
- **Проверки обновлений**: Настройка автоматических проверок.

#### 5. Импорт плагинов

- **Структура**: Настройка плагинов в папке `lua/plugins`.
- **Инициализация**: Основной файл `init.lua` импортирует Lazy.

#### 6. Установка первого плагина

- **Пример**: Плагин `git-science` для отображения изменений в коде.
- **Процесс**:
    - Создание файла в папке `plugins`.
    - Описание параметров плагина (имя, конфигурация).

#### 7. Завершение установки

- **Инициализация плагина**: С помощью функции `require('...').setup()`.
- **Запуск NeoVim**: Проверка установки плагина.

#### 8. Интерфейс LazyNvim

- **Команда**: `:Lazy` для просмотра установленных плагинов.
- **Возможности**:
    - Управление (установка, обновление, синхронизация).
    - Дебаг плагинов.



### Тема












## Плагины UI

### Neotree
### Bufferline
### Lualine
### Telescope
### Доработка цветов
### Терминал








## Плагины для разработки

### Cmp
### LSP
### Mason
### Ensure install
### Стилизация
### Treesitter
### Быстрый переход
### Dressing
### Trouble
### Formatting
### Linting








## Продвинутая работа

### Версионирование
### Git плагины
### Leap
### Which key
### Несколько сборок NVim


```bash
alias nv="NVIM_APPNAME=nv nvim"

function nvims() {
  items=("default" "nv" "lazy")
  config=$(printf "%s\n" "${items[@]}" | fzf --prompt=" Neovim Config  " --height=~50% --layout=reverse --border --exit-0)
  if [[ -z $config ]]; then
    echo "Nothing selected"
    return 0
  elif [[ $config == "default" ]]; then
    config=""
  fi
  NVIM_APPNAME=$config nvim $@
}
```

### Dashboard
















