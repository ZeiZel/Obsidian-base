#nvim #neovim #console #IDE

>[!summary] Писать в виме - это как использовать определённый язык программирования. Мы общаемся с Вимом, используя определённый синтаксис. `d2w` может расшировываться, как `delete 2 words`, что является понятным путём для редактирования текста. Каждое сочетание в виме переводится определённым полноценным словом, которое описывает действие клавиши. 

## Введение

Vim - это консольный редактор

Его можно как запустить удалённом сервере и уже поднять внутри него свою конфигурацию, так и просто импортировать конфигурацию удобно и быстро на любой другой компьютер 

![](_png/Pasted%20image%2020240901115145.png)

Стоит различать, что vim-motions и vim-редактор - это две разные сущности, которые можно отделить друг от друга. Те же моушены можно использовать в любой IDE или редакторе через плагины, потому что это целый подход к работе с текстом.

![](_png/Pasted%20image%2020240901115203.png)

## Настройка окружения

### Vim или NVim

Vim:
- присутствует из коробки во многих системах
- у него только один простой конфигурационный файл

NeoVim:
- Конфигурируется на lua, который проще vimscript и предоставляет возможность разнести разные группы по разным файлам 
- Является многопоточным и ускоренным за счёт libuv
- Имеет больше плагинов
- Имеет широкую базу различных удобных сборок

![](_png/Pasted%20image%2020240901123734.png)

### Выбор терминала

Самый универсальный вариант - Alacritty. Он работает под любой ОС.

![](_png/Pasted%20image%2020240901125018.png)

### Настройка терминала

По пути нам нужно будет создать конфиг для alacritty

`~/.config/alacritty/alacritty.toml`
```bash
[env]
TERM = "xterm-256color"

[font]
size = 13.0

[font.normal]
family = "JetBrainsMono Nerd Font"
style = "Regular"

[window]
decorations = "Buttonless"
opacity = 0.92
blur = true

[window.padding]
x = 0
y = 0

[selection]
save_to_clipboard = true
```

Далее устанавливаем zsh на нашу систему, если не установлен и указываем в качестве дефолтного терминала

```bash
sudo apt install zsh
chsh -s $(which zsh)
```

Далее нужно добавить данный конфиг для zsh

`~/.zshrc`
```bash
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi


# Path to your oh-my-zsh installation.
export ZSH="$HOME/.oh-my-zsh"
export KUBECONFIG=/Users/alaricode/.kube/purple-cluster_kubeconfig.yaml
export NVM_DIR="$HOME/.nvm"
  [ -s "/usr/local/opt/nvm/nvm.sh" ] && \. "/usr/local/opt/nvm/nvm.sh"  # This loads nvm
  [ -s "/usr/local/opt/nvm/etc/bash_completion.d/nvm" ] && \. "/usr/local/opt/nvm/etc/bash_completion.d/nvm"
ZSH_THEME="powerlevel10k/powerlevel10k"

plugins=(git z docker fzf thefuck zsh-autosuggestions history)

source $ZSH/oh-my-zsh.sh

if [ -f '/Users/alaricode/vk-cloud-solutions/path.bash.inc' ]; then source '/Users/alaricode/vk-cloud-solutions/path.bash.inc'; fi

# bun completions
[ -s "/Users/alaricode/.bun/_bun" ] && source "/Users/alaricode/.bun/_bun"
alias ls="eza --tree --level=1 --icons=always --no-time --no-user --no-permissions"

export PATH="/usr/local/opt/openjdk/bin:$PATH"
export PATH="/Users/alaricode/.cargo/bin"
export PATH=/bin:/usr/bin:/usr/local/bin:/sbin:${PATH}
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"

eval "$(fzf --zsh)"
function yy() {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
	yazi "$@" --cwd-file="$tmp"
	if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
		cd -- "$cwd"
	fi
	rm -f -- "$tmp"
}

function htt() {
  httpyac $1 --json -a | jq -r ".requests[0].response.body" | jq | bat --language=json
}

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh
```

И склонировать репозитории с плагинами `git z docker fzf thefuck zsh-autosuggestions history` (строчка `plugins = (...)`) в папку `~/.oh-my-zsh/custom/plugins`

```
https://github.com/nvbn/thefuck?tab=readme-ov-file#installation
https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#homebrew
https://github.com/agkozak/zsh-z
https://github.com/unixorn/fzf-zsh-plugin?tab=readme-ov-file#oh-my-zsh

https://github.com/romkatv/powerlevel10k?tab=readme-ov-file#oh-my-zsh
```

Далее устанавливаем [brew](https://brew.sh/)

````
brew install eza
````

### Установка NVim

```bash
sudo [apt install | dnf install | pacman -S] neovim
brew install neovim
```

### Создание первого файла

Так же мы можем создать новый файл через вим, передав имя и расширение файла. Если такой файл в папке уже существует, то вим просто откроет его.

```bash
nvim [название файла]
```

Для ввода данных, нужно будет перейти в режим ввода `i`

![](_png/Pasted%20image%2020240904190417.png)

Изначально файл создастся в нашем буфере и потом, когда мы запустим команду `:w`, он запишется к нам на диск

![](_png/Pasted%20image%2020240904190450.png)

Если мы уже вошли в вим, но не открыли файл, то это сделать мы можем через команду `:edit` куда передадим имя целевого файла

![](_png/Pasted%20image%2020240904190513.png)

## Базовые motion

### Режимы

>[!danger] NVim не воспринимает русскую раскладку во время работы с коммандами! Нужно перключаться на английскую.

Сама работа в симе поделена на несколько режимов, которые определяют доступный пул действий, которые мы можем выполнять в редакторе.

В Vim существует 5 режимов:
- *normal* - просмотр кода. Это основной режим для навигации, который является стандартным и используется для перемещения по файлу.
- *insert* - вставка. Позволяет вводить текст.
	- `i` - войдёт в режим вставки перед текущей позицией курсора.
	- `I` - войдёт в режим вставки в начале строки.
	- `a` - войдёт в режим вставки после текущей позиции курсора.
	- `A` - войдёт в режим вставки в конце строки.
	- `o` - создаст новую строку ниже текущей и войдите в режим вставки.
	- `O` - создаст новую строку выше текущей и войдёт в режим вставки.
	- `r` - заменит текущий символ (без перехода в режим вставки).
	- `R` - войдёт в режим замены, где можно будет заменять символы непосредственно.
- *visual* - выделение кода
	- `v` - войдёт в режим визуального выделения для выделения текста.
	- `V` - войдёт в режим визуального выделения для выделения строк.
	- `Ctrl + v` - войдёт в режим блочного выделения для выделения прямоугольных областей текста.
- *replace* - ввод с перезаписью существующего текста.
- *command* - позволяет работать с коммандами vim
	- `:` - вызывает режим команд

![](_png/Pasted%20image%2020240904190709.png)

### Базовые перемещения

#### Базовые движения

Для базовых перемещений по коду:
- `j/k` - вверх-вниз
- `h/l` - влево-вправо

#### Горизонтальные перемещения:

- `0` - перемещает в начало строки
- `$` - перемещает в конец строки
- `w/b` - переход вперёд/назад по словам с учётом пробелов
- `W/B` - переход по словам без учёта пробелов (помогает, если перемещаемся по большому количеству спецсимволов `<title>Слова внутри тега</title>`)
- `e` - переходит в конец текщего слова
- `E` - игнорирует символы, кроме пробела, перемещаясь к концу слова.

#### Вертикальные перемещения:

- `число + G` - перемещение на определённую строку (перейдёт на выбранную по числу строку)
- `число + jk` - перемещение вверх/вниз на определённое число строк
- `gg` - перемещение в начало файла
- `G` - перемещение в конец файла

### Как практиковаться

Даже если пока не получается сидеть в виме, можно установить плагин для работы с Vim Motions в любом редакторе

![](_png/Pasted%20image%2020240907135304.png)

### Комбинации движений

Комбинации - это последовательность действий. которые мы можем выполнить за счёт объединения сочетаний в виме

Operator - это действие, которое нужно выполнить над текстом
Count - это количество Motion (так же есть альтернатива в виде указания места)
Motion - это действие передвижения, в рамках которой будет выполнен оператор

![](_png/Pasted%20image%2020240904191102.png)

`d3w` удалит 3 слова (aka *delete 3 words*)

![](_png/Pasted%20image%2020240908095804.png)

`d3j` удалит уже 3 строки вниз

![](_png/Pasted%20image%2020240908100123.png)

`di(` - удалит текст внутри скобок

![](_png/Pasted%20image%2020240908100347.png)

Все те движения, что мы совершаем в виме - мы можем откатить. Если нам нужно будет откатиться на прошлое движение, то мы можем воспользоваться `ctrl + o`. Может это быть полезно, например, если мы зашли внутрь типа и нам нужно быстро вернуться обратно либо в случае, когда мы перешли не в ту часть файла. 

### Продвинутое перемещние

`$` - переход в начало строки
`0` - переход в начало строки
`gg` - переход в начало файла
`G` - переход в конец файла

`:set nu` вызовет номера строк

![](_png/Pasted%20image%2020240908101512.png)

`:set relativenumber` вызовет относительные номера строк, которые позволят нам не считать количество строк, на которое мы можем переместиться, например, той же командой `5j`

![](_png/Pasted%20image%2020240908101714.png)

`f` ищет определённую букву в строке вперёд, а `shift+f` ищёт назад

`f` + `o` - найдёт первую найденную букву `o` в строке
`2fo` - перейдёт сразу ко второй названной `o` в строке

![](_png/Pasted%20image%2020240908102400.png)

Если нужно продолжать передвигаться дальше по найденной букве, то мы нажимаем `;`

![](_png/9265fdd14432504666790112c4bc5dcd.png)

### Перемещение по блокам

`{` / `}` - позволяют перемещаться между разрывами строк

![](_png/Pasted%20image%2020240908104202.png)

`%` - позволяет нам передвигаться между открывающей и закрывающей скобками (любыми)

![](_png/Pasted%20image%2020240908104715.png)

![](_png/8cc92ac09ccb25ccbb38d65b924d84db.png)

![](_png/Pasted%20image%2020240908104926.png)

`[` / `]` + определённый тип скобки - позволит переместиться к ближайшей скобке

`[}` переместит изнутри блока к ближайшей фигурной скобке. А уже комбинация `]}` сделает то же самое, но к закрывающей скобке. Так же это работает и с любыми другими скобками.

![](_png/Pasted%20image%2020240908105220.png)

`ctrl + d` / `ctrl + u` - перемещение на страницу вниз/вверх

`_` - позволит нам перейти к первому символу строки. В отличе от `0`, который переносит нас в целом в начало строки (даже включая табы).

![](_png/Pasted%20image%2020240908105705.png)

`-` / `+` уже будут переводить к началу/концу следующей строки

![](_png/Pasted%20image%2020240908105835.png)

### Файлы и buffers

Как уже и упоминалось ранее, vim работает с буфферами - он загружает файл в ОЗУ и редактирует его в нём.

Открыть файл мы можем через команду `:edit <file>`

Открыть директорию с файлами мы можем через `:edit .`. Тут у нас появится напрямую файловый менеджер из вима. Все команды указаны сверху и, например, `R` позволит переименовать файл.

![](_png/Pasted%20image%2020240908113245.png)

Команда `:buffers` позволит выписать список буфферов. В первом столбце идёт идентификатор буффера. Для перехода в определённый буффер, мы можем воспользоваться `:buffer <id_буфера>` для перехода в нужный 

`:bnext` / `:bprevious` позволят переместиться к следующему/предыдущему буферу

![](_png/Pasted%20image%2020240908113531.png)

`:buffer {` позволяет перейти в доку и узнать, что делает определённое сочетание на случай того, если мы забыли, что делает определённая команда 

![](_png/Pasted%20image%2020240908113809.png)

## Удаление и копирование

### Удаление текста

За удаление отвечает операцтор `d`. Он включает операцию удаления, которая позволит по моушену удалить нужный нам участок текста.

![](_png/Pasted%20image%2020240904191149.png)

Чтобы откатить изменения вместо `ctrl + z` в Vim работает `u`. Сам же вим хранит все изменения, которые мы совершали в файле, поэтому можно откатываться даже до тех изменений, которые были до входа в файл
Чтобы вернуть отменённые изменения, нам нужно использовать `ctrl + r`

#### Основные комбинации

- **d**: удаляет текст и остается в нормальном режиме.
- **c**: удаляет текст и переходит в режим Insert.

#### Работа с операторами и motion

- **dw**: удалить слово.
- **dd**: удалить строку.
- **db**: удалить назад до начала слова.
- **de**: удалить до конца слова.

#### Примеры комбинирования

- **d2w**: удалить два слова.
- **d$**: удалить до конца строки.
- **d10j**: удалить 10 строк вниз.

#### Переходы в режим Insert

- **cw**: удалить слово и сразу перейти в режим Insert.
- **cb**: удалить назад до начала слова и перейти в режим Insert.

#### Упрощенные операции удаления

- Используемые команды для удаления могут быть комбинированы с count (числом удаляемых объектов) и motion (движением курсора), что позволяет эффективно удалять большие участки текста.

### inside и around

Так же вместо *Count* мы можем использовать специальные операторы, которые будут выполнять действия в рамках определённых границ либо только за ними

- `d` – удалить
- `i (inside)` – внутри границ
- `a (around)` – вокруг границ
- `t` – тег

![](_png/Pasted%20image%2020240904191216.png)

Например, мандой `div` мы можем выполнить действие внутри слова и удалить его целиком

`di"` удалит слово внутри кавычек `"example"` -> `""`

Команда `dit` удалит всё внутри тегов: `<title>Школа разработки</title>` → `<title></title>`

`di{` удалит всё внутри фигурных кавычек

Мы можем вместо удаления скорректировать текст с помощью `ci(` для круглых скобок с последующим вводом нового значения

### Копирование и вставка






### Регистры









## Преобразование текста

### Замена текста
### Поиск по буферу
### Замена в файле








## Visual mode и макросы

### Visual Mode
### Изменение регистра
### V-Line Mode
### V-Block Mode
### Макросы







## Основы lua

### Установка

Установить lua достаточно легко можно через brew

```bash
brew inatall lua
```

Далее нам нужно будет создать файл с небольшим примером кода на lua

`demo.lua`
```lua
print("Привет!")
```

Далее нам нужно запустить терминал. Сделать это можно так же прямо в виме через команду `:terminal`. Начать писать можно через переход в режим *terminal* через `i`

И запускаем файл

```bash
lua demo.lua
```

![](_png/Pasted%20image%2020240908124724.png)

Из терминала можно выключить через стандартный `exit`

### Переменные

Переменные в lua делятся на локальные и глобальные.
Создать локальную переменную можно с помощью конструкции `local`.

Основные типы: числа, строки, булевы значения, таблицы, массивы (таблицы с числовыми индексами), nil

Конкатенация строк происходит через `..`
Вывести текст через `print()`
Вывести тип можно через `type()`

```lua
local a = 50
local b
b = 30
c = 80

local greeting = "Привет"
local excl = "!"

local isAdmin = true

-- Привет!
print(greeting..excl)
-- boolean
print(type(isAdmin))
-- 80 80
print(a + b, c)
```

### Циклы

Массивы в lua - это таблицы (объекты), ключами которых являются числовые значения. Значения индексов идут с 1, а не с 0.

Перебор по собственным нашим индексам, которые мы добавим в таблицу можно совершить через `for-i`. А пройти целиковый массив можно через `for-in`.

```lua
local array = {"london", "moscow"}
array[0] = "paris"
array[-1] = "denver"

-- Цикл for с числовыми индексами
for i = 0, 2 do
  print(array[i])
end

-- Итерация с помощью ipairs
for key, value in ipairs(array) do
  print(key, value)
end
```

![](_png/Pasted%20image%2020240908132100.png)

### Ветвления

Операции ветвления в lua представлены следующим образом:
- старт условия - `if`
- вставка дополнительного условия - `elseif`
- иначе - `else`
- `||` и `&&` выглядят как `and` и `or`

```lua
local a = 20

if a < 20 then
	print("a is less then 30")
elseif a > 20 and a < 30 then
	print("a is between 20 and 30")
else
	print("a is more then 30")
end
```

### Функции

Функция — это изолированный кусочек кода.

- Их можно вызывать в различных частях приложения.
- Функции имеют наименование, аргументы и могут возвращать значение.

```lua
function max(num1, num2)
	if num1 > num2 then
		return num1
	else
		return num2
	end
end

local res = max(5, 7)

-- 7
print(res)
```

### Tables

Таблица в lua представляет из себя то же самое, что и объект в JS. Она хранит набор различных значений 

Ключи мы можем записывать под индексами, под строчными записями, записывать через dot notation и обращаться ко всем записанным значениям таким же образом.

```lua
table = {}
table[0] = "test"
table["a"] = "avalue"
table.b = "bvalue"

table2 = {
	c = "cvalue"
}

table3 = {
	d = {
		e = "evalue"
	}
}

print(table3.d.e)
```

### Модули

Модули - это удобный инструмент декомпозиции кода по разным файлам. Они нам предоставляют:

- Декомпозицию код на отдельные файлы
- Изоляцию кода для последующего переиспользования
- Повышение читабельности приложения

Создаём таблицу с нужными данными и для неё создаём функцию. Чтобы таблица не попадала в глобальный скоуп, создадим её локальной (чтобы она реально оставалась только внутри своего файла).
Саму таблицу мы экспортируем из файла через `return`.

`lib/mymath.lua`
```lua
local mymath = {}

function mymath.add(a, b)
	print(a + b)
end

return mymath
```

И далее через `require` и абсолютный путь до файла мы можем получить наш экспортированный модуль

`demo.lua`
```lua
mymathmodule = require("lib/mymath")
mymathmodule.add(1, 3)
```

## Конфигурация

### Путь конфигурации
### Структура конфигурации
### Базовые настройки
### Сочетания клавиш
### Split окон
### Менеджер плагинов
### Тема







## Плагины UI

### Neotree
### Bufferline
### Lualine
### Telescope
### Доработка цветов
### Терминал








## Плагины для разработки

### Cmp
### LSP
### Mason
### Ensure install
### Стилизация
### Treesitter
### Быстрый переход
### Dressing
### Trouble
### Formatting
### Linting








## Продвинутая работа

### Версионирование
### Git плагины
### Leap
### Which key
### Несколько сборок NVim
### Dashboard
















