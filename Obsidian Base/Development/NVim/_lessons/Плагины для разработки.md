---
tags:
  - nvim
  - DevNvim
description: Глава посвящена установке плагинов для разработки приложений
---

### Cmp

Мы не можем обойтись во время разработки без автокомплитов, которые может предложить нам полноценная IDE. Покрыть эту реализацию поможет нам плагин [Cmp](https://github.com/hrsh7th/nvim-cmp)

Конфиг будет включать в себя сразу несколько различных пакетов:

`lua / plugins / cmp.lua`
```lua
return {
	{ "hrsh7th/cmp-nvim-lsp" },
	{ "hrsh7th/cmp-buffer" },
	{ "hrsh7th/cmp-path" },
	{ "hrsh7th/cmp-cmdline" },
	{
		"hrsh7th/nvim-cmp",
		config = function()
			local cmp = require("cmp")
			cmp.setup({
				snippet = {
					expand = function(args)
						vim.fn["vsnip#anonymous"](args.body) -- For `vsnip` users.
						-- require('luasnip').lsp_expand(args.body) -- For `luasnip` users.
						-- require('snippy').expand_snippet(args.body) -- For `snippy` users.
						-- vim.fn["UltiSnips#Anon"](args.body) -- For `ultisnips` users.
						-- vim.snippet.expand(args.body) -- For native neovim snippets (Neovim v0.10+)
					end,
				},
				window = {
					-- completion = cmp.config.window.bordered(),
					-- documentation = cmp.config.window.bordered(),
				},
				mapping = cmp.mapping.preset.insert({
					["<C-b>"] = cmp.mapping.scroll_docs(-4),
					["<C-f>"] = cmp.mapping.scroll_docs(4),
					["<C-Space>"] = cmp.mapping.complete(),
					["<C-e>"] = cmp.mapping.abort(),
					["<CR>"] = cmp.mapping.confirm({ select = true }), -- Accept currently selected item. Set `select` to `false` to only confirm explicitly selected items.
					-- конфигурация маппинга по доступным словам по табу
					["<Tab>"] = cmp.mapping(function(fallback)
						if cmp.visible() then
							cmp.select_next_item()
						else
							fallback()
						end
					end, { "i", "s" }),
					["<S-Tab>"] = cmp.mapping(function(fallback)
						if cmp.visible() then
							cmp.select_prev_item()
						else
							fallback()
						end
					end, { "i", "s" }),
				}),
				sources = cmp.config.sources({
					{ name = "nvim_lsp" },
					{ name = "vsnip" }, -- For vsnip users.
					-- { name = 'luasnip' }, -- For luasnip users.
					-- { name = 'ultisnips' }, -- For ultisnips users.
					-- { name = 'snippy' }, -- For snippy users.
				}, {
					{ name = "buffer" },
				}),
			})
		end,
	},
}
```

Но пока этот плагин не будет нормально работать, так как у нас не установлены LSP, которые и отвечают за поддержку различных языков

В итоге наш автокомплит будет предлагать нам завершение строк в зависимости от контекста его вызова и доступных вариантов.

![](_png/Pasted%20image%2020240922102248.png)

### LSP + Быстрые переходы

И сейчас для полноценной поддержки наших ЯПов в разработке, нам понадобится подключить Lsp

LSP - это language server protocol, который представляет из себя иснтрумент для взаимодействия с языком (проверка, подсказки и так далее)

Для подключения большого количества различных lsp, мы можем воспользоваться [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)

![](_png/Pasted%20image%2020240923174040.png)

Тут мы добавили базовые LSP для TS, GO и Lua, а так же клавиши быстрых переходов по коду:

- `gd` - пройти к определению

![](_png/Pasted%20image%2020240923190929.png)

- `K` - сигнатура функции (какие аргументы она принимает)

![](_png/Pasted%20image%2020240923190749.png)

- `ctrl + k` - помощь сигнатуры

![](_png/Pasted%20image%2020240923191102.png)

- `gi` - имплементация

Тут осуществился переход к компоненту из прошлого скрина

![](_png/Pasted%20image%2020240923191127.png)

- `leader` + `D` - переход к определнию типа
- `leader` + `lr` - переименовывает объект
- `leader` + `la` - выводит быстрое действие, которое можно выполнить

![](_png/Pasted%20image%2020240923191711.png)

- `leader` + `lf` - форматирование кода

![](_png/Pasted%20image%2020240923191822.png)

`lua / plugins / lsp.lua`
```lua
return {
	{
		"neovim/nvim-lspconfig",
		config = function()
			local lspconfig = require("lspconfig")
			lspconfig.lua_ls.setup({})
			lspconfig.gopls.setup({})
			lspconfig.ts_ls.setup({})

			-- Быстрые переходы
			vim.api.nvim_create_autocmd("LspAttach", {
				group = vim.api.nvim_create_augroup("UserLspConfig", {}),
				callback = function(ev)
					vim.bo[ev.buf].omnifunc = "v:lua.vim.lsp.omnifunc"

					local opts = { buffer = ev.buf }
					vim.keymap.set("n", "gd", vim.lsp.buf.definition, opts)
					vim.keymap.set("n", "K", vim.lsp.buf.hover, opts)
					vim.keymap.set("n", "gi", vim.lsp.buf.implementation, opts)
					vim.keymap.set("n", "<C-k>", vim.lsp.buf.signature_help, opts)
					vim.keymap.set("n", "<Leader>D", vim.lsp.buf.type_definition, opts)
					vim.keymap.set("n", "<Leader>lr", vim.lsp.buf.rename, { buffer = ev.buf, desc = "Rename Symbol" })
					vim.keymap.set({ "n", "v" }, "<Leader>la", vim.lsp.buf.code_action, opts)
					vim.keymap.set("n", "<Leader>lf", function()
						vim.lsp.buf.format({ async = true })
					end, opts)
				end,
			})
		end,
	},
}
```

Ну и так же нам нужно установить языковые сервера, чтобы протоклы могли с ними общаться

```bash
brew install go
npm install -g typescript typescript-language-server
```

**Либо** мы можем установить Mason, который упростит установку языковых серверов

### Mason + Ensure install

Далее нам понадобится пакетный менеджер [Mason](https://github.com/williamboman/mason.nvim), который пзволит нам устанавливать языковые-сервера и связанные с разработкой пакеты в NeoVim

- Первым объектом мы установим сам Mason
- а дальше пакет автоматической установки LSP после установки самого Mason

`lua / plugins / mason.lua`
```lua
return {
	{
		"williamboman/mason.nvim",
		config = function()
			require('mason').setup()
		end
	},
	-- Ensure install
	{
		'williamboman/mason-lspconfig.nvim',
		config = function()
			require("mason-lspconfig").setup(
			{
				ensure_installed = { "lua_ls", "rust_analyzer", "gopls" }
			})
		end
	}
}
```

Командой `:Mason` мы вызываем окно, в котором сами ищем и через `i` запускаем установку интересующего нас сервера

Так же он сам за нас добавляет сервер в `$PATH`

![](_png/Pasted%20image%2020240923180429.png)

И теперь у нас на данном этапе появляется автокомплит

![](_png/Pasted%20image%2020240923180624.png)

### Treesitter

Теперь нам понадобится плагин для того, чтобы подсвечивать синтаксис [Treesitter](https://github.com/nvim-treesitter/nvim-treesitter)

`lua / plugins / treesitter.lua`
```lua
return {
	{
		'nvim-treesitter/nvim-treesitter',
		config = function()
			require('nvim-treesitter.configs').setup({
				ensure_installed = { "go", "rust", "lua", "typescript", "javascript", "c", "vim", "vimdoc", "markdown", "markdown_inline" },
				auto_install = true,
				highlight = {
					enable = true,
				}
			})
		end
	}
}
```

В итоге мы из обычной белой подсветки получим полноценную подсветку функций, методов, классов и других конструкций языков

![](_png/Pasted%20image%2020240923183124.png)

### Dressing

Далее было бы удобно открывать быстрые действия с помощью [Dressing](https://github.com/stevearc/dressing.nvim), которые предоставляет нам LSP в отдельном маленьком попапчике, который будет более удобным отображением, чем окошко в районе поля команд

`lua / plugins / dressing.lua`
```lua
return {
	{
		'stevearc/dressing.nvim',
		config = function()
			require('dressing').setup({
				input = {
					win_options = {
						winhighlight = 'Normal:CmpPmenu,FloatBorder:CmpPmenuBorder,CursorLine:PmenuSel,Search:None',
					},
				}
			})
		end
	}
}
```

Теперь под каждое действие, которое мы добавили через LSP, у нас открываются попапчики

![](_png/Pasted%20image%2020240923192513.png)

![](_png/Pasted%20image%2020240923192354.png)

### Trouble

Так же нам очень понадобится плагин, который отобразит более подробно ошибку, которая произошла в коде и в этом нам поможет [Trouble](https://github.com/folke/trouble.nvim)










### Formatting












### Linting











