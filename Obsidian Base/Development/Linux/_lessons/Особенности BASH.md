
## Архивы

`du` позволяет вывести размер файла или каталога. `-sk` выведет размер файла в килобайхтах, а `-sh` выведет в удобочитаемом формате.

`ls -lh` так же выведет размеры файлов

![](_png/Pasted%20image%2020240803183335.png)

`tar` архивирует файлы

- `-c` - используется для архивации файлов
- `-f` - используется для указания имени результирующего файла с архивом

![](_png/Pasted%20image%2020240803183828.png)

Чтобы просмотреть внутренности архива, можно воспользоваться `-tf`

Чтобы разархивировать файл, нужно воспользоваться `-xf`

Чтобы сжать архив, нужно воспользоваться опцией `-zcf` (сжатие в `gz` формате) и на выходе мы получим файл `.tar.gz`

![](_png/Pasted%20image%2020240803184013.png)

Есть несколько методов сжатия и разжатия файла и все они имеют разные алгоритмы, но чем более сжатый файл, тем дольше он будет распаковываться.

Команды для `запаковки` - `распаковки` файлов:

`bzip2` - `bunzip2`
`gzip` - `zunzip`
`xz` - `unxz`

![](_png/Pasted%20image%2020240803184227.png)

Ну и так же команды `zcat` `bzcat` `xzcat` позволяют просмотреть содержимое файлов без распаковки

![](_png/Pasted%20image%2020240803184601.png)

## Поиск файлов и директорий

### поиск по директориям

Чтобы найти определённый файл в системе с помощью консоли, мы можем воспользоваться несколькими способами

`locate` - отображает пути до определённого искомого файла в системе. Ищет по файлу `mlocate.db`, в котором описаны все файлы в системе. Само собой этот файл нужно иногда обновлять, потому что новые пути туда записываются не сразу. Можно это сделать самостоятельно с помощью `updatedb`.

Так же можно воспользоваться командой `find`, которая найдёт вхождения в определённом каталоге.

![](_png/Pasted%20image%2020240803193933.png)

### поиск по файлам

Если нам требуется вывести содержание файла целиком, то мы можем воспользоваться `cat`

Команда `grep` позволяет искать определённые строки по паттерну. Сама команда является регистрозависимой, и если нам нужно будет найти что-то вне регистра, то мы должны использовать `-i`. Если мы не помним, в каком файле находится слово, то используем `-r` и рекурсивно проверяем файлы в директории на наличие паттерна. Если нам нужно ввести сразу несколько слов в поиске, то обернуть его нужно в `""` кавычки. Если нам нужно инвертировать поиск и найти все строки, кроме определённой, то используем `-v`.

![](_png/Pasted%20image%2020240803194413.png)

`-w` - если требуется найти как выделенное слово (ищем `Clone` и будем находить только `_Clone_`)
`-vw` - так же позволит инвертировать выделение и найти только строки, не совпадающие выделенному слову `Clone`
`-A<число>` - позволит вывести найденное и определённое количество строк ПОСЛЕ него
`-B<число>` - позволит вывести найденное и определённое количество строк ДО него

Так же `-A1 -B1` можно объединить в один запрос, чтобы вывести сразу и до и после совпадения несколько строк

![](_png/Pasted%20image%2020240803195518.png)

Команда `awk` позволяет парсить большое количество текста. Можно сказать, что это целый скриптовый язык с переменными, операциями и символами.

В паттерне команды мы определяем выводимые поля. Все поля делятся по пробелу (как в csv по `;`).

Каждая переменная `$0`, `$1`, `$2` и так далее отвечают за свой участок строки, который выведет команда.

В последнем примере мы меняем разделитель с помощью опции `-F`. Поменяли мы разделитель на `:`. В самом паттерне мы скрыли второе поле (назвав его `hidden`) и вывели всю остальную строку.

 С помощью `|` мы чейним вывод (перенаправление) и передаём результат первой команды во вторую.

![](_png/Pasted%20image%2020240803200511.png)

## Перенаправление

В линукс все операции делятся на три потока:
- `0` - стандартный ввод
- `1` - стандартный вывод
- `2` - стандартные ошибки

Дефолтно, стандартный вывод и ошибки идут в экран пользователя на отображение, но так же эти потоки можно перенаправлять, чтобы выполнять другие операции, как, например, вывод всех данных в файлы, а не на экран

![](_png/Pasted%20image%2020240806190446.png)

Мы можем записать результат выполнения операции в несуществующий пока файл с помощью `>` либо добавить в конец существующего `>>`

![](_png/Pasted%20image%2020240806190649.png)

Так же мы можем перенаправить результат вывода только опрделённого потока в нужный нам файл. Операция `1>` перенаправит только результат успешного выполнения в файл.

Так же стоит отметить про существование папки `/dev/null`, в которую можно положить файлы, которые сразу же пропадут (aka чёрная дыра, пожирающая всю информацию)

![](_png/Pasted%20image%2020240806191010.png)

Так же стоит рассказать про последовательность выполнения перенаправления. 

У нас есть команда `ls -lh > name.txt`

Данные операции в bash выполняются слева направо. 
1. Сначала проверяется существование файла и его создание, при необходимости (что является быстрым способом создания файла)
2. Затём идёт обнуление файла через `>` (либо дополнение через `>>`)
3. Затем выполняется начальная операция, вывод которой заполнится в файл

Таким образом мы увидим в выводе, что в каталоге существует наш файл `name.txt` с весом в 0 байт. Именно такой размер был у этого файла во время создания, потому что результат записался в этот файл уже после того, как выполнилась операция `ls -lh` 

![](_png/Pasted%20image%2020240806191355.png)

Для упрощения работы и использования результатов вывода прошлой команды, используется `|`, который предоставляет стандартный вывод прошлой команды для следующей (вторая команда берёт результат первой и работает с ним)

![](_png/Pasted%20image%2020240806191911.png)

Так же в качестве команды для перенаправления вывода мы можем использовать `tee`. Разница в отличе от `>` в том, что `tee`, по прежнему печатает стандартный вывод на экране, а так же записывает его в файл

`tee -a` заменит операцию `>>` с добавлением вывода в конец файла

![](_png/Pasted%20image%2020240806192401.png)

Так же мы можем с помощью указателей `>&` определять движение потоков по файлам. То есть `&` позволяет указать потоку, в какой поток должен идти его вывод

Команда `ls -lh notOk result.txt 1> result.txt 2>&1`

![](_png/Pasted%20image%2020240806193744.png)

## Логические операторы

В результате выполнения всех команд в строке линукс мы получаем статус код, который отображает успешность или неуспешность выполнения операции.

Команда `echo $?` выводит код статуса завершения операции

- `0` - успешный выполнение операции
- `1` и отличные от нуля - неуспешное выполнение операции



![](_png/Pasted%20image%2020240806195033.png)











## Текстовые редакторы












## Cron










