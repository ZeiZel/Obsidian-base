

## Про процессы

Процесс - это программа, которая выполняется в ОС, взаимодействует с другими программами, делится на другие программы, взаимодействует с ОС, запрашивает у неё ресурсы - все эти явления являются процессом

Создаются во всех ОС процессы по-разному. Создание процесса в линуксе выполняется через полное его клонирование. Вызывается клонирование функцией `fork()`, которая передаётся в пространство ядра.

То есть, когда мы запускаем `uptime`, `fork` отправляет запрос в ядро, где клонируется `bash` (создаётся процесс-потом от `bash`) и в этом клоне запускается функция `exec()`, которая меняет код программы оболочки на код программы `uptime` (`bash` поменялся на `uptime`). Путь: `bash` -> `bash` + `bash` -> `bash` + `uptime`.
Далее `uptime` получает данные, выполняется и записывает результат на свой вывод. После этого он запускает системный вызов `exit()`, который уведомляет систему о том, что операция выполнена и процесс можно закрывать. Сам вызов передаёт идентификатор потомка и код возврата родителю этого дочернего процесса (0/1/и тд). Система закроет процесс, вернёт выделенную память, сотрёт процесс из таблицы процессов и пометит процесс завершённым. Если родитель проигнорировал возврат, то процесс останется в таблице процессов со статусом завершённого - такой процесс называется ==процессом зомби==.
Этот код взврата ждёт родитель процесса и специально для этого в начале дочернего процесса запускает системный вызов `wait()`, чтобы синхронизировать выполнение с момента завершения потомка (получает код возврата от дочернего процесса). После получения из системы код возврата родителем, родитель полностью удаляется из системы.

![](_png/Pasted%20image%2020240808190146.png)

Все процессы находятся в папке `/proc/`. Чтобы посчитать количество процессов, можно посчитать количество записей в папке через `wc -l`

Так же мы можем вывести процессы, которые принадлежат опрдеелённому пользователю через `ls -ld`. Поменять владельца процесса - нельзя.

Есть более удобный вариант вывода процессов - `ps`.

![](_png/Pasted%20image%2020240808191351.png)

Вывести подробную информацию по процессам можно с помощью `ps -elf`

![](_png/Pasted%20image%2020240808191547.png)

Так же `pstree` выведет дерево процессов

![](_png/Pasted%20image%2020240808191623.png)

Чтобы найти определённый процесс, можно грепнуть вывод `ps` и увидеть, например, демон-процессы

Процессы-демоны - это процессы, которые срабатывают при триггере какого-либо события. Обычно их используют для более быстрой отработки операции. Тот же eslint_daemon работает постоянно, что позволяет быстрее форматировать код.

Сами демоны срабатывают на какие-либо системные сигналы, например, подключение по определённому порту, чтобы сигнал шёл через ssh.

Всего различных сигналов 28.

![](_png/Pasted%20image%2020240808191826.png)

Самые распространённые сигналы - это сигналы прерывания процесса.

- 9 - SIGKILL - принудительное завершение процесса со стороны ОС. Эта команда не всемогущая и может не завершить процесс, когда программа ожидает ввод/вывод или когда запущен процесс `init` (`pid=1`).
- 15 - SIGTERM - запуск процесса выхода из программы
- 2 - SIGINT - уведомление процесса о том, что пользователь хочет выйти из процесса (`Ctrl+C` в терминале)

![](_png/Pasted%20image%2020240808193853.png)

Нужно сразу сказать, что бывает достаточно часто такое, что у дочерных процессов завершают родительский процесс. В таком случае дочерные процессы будут либо закрываться, либо для них родительскими будут искаться более старшие процессы.

Во время запуска системы, запускается процесс `init` с `pid=1`, который остаётся в процессах до перезагрузки. Это корневой процесс, от которого запускаются все остальные процессы.

`p(process)id` - это идентификатор процесса, `p(parent)pid` - идентификатор родителя процесса. `pid=1` имеет процесс `systemd`, который обычно находится в `/sbin/init`. Родителем его процесса является процесс с идентификатором `0`, которого не существует.

![](_png/Pasted%20image%2020240808194410.png)

Сам `systemd` - это современный способ запуска системы. Он позволяет достаточно быстро запустить систему за счёт сильного распараллеливания выполняемых операций.

## Создание службы 

`Unit` - это отдельновзятый модуль, который отвечает за точку монтирования файловой системы, работы абстрактных служб, сетевых ресурсов, устройств, изоляции ресурсов и так далее.
`Traget` - это уровень выполнения, состоящий из нескольких `Units`.

Задача: нам нужно запустить службу на сервере, которая локально у нас работает. Сама служба должна работать так:



`units` у `systemd` - это объекты, которыми может управлять система, которые являются аналагом службы/задания (но они имеют более широкую сферу применения, исходя из определения). 

`2:50`







## Инструменты systemd 























