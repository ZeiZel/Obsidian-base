
## Что такое image

### Состав изображения

Для начала скачаем образ nginx с docker hub с помощью docker daemon

```bash
docker pull nginx
```

Как можно заметить, докер скачивает не целиковый образ, а отдельные слои (aka *layers*, из которых состоит образ). Каждый образ подписан уникальным идентификатором. Такой подход позволяет экономить пространство на диске.

![](_png/Pasted%20image%2020240811190542.png)

По-факту, каждый слой - это отдельный образ, который доступен только на Read (чтение). После создания контейнера из image, у нас создастся тонкий слой, который будет доступен для записи информации (ReadWrite).

Это приводит к тому, что сколько бы мы не запустили разных контейнеров изображения, image, на котором (например) nginx будет базироваться, останется всегда один.

![](_png/Pasted%20image%2020240811191349.png)

### Внутрянка image

Теперь мы можем посмотреть, что находится внутри изображения в докере.

Для начала просмотрим список изображений

```bash
docker images
```

![](_png/Pasted%20image%2020240811191415.png)

Чтобы сохранить архив с внутренними файлами изображения, можно воспользоваться следующей командой

> Сразу можно сказать, что данный способ может пригодиться, когда наша машина не имеет доступа в интернет и в неё можно передать изображение только таким образом.

```bash
docker save --output nginx.tar nginx
mkdir nginx
tar xvf nginx.tar -C nginx
```

Ну и в манифесте можно просмотреть все ссылки на остальные слои изображения.

Структура каждого слоя выглядит похожим образом. Даже можно сказать, что layer - это тоже image, который содержит определённую информацию.

Такая иерархия очень похожа на стандартную работу пакетного менеджера, который собирается из других пакетов.

![](_png/Pasted%20image%2020240811192302.png)

Так же в отдельном слое может находиться и внутренность его файловой системы

![](_png/Pasted%20image%2020240811192908.png)

Так же мы можем вывести историю,  по которой мы можем понять, как был собран тот или иной image. История снизу вверх идёт и отображает последовательность операций сборки

```bash
docker history <package>
```

![](_png/Pasted%20image%2020240811193104.png)

Эффективным это переиспользование является потому, что мы не занимаем на диске место несколькими разными контейнерами. У нас поднимаются отдельные верхние слои, которые используют свои модули и пакеты в процессе работы, а так же ссылаются на общие слои.

![](_png/Pasted%20image%2020240812184645.png)

`/var/lib/docker/overlay2` - это группа слоёв изображений, который смёрдживается в одну файловую систему, которая используется в разных контейнерах. Сама по себе она весит немного, так как использует слоёную архитектуру

`/var/lib/docker/containers` - содержит образы контейнеров, которые мы пульнули из хаба. Сейчас тут 54 килобайта nginx

```bash
sudo du -sh /var/lib/docker/overlay2
sudo ls /var/lib/docker/overlay2
```

![](_png/Pasted%20image%2020240812193355.png)

![](_png/Pasted%20image%2020240812194249.png)

После создания отдельного контейнера, мы создаём на базе изображения nginx второй верхний слой, который будет занимать не так много места

То есть прошлое изображение и новое с 56кб начали весить 120кб

```bash
docker run -d --name nginx2 nginx
```

![](_png/Pasted%20image%2020240812195039.png)

Деление оверлея файловой системы:
- Нижний слой
	- link - ссылка на слой
	- diff - изменения файловой системы образа
- Верхний слой
	- lower - ссылается на нижний слой и может вернуть информацию о том, что там лежит
	- link - ссылка для того, чтобы на этот слой мог ссылаться другой слой, который будет выше
	- diff - показывает разницу относительно прошлого слоя
	- merged - слитый diff с предыдущей файловой системой (diff из нижнего и верхнего слоя). Позволяет собрать правильный слепок файловой системы, на которой будет работать образ
	- work - папка для хранения внутренних данных для оверлея

![](_png/Pasted%20image%2020240812195407.png)

Собственно, все эти папки можно вывести из определённого изображения

![](_png/Pasted%20image%2020240812200843.png)

Раньше использовались драйверы OverlayFS1 (предыдущая, менее эффективная версия) и AUFS (этот был устроен сложнее, но выполнял всё то же самое, хоть и медленнее)

## 002 Работа с image








## 003 Dockerfile








## 004 Создаем свой image








## 005 Улучшаем сборку








## 006 Анализируем image








## 007 Многоэтапная сборка








## 008 Упражнение - Сборка go проекта





















