## 016 Устройство Node.js

В начале 2000-х годов у нас были стандартный многопоточные серверы. Один поток процессора сервера выполнял один запрос от пользователя. 
Основная проблема заключалась в том, что 1 поток занимал 1 мб памяти и само переключение потоков требовало определённых ресурсов компьютера. 

![](_png/Pasted%20image%2020221120120612.png)

Далее проблема переходила в то, что наш поток блокировался в процессе выполнения своих операций и простаивал пока происходило логирование данных, получение данных из базы и происходил сам рендер шаблона 

![](_png/Pasted%20image%2020221120120701.png)

Так же вследствие того, что поток занимал 1 мб памяти, то при выделении большого количества потоков, у нас может появиться стопор в виде недостатка памяти (а на момент начала 21-ого века 10 гб памяти было большой цифрой) 

![](_png/Pasted%20image%2020221120120815.png)

Поэтому вдальнейшем была придумана система, при которой наш поток не блокируется

![](_png/Pasted%20image%2020221120120858.png)

Поэтому схема, которая работала раньше, преобразуется уже в другую: 
1) Мы имеем запросы
2) Все они поступают в основной поток, который выполняет задачи запросов
3) Если задача достаточно тяжёлая, то она отправляется на дополнительный поток сервера (например, криптография, чтение файлов и так далее)

![](_png/Pasted%20image%2020221120121352.png)

Так же в ноде существуют такие понятия как: стек и куча.
1) Куча хранит в себе переменные
2) Стек - это хранилище стека вызова функций

Конкретно тут мы видим ситуацию со схемы выше. Стек - это основной поток, который выполняет все операции. Конкретно функция `setTimeout` не будет блокировать все остальные операции - она вынесется в дополнительный поток, где и обработается.

==node== - это не однопоточный фреймворк. Это фреймворк, который имеет один основной поток (стек вызовов) и множество дополнительных поток, в котором выполняются более затратные операции.

![](_png/Pasted%20image%2020221120121555.png)

Составляющие ==NodeJS==:
1) Движок ==V8== (виртуальная машина JS), который разрабатывается в ==google== и находится в хроме;
2) Библиотека LibUV. Она реализует концепцию Event Loop, Thread Pool и асинхронный ввод/вывод;
3) Стандартная библиотека. Она содержит в себе функциональность работы с файловой системой, криптографией, ивентами и всеми остальными функциями ноды (аналог - WebAPI);
4) Далее наш код будет биндиться в C/C++ код, который уже будет выполнять эффективные операции над нашими операциями;
5) Так же мы можем подключать C/C++ аддоны к нашему приложению;
6) NodeJS API

![](_png/Pasted%20image%2020221120122123.png)

К нам пришёл на сервер запрос от пользователя, первым делом он попадает в движок V8 откуда попадает в биндер ноды, уже который переводит запрос в очередь событий. В рамках очереди событий, у нас есть Event Loop, который крутиться и обслуживает всю нашу систему. После же Event Loop отправляет все задачи в Callstack (тот самый основной поток - Stack), где задача и выполняется на движке V8, либо, если встречается тяжёлая задача, она идёт на выполнение в отдельный поток. После выполнения задачи уже из этого стека результат задачи идёт обратно в ивент луп, откуда и передаётся обратно на входные системы для выдачи ответа.
Если выполнилась тяжёлая задача, то её коллбэки будут передаваться обратно в очередь событий, откуда пройдёт стандартный путь стандартной задачи.

![](_png/Pasted%20image%2020221120123235.png)

## 017 Event Loop

Event Loop имеет свои фазы, которые описаны в его документации. Самой важной и основной является четвёртая, потому как нода очень быстро работает с вводом/выводом.

![](_png/Pasted%20image%2020221120164001.png)

Так как указаны не все выполняемые элементы языка, то между этими фазами выполняются остальные функции (те же промисы)

![](_png/Pasted%20image%2020221120164516.png)

В полной картине выполнения ивент лупа выполняется в самом начале инициализация всех импортов и функций. Далее по порядку выполяются все элементы ивент лупа. Потом ивент луп проверяет, на закончена ли программа (например, если в моменте совершения лупа таймер был 3 секунды, то луп повторяется до тех пор, пока время таймера не кончится и не выполнится операция).

![](_png/Pasted%20image%2020221120165120.png)

## 018 Таймеры

Первое, что нужно отметить это то, что таймер не гарантирует нам выполнение функции ровно в то время, которое мы указали. Он гарантирует нам, что функция сработает не раньше указанного времени. И чем более высоконагруженные задачи будут в стеке, тем на большее время будет отдаляться выполнение функции от таймера  

```JS
const start = performance.now();

setTimeout(() => {
	console.log(performance.now() - start);

	console.log("Прошла секунда");
}, 1000);
```
![](_png/Pasted%20image%2020221120170311.png)

Чтобы вызывать таймаут с аргументами, нужно просто перечислить их через запятую

```JS
function myFunc(arg) {
	console.log(arg);
}

setTimeout(myFunc, 1000, "Этот мир");
```

Так же мы можем отменять выполнение таймера через `clearTimeout()`

```JS
const timerId = setTimeout(() => {
	console.log("BOOOOOM!");
}, 5000);

setTimeout(() => {
	clearTimeout(timerId);
	console.log("Таймер очищен");
}, 1000);

```

И так же мы можем отменить работу интервала. Интервал `setInterval()` уже повторяет функцию каждое определённое время.

```JS
const intervalId = setInterval(() => {
	console.log(performance.now());
}, 1000);

setTimeout(() => {
	clearTimeout(intervalId);
	console.log("Интервал очищен");
}, 5000);
```
![](_png/Pasted%20image%2020221120181243.png)

Функция `setImmediate()` мгновенно выполняет функцию сразу в самом конце программы

```JS
console.log("Начало");

setImmediate(() => {
	console.log("Immediate");
});

console.log("Конец");
```
![](_png/Pasted%20image%2020221120182539.png)

Так же мы можем убрать ссылку из стека на таймер через функцию `unref()` 

```JS
const timerId = setTimeout(() => {
	console.log("BOOOOOM!");
}, 5000);

timerId.unref(); // таймер не отработает
```

Но так же мы можем обратно вернуть ссылку на таймер, чтобы он выполнился через `ref()`

```JS
const timerId = setTimeout(() => {
	console.log("BOOOOOM!");
}, 5000);

timerId.unref(); // таймер отцеплен

setImmediate(() => {
	timerId.ref(); // таймер обратно прицепили и выполнили
})
```

## 019 Пример работы event loop


>[!note] Фазы Event Loop
>- инициализация
>- ---
> #### Фазы
> - таймеры
> - pending callbacks
> - idle, prepare
> - poll
> - check
> - close callback
> ---
> - проверка на окончание

Мы проинициализировали все функции в нашем коде, выполнили все синхронные функции, затем уже приступили к выполнению асинхронных функций. Конкретно тут видно, что функция таймаута задержалась на выполнение последнего `console.log` и поэтому сильно отдалилась в выполнении от начального значения 

```JS
console.log("Начало");

// таймер
setTimeout(() => {
	console.log(performance.now(), " timer 0ms");
}, 0);

console.log("Конец");
```
![](_png/Pasted%20image%2020221122084738.png)

Функция `setImmediate` относится к завершающим, поэтому она выполняется в конце порядка этой фазы ивент лупа

```JS
console.log("Начало");

// таймер
setTimeout(() => {
	console.log(performance.now(), " timer 0ms");
}, 0);

// check
setImmediate(() => {
	console.log("Immediate");
});

console.log("Конец");
```
![](_png/Pasted%20image%2020221122085306.png)

Дальше мы встречаемся с тем, что `setImmediate` выполнился до нашего таймаута. Почему?
Мы входим в первую фазу ивент лупа, смотрим, что таймер незарезолвен, так как его таймер не вышел, дальше уже идёт пункт `check`, где и вызвается `setImmediate`, и он там и вызывается.
Уже во второй фазе ивент лупа наш таймаут зарезолвен, что даёт нам возможность его выполнить, и вот уже сейчас его результат выведен.

```JS
console.log("Начало");

// таймер
setTimeout(() => {
	console.log(performance.now(), " timer 0ms");
}, 100);

// check
setImmediate(() => {
	console.log("Immediate");
});

console.log("Конец");

```
![](_png/Pasted%20image%2020221122085616.png)

Уже тут ивент луп выполняет три круга. Выполняет иммедиэйт. На втором получает ответ от асинхронного прочтения файла через `fs` и выполняет его колбэк-функцию. На третьем резолвится таймер и выполняется его коллбэк

```JS
const fs = require("fs");

console.log("Начало");

// таймер
setTimeout(() => {
	console.log(performance.now(), " timer 100ms");
}, 100);

// check
setImmediate(() => {
	console.log("Immediate");
});

// poll
fs.readFile(__dirname, () => {
	console.log("File was read(?)!");
});

console.log("Конец");
```
![](_png/Pasted%20image%2020221122090623.png)

Тут уже нужно описать несколько моментов:
1) ==Большая операция==. Мы имеем крайне тяжеловесную операцию, которая выполняется самой первой, так как по времени она зарезолвлена сразу. Из-за неё фаза стопорится и прошлый таймер, так как он уже проверен был, выполнится намного позже - только на следующем заходе в новую фазу.
2) ==Промис==. Он выполнился на этапе `microtask, nextTick`, который выполняется сразу **после каждого** этапа нашей фазы ивент лупа!

```JS
const fs = require("fs");

console.log("Начало");

// таймер
setTimeout(() => {
	console.log(performance.now(), " timer 100ms");
}, 100);

// check
setImmediate(() => {
	console.log("Immediate");
});

// poll
fs.readFile(__dirname, () => {
	console.log("File was read(?)!");
});

// большая операция
setTimeout(() => {
	for (let i = 0; i < 1000000000; i++) {}
	console.log("Big operation done")
});

// microtask, nextTick
Promise.resolve().then(() => {
	console.log("Promise");
});

console.log("Конец");
```
![](_png/Pasted%20image%2020221122091504.png)

И примерно так выглядят фазы, если мы включим в схему выполнение промисов

```md
- инициализация

## Фазы
// microtask, nextTick
- таймеры
// microtask, nextTick
- pending callbacks
// microtask, nextTick
- idle, prepare
// microtask, nextTick
- poll
// microtask, nextTick
- check
// microtask, nextTick
- close callback

- проверка на окончание
```

Ну и так же если мы воткнём в большую операцию промис, то он начнёт выполняться сразу после неё:

```JS
// большая операция
setTimeout(() => {
	for (let i = 0; i < 1000000000; i++) {}
	console.log("Big operation done");
	// microtask, nextTick
	Promise.resolve().then(() => {
		console.log("Promise timeout");
	});
});
```
![](_png/Pasted%20image%2020221122092402.png)

Ну и так же `process.nextTick()`, который выполняется вместе с промисом после каждой фазы. 
Сама тиковая операция очень важна, когда мы совершаем те же htttp-реквесты или для регистрации обработчиков некоторых событий.

```JS
const fs = require("fs");

console.log("Начало");

// таймер
setTimeout(() => {
	console.log(performance.now(), " timer 100ms");
}, 100);

// check
setImmediate(() => {
	console.log("Immediate");
});

// poll
fs.readFile(__dirname, () => {
	console.log("File was read(?)!");
});

// большая операция
setTimeout(() => {
	for (let i = 0; i < 1000000000; i++) {}
	console.log("Big operation done");
	// microtask, nextTick
	Promise.resolve().then(() => {
		console.log("Promise timeout");
	});
});

// microtask, nextTick
Promise.resolve().then(() => {
	console.log("Promise");
});

// nextTick
process.nextTick(() => console.log("Tick"));

console.log("Конец");
```
![](_png/Pasted%20image%2020221122092709.png)

## 020 Stack вызова

==Стек вызовов (Call Stack)== в JS устроен по принципу LIFO (Last In, First Out — последним вошёл, первым вышел). Цикл событий постоянно проверяет стек вызовов на предмет того, имеется ли в нём функция, которую нужно выполнить. Если при выполнении кода в нём встречается вызов некоей функции, сведения о ней добавляются в стек вызовов и производится выполнение этой функции.

Конкретно тут в примере мы видим по шагам, как выполняется логирование результата функции и куда попадают и где сохраняются наши результаты внутри системы стека. 

![](_png/Pasted%20image%2020221122094417.png)
![](_png/Pasted%20image%2020221122094423.png)
![](_png/Pasted%20image%2020221122094427.png)
![](_png/Pasted%20image%2020221122094431.png)
![](_png/Pasted%20image%2020221122094436.png)
![](_png/Pasted%20image%2020221122094440.png)
![](_png/Pasted%20image%2020221122094442.png)

Уже в этом примере можно увидеть, что таймер после инициализации в стеке сразу из него выходит, чтобы не стопорить стек, и чтобы тот продолжал свою работу в стандартном режиме 

![](_png/Pasted%20image%2020221122094926.png)
![](_png/Pasted%20image%2020221122094921.png)
![](_png/Pasted%20image%2020221122094917.png)
![](_png/Pasted%20image%2020221122094913.png)
![](_png/Pasted%20image%2020221122094910.png)
![](_png/Pasted%20image%2020221122094907.png)

Чтобы просмотреть стек вызова, мы можем зайти в отладчик внутри VSCode и в нём просмотреть все полученные значения стека вызова

![](_png/Pasted%20image%2020221122095907.png)

>[!info] Особенности стека
> - Стек может быть переполнен (err: StackExided). Произойти ошибка может, если была запущена рекурсивная функция без явного конца

## 021 Worker threads

Это упрощённая схема работы воркера. Из стека тяжёлые задачи попадают в воркер, а уже из него возвращаются колбэки тех тяжёлых задач. Однако не все задачи попадают в отдельные воркеры.

![](_png/Pasted%20image%2020221122101017.png)

На самом деле рабочий поток предоставляется нашим задачам, если на то будут оправданы ресурсы. В основном процессе все наши функции очень тесно соприкасаются с ==C++==, который и обрабатывает запросы на выполнение от ==JS==, либо отправляет задачу в один из рабочих процессов. 
По умолчанию рабочих процессов всего 4 (как установлено в ==libuv==)

![](_png/Pasted%20image%2020221122101021.png)

Каждый поток, грубо говоря - это одно ядро процессора. 4 треда - это условный четырёхядерный процессор, который может без потери производительности выполнять операции. Если мы хотим выделить 8 воркер тредов на 4-хядерном процессоре, то эти потоки будут выполняться последовательно.  
Конкретно под воркер тред выделяются задачи по работе с файловой системой, днс.лукап, редкие пайпы и тяжёлые для ЦПУ задачи (то же шифрование) 

![](_png/Pasted%20image%2020221122101354.png)

Сейчас мы можем чётко увидеть, что у нас выделено всего 4 воркер треда по умолчанию на выполнение тяжёлых задач 

```JS
// подключение библиотеки шифрования
const crypto = require("crypto");

// фиксируем начало выполнения
const start = performance.now();

// выполняем шифрование
for (let i = 0; i < 50; i++) {
	crypto.pbkdf2("test", "salt", 100000, 64, "sha512", () => {
		console.log(performance.now() - start);
	});
}
```
![](_png/Pasted%20image%2020221122102847.png)

Так же мы можем выделить большее количество ядер для выполнения операции. 
Зачастую такая настройка не нужна, так как мы запускаем сервер в контейнере на виртуальных процессорах.

```JS
// подключение библиотеки шифрования
const crypto = require("crypto");

// фиксируем начало выполнения
const start = performance.now();

// увеличиваем количество воркер тредов до 8
process.env.UV_THREADPOOL_SIZE = 8;

// выполняем шифрование
for (let i = 0; i < 50; i++) {
	crypto.pbkdf2("test", "salt", 100000, 64, "sha512", () => {
		console.log(performance.now() - start);
	});
}
```

Ну и так же мы можем отправлять запросы на сервер с такой же проверкой времени

```JS
// подключение библиотеки запросов
const https = require("https");

// фиксируем начало выполнения
const start = performance.now();

// выполняем отправку запросов
for (let i = 0; i < 50; i++) {
	// отравляем запрос яндексу на получение данных
	https.get("https://www.yandex.ru", (res) => { // получаем результат
		// если мы получаем данные, то что-то делаем
		res.on("data", () => {});
		// срабатывает, когда получаем последний байт данных
		res.on("end", () => {
			console.log(performance.now() - start);
		});
	});
}
```
![](_png/Pasted%20image%2020221122105112.png)

## 022 Измерение производительности



```JS
function slow() {
	// делаем отметку по времени - начало
	performance.mark("start");
	const arr = [];
	for (let i = 0; i < 100000000; i++) {
		arr.push(i * i);
	}
	// делаем отметку по времени - конец
	performance.mark("end");

	// и тут будет происходить подсчёт времени нашей производительности
	performance.measure("slow", "start", "end");

	// получает все наши измерения
	console.log(performance.getEntries());
	// получает только одно наше измерение по имени
	console.log(performance.getEntriesByName("slow"));
}
slow();
```
![](_png/Pasted%20image%2020221122111228.png)









