### 001 Функциональные выражения

![](_png/dbe06ce7bf3eedc6d494aa01e19ff835.png)
![](_png/8dd50d6467fdde9a47131ca1969c64b4.png)

Последний пункт отвечает за концепцию ==call-back== функций. Чаще всего там используются функциональные выражения

![](_png/3a699ab8ecb4ceffed4cc1c753ac2598.png)

Тут уже идёт такая структура:

Переменная – присвоение переменной – само функциональное выражение (оно идёт сразу после `=` и только оно является функциональным выражением)

![](_png/389b1eb50411fcbd2bc7e11064ecdd19.png)

И так как `setTimeout()` принимает в себя только функцию и время* (опционально*), то в нём можно вызвать анонимную функцию (потому что тут нет необходимости в объявленной)

![](_png/87a96f27d94d53b003d15d8057cc70d8.png)

### 002 Стрелочные функции

![](_png/36e0c452d7691835146e33815f9a6c43.png)
![](_png/2047a9db6d23ea01a51d1a4015b647c1.png)![](_png/357bbfd3d64244bc6f57066150e7294f.png)

Тут стоит сразу сказать, для чего мы присваиваем функции к переменной. Мы делаем это для того, чтобы защитить их от переприсвоения (`const`).

![](_png/60d22621340d8a8d746634b95108bccb.png)

Так же стрелочную функцию можно быстро и просто использовать

![](_png/979fa0acf1b88945936642f0fe5039c7.png)

Так же есть сокращённые варианты написания функций:

1) Тут стоит заметить, что лучше всё-таки написать круглые скобки, даже если используется один параметр
2) Тут в функции автоматически будет выполняться оператор `return` над нашей инструкцией

![](_png/3144dd4b0be2b4de594384494d226230.png)

### IIFE (Immediately Invoked Function Expression) 

Это [JavaScript](https://developer.mozilla.org/ru/docs/Glossary/JavaScript) функция, которая выполняется сразу же после того, как она была определена (оба примера на картинках равнозначны и работают почти одинаково)

```JS
(function () {
	return 4 * 4;
})();

(function () {
	return 4 * 4;
}());
```

Функция становится мгновенно выполняющимся функциональным выражением. Переменные внутри функции не могут быть использованы за пределами её области видимости.

Функциональное выражение, которое было тут описано, не будет хранить в себе вызываемую функцию. Оно будет хранить только результат выражения

```JS
const result = (function () {
	const rounded = Math.round(4, 56);
	return rounded;
})();

console.log(result); // выведет результат вызова функции, так как переменная функцию не хранит
```

Так же можно вызвать эту функцию представленным ниже образом. Вообще, в такой вариации можно использовать не только `!`, а заменить его на `+`,  `-` или `~`. В общем, подойдет любой унарный оператор.

Стоит отметить, что после вызова функции – она исчезнет и больше не будет совершать никаких действий на странице

![](_png/8e1116a67db42dc732f9a96200fed5d6.png)![](_png/3d8cdb4a293a8f4568f0a7370852f8c2.png)

В этом примере мы объявили две переменные внутри ==IIFE== и тут они приватные, то есть только для самой ==IIFE==. Никто за пределами ==IIFE== не имеет к ней доступа. Так же, у нас есть функция `init`, к которой ни у кого нет доступа за пределами ==IIFE==. Но функция `init` имеет доступ к приватным переменным.

![](_png/ebf0ae295f9b8b76ffb77b4fb511a5b8.png)

>[!info] Преймущество использования IIFE:
>В следующий раз, когда вы будете создавать группу переменных и функций в глобальной области видимости, которые никто не использует за пределами вашего кода, просто оберните все их в IIFE и получит в ответочку много хорошей JavaScript кармы за такие дела. Ваш код будет также работать, но только теперь вы не будете загрязнять глобальную область видимости. А еще вы защитите ваш код от тех, кто может случайно внести изменения в глобальные переменные, ну а может быть и не случайно.

Так же в такую функцию можно передавать аргументы

![](_png/cc0a28dc492657e259726e8e8831ec3a.png)

### Проименованные функциональные выражения

Так же для реализации рекурсии в функциональных выражениях можно использовать такой синтаксис

![](_png/b3c0a833dd30ba53a4d9176a65553e2f.png)

### 003 Значения параметров функции по умолчанию

Так же никто нам не запрещает использовать значения по умолчанию для избегания ошибок реализации функции

![](_png/47b4035e3bc8d8ededc407b68ff1bf1d.png)![](_png/89c0c1d34e8b029dfad34a0e5bffb6d1.png)

Тут изображена функция, которая выполняет действие над объектом. Первый параметр – сам объект, второй параметр – стоковая дата. Дальше, в теле функции, мы раскладываем переданный объект и добавляем новое значение. Тем самым мы избежали мутаций и создали новый объект, который будет иметь дополнительно дату

Скобки `()` выполняют роль неявного возвращения объекта. То есть, если опустить скобки, то интерпретатор подумает, что начинается тело функции и нам нужно будет использовать return

**То есть явное возвращение результата функции – `return`, неявное – с использованием `()`**

![](_png/2d86766321a54c6e0a801e24e39d5fe4.png)

К слову, это встроенная функция, у которой можно посмотреть ещё её методы (`now`, `parse`)

![](_png/66549df598833a95a40b21d7ef5a58c6.png)

Вот явный способ возвращения объекта из функции

![](_png/e1eb2d0d3fed46583c6fe445f1d449f8.png)

Так же можно присваивать возвращённые из функции значения переменной

![](_png/f18fb8097e812f3b258a2ac78f6a35c3.png)

Вот неявный способ возвращения значения объекта из функции

![](_png/283c40dbe4846fd4c67be3d004c601a2.png)

То есть тут стоит пояснить, что в первом случае, мы возвращаем **неявно целую группу свойств**, а во втором – **явно указываем, что возвращать**

![](_png/813a2c5ff93836ffc7962c09c98590b5.png)