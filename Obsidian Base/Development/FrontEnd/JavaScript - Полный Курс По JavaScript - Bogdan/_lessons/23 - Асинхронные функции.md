
### 001 Асинхронные функции

Это специальный синтаксис для упрощения работы с промисами

![](_png/c8456b0bd23b5f10faa73a7c32c45921.png)

Асинхронная функция вместо какого-либо значения всегда возвращает промис

![](_png/ce747590fda56bab45f512384ae87517.png)

Данная функция вернёт в результате промис, а в качестве аргумента resolve будет передана возвращаемая строка

![](_png/445b348e62d4f682b0acf21e5abe9ed5.png)

И так же мы можем к вызову функции применить `then()` и `catch()` для обработки результата функции и работы с ней

![](_png/00534ae29e0bcf812d26c588b2a96136.png)

При появлении ошибки, мы будем видеть в статусе промиса `rejected`

![](_png/de471385701351a22efeab3ebac46233.png)

Обработка ошибок промиса

![](_png/86ff5650d1d2b30afb3a4cbd42eb884b.png)

### 002 Использование `await` внутри асинхронных функций

Ключевое слово `await` позволяет нам не ожидать выполнение промиса, а сразу приступать к выполнению остальных инструкции внутри асинхронной функции. Данное ключевое слово работает только в асинхронной функции

![](_png/cd71ef1c06a5901faec1df21eda6a838.png)

### 003 Пример с `async await`

Мы имеем, собственно, асинхронную функцию. Создали первую функцию, которая возвращает нам результат промиса. Вторая функция выполняет промис, который выполняется обязательно прежде чем продолжить выполнение кода дальше (промисы дают выполнять код дальше в отличие от асинхронок)

![](_png/1d4a760cfee7b7c386ddc85897f87879.png)

### 004 Переход с промисов на `async await`

И вот пример функции `getDate()`, которая возвращает по итогу json формат данных. Переменные внутри функции заменяют `then()` и читаются лучше. Если выпадет ошибка, то промис просто будет автоматически отклонён

![](_png/0582b018dfbb276648da466bf6f3480f.png)

И вот представлен пример сокращённого написания как самого промиса, так и быстрый вывод его результата (заменой then()). Однако в этом случае мы можем словить непойманную ошибку, так как обработки ошибки - нет

>Тут нужно напомнить, что `await` можно использовать только внутри асинхронных функций. Дело в том, что браузер может обработать такой код, а внешние интерпретаторы - нет

![](_png/8218b30ff86dd22bacc523a8443e26b7.png)

### 005 Обработка ошибок в асинхронных функциях

Чтобы отловить ошибку, нужно будет поместить код вывода результата в блок `try/catch`

![](_png/a93930a9f41966e188a5b6ca571e9c6e.png)

### 006 Ключевые принципы в async await

Тут нужно поподробнее остановиться на последнем пункте. В асинхронных функциях будет ожидаться выполнение промиса, **но промисы** _не блокируют выполнение остальных частей фронт-энд приложения_ (например, нажатие каких-либо кнопок). И только тогда, когда выполнение промиса будет закончено (`resolve`/`rejected` – и не `pending`), функция продолжит своё выполнение

![](_png/efda3a164fbc0f1707be8292c9a4f3dd.png)