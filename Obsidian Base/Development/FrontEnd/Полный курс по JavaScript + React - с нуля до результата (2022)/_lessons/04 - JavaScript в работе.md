
## 002 ClassList и делегирование событий


С помощью приведённых ниже методов обычно создают изменения в классах для применения новых стилей на объекте и проявления элементов. Конкретно данный гамбургер был сделан через использование метода `toggle()`

![](_png/f5615459dbaf220d36ba590f66aa1271.png)

![](_png/d7260037de2f8068786e562ac3b872ad.png)

Изначальный код на странице:

![](_png/1adad9d29ea2307fa53f9731ea23fab7.png)

Сначала мы получим псевдомассив со всеми нашими кнопками со страницы. Через `classList.length` можно получить количество классов на объекте. Через `classList.item(индекс)` можно получить наименование класса объекта под определённым индексом

![](_png/0b6361b675e6ede92072ae6b7ea2037a.png)

![](_png/ee814357cd128942d2e34a6f60edbdf8.png)

Метод `classList.togle()` крайне полезен и юзабелен. Данный метод добавит класс, если он отсутствует на объекте и удалит, если уже присуствует. Он может заменить целый блок с условной конструкцией, так как в его нутрянке и есть подобная проверка

![](_png/6cc221de54253867e9a9a510e5f04624.png)

Метод `contains()` проверяет наличие класса в выбранном объекте. С помощью него можно прописать условие, которое будет срабатывать при наличии определённого класса

![](_png/c713354ed9f64ee809ad75c1b4e4bb4a.png)

И вот пример добавления/удаления класса через условную конструкцию и через `toggle()`

![](_png/d19a1c23666d73b55897bfff2dd22a3d.png)

`className` – устаревший способ изменения классов. Он хранит в себе классы как строчку и использовать его неудобно

![](_png/d5ac0cbbeebe885376579e4fe064defa.png)

И сейчас нужно поговорить про добавление события для нескольких элементов на странице. Дело в том, что если нам нужно одинаковое событие на странице для нескольких элементов, то мы могли бы добавить `addEventListener` через `forEach` на все такие элементы. Однако такой подход немного устарел и имеет свои минусы в виде того, что если элемент отсутствовал на странице, то тот при появлении не будет иметь данный ивент.

Чтобы упростить задачу, нам нужно применить данный ивент на сам враппер, который в себе содержит эти элементы

![](_png/582b3aef3ffd1b343d251754cc7d207f.png)

Далее хорошо бы было узнать название элемента в самой HTML-структуре через дир - `event.target` (название элемента можно увидеть при нажатии на него на странице)

![](_png/0faa4670d485ec255fe0ffec2a6027b2.png)
![](_png/faccb87be07e09f794d471d7050ac794.png)

И теперь при нажатии любой кнопки внутри `wrapper` (даже если кнопка появилась позже в нём) у нас будет срабатывать `event`. При нажатии на сам враппер, ничего происходить не будет

Такой способ называется делегированием

![](_png/525e460fd9bfe30935c52a80234c5df2.png)
![](_png/1e3b121bab4dfeca7e249b19cd8ee8d9.png)

Так же можно присвоить ивенты только тем кнопкам, которые имеют определённый класс (тут – `blue`)

![](_png/aba8e8fd636b01589d3a501b7832fbea.png)
![](_png/6ef72963062d78d70a62fb8aa3960000.png)

И вот простой пример. Созданная кнопка после объявления ивента, уже имеет данный ивент, потому что он делегируется дочерним элементам

![](_png/f368b0dd79f1c9cb2752b3de9ad2ffa7.png)
![](_png/7c34de997a0a7fb3d58af22a46732dfd.png)

При таком коде новый ивент не будет добавлен на кнопку и она будет грустить одна такая☹

![](_png/89c3ba920b10f19c417ddb121c42ce4c.png)

И так же есть продвинутая техника обращения к элементу через метод `matches()`, внутрь которого мы положим наименование элемента и селектор класса

![](_png/4cef273fb4f4a864013e53e34ec70afd.png)
![](_png/c8f7040b64832acd10fdf17ecd571e22.png)


## 003 Создаем табы в новом проекте


Вот хороший пример структуры CSS-документа, когда разные стили находятся в разных блоках. Такой подход упростит создание большого сайта

![](_png/447593c20a8dde6428bd338984a99be0.png)

Ну и немного дополнительных стилей, с которыми можно будет порабоать из JS

![](_png/b7bc5b041e41bdadfd00d6e360d091e7.png)

Так выглядят наши переключатели табов

![](_png/79b03fde5e915d6b6f8a64a3c2118145.png)
![фитнес|500](_png/e6d7a861e5ebdade9f16f638da9b9fb4.png)

Так выглядят сами табы

![](_png/96f962a2ab4545c089a2af1298b74fdb.png)
![](_png/2096489cc476bb8f87dad75f34ac6c11.png)

Для начала мы запишем весь наш код в ивентлистенер документа, который будет срабатывать при загрузке всей дом-структуры

![](_png/7b2c414a75230884adb478d2a35be365.png)

Данной функцией мы прячем весь контент наших табов (добавляем хайд и снимаем шоу с анимацией фэйда на всех элементах через цикл)

![](_png/6ade37f4b62aa4eb3a6f3c3e23d19971.png)

И дальше реализована функция, которая показывает нужные табы по индексу. По умолчанию индекс равен нулю. Тут мы ремувим хайд и добавляем шоу и фэйд. Так же добавляем класс активности для переключателя табов

![](_png/0725a57f40d41ea00404ba0a5fefb136.png)

И самая сложная часть: смена активности таба. Её мы будем реализовывать через проверку тыкнутого элемента с `event.target`. Его айди закинем в метод `showTabContent()`

![](_png/07bfb1c9b4a0730bf54e83f46d0e236f.png)

Ивент будет срабатывать при клике внутри родителя.

Для начала мы упростим обращение к таргету. Потом мы создадим условие, которое будет срабатывать, если элемент имеет нужный нам класс (класс элемента внутри родителя).

Дальше мы внутри условия будем перебирать все наши кнопки для переключения изображений. В качестве аргументов используем саму кнопку и её индекс.

Внутри создаём ещё одно условие - если кнопка будет совпадать с таргетом, то будем прятать весь контент и показывать нашу кнопку по индексу

![](_png/3738cb1860400e2b3b2f065ac6157a95.png)


## 004 Скрипты и время их выполнения. setTimeout и setInterval


Примерно так можно написать `setTimeout()` в обычных условиях. Первым аргументом функция принимает колбэк-функцию, вторым аргументом – таймаут. Все остальные аргументы – это аргументы для вложенной колбэк-функции

![](_png/63e49ff05b18d4d6da10b179c71ff567.png)

Так же мы можем вложить именованную функцию в таймаут. Тут нужно заметить, что внури мы не вызываем функцию, а просто вкладываем её имя 

![](_png/5f2d09456d0345ca568bea4f6aceca2b.png)

Когда мы передаём `setTimeout()` в переменную, мы передаём числовой идентификатор этой функции. Делается это для того, чтобы чётко определять различные `setTimeout` в коде, так как таких асинхронных функций может быть много

И так же мы можем очистить интервал и отменить его выполнение

![](_png/abe79f02920adce384dd90f7efb3e5f5.png)

Таким способом мы можем задать таймаут для определённой кнопки. Так же через таймаут часто задают всплытие каких-нибудь модальных окон на сайтах

![](_png/174e222764176b76347a7833a0b0241c.png)
![](_png/86a3382034849267fcc466d9ae1f5f1c.png)

И так же мы можем воспользоваться не только таймаутом, но и задать выполнение функции по интервалу (в примере каждые 3 секунды) через `setInterval()`

![](_png/b26d0314e6b7e954589bef63136f38f5.png)

И уже в таком случае наш код сможет добраться до переменной с интервалом. Однако тут мы встречаемся с другой проблемой: `clearInterval` не выполнится, так как он идёт в синхронном потоке кода. Дело в том, что на момент выполнения у него не будет никакого значения, вместо него в нём будет `undefined` (`clearInterval(longTO = undefined)`)

![](_png/998a370f7a137cea8fcbae831b5cbb32.png)

Чтобы очистка интервала не выходила из потока, нам нужно задать в самой функции определённое условие, по которому будет выполнятся очистка интервала изнутри самого этого интервала

![](_png/5d833d9eed2b868de0c07c15e2f9c16a.png)
![](_png/c6ac5524fd92450032565a852697e560.png)

И сейчас мы подбираемся к проблеме, которая заключается в том, что `setInterval` не учитывает то, сколько времени выполняется функция внутри него. Он просто выполняет функцию раз в определённое время, которое ему задали. Сама же функция внутри него может выполняться и гораздо дольше.

И тут уже приходит рекурсивный `setTimeout()`. Он, в свою очередь, сначала выполняет функцию и уже только потом ожидает выделенное время. Создаётся такой таймаут через перевызов по его идентификатору (переменной)

![](_png/cded009feea0da8228f629faf6219986.png)

И тут уже представлено создание анимации блока, который перемещается по боксу при нажатии на кнопку.

Первым делом, получаем нашу кнопку, через которую будем запускать анимацию.

Во-вторых, создадим анимацию, внутри которой будем хранить сам бокс, который будем перемещать. Там же инициализируем наш счётчик позиции и идентификатор `setInterval`. Так же внутри расположим функцию, которая будет менять позицию каждый кадр. Эта функция будет помещена в интервал.

Конечной точкой нашего блока будет сдвиг до конца блока (тут 600 бокс и 120 движущийся блок – 480 длина пути). Проверка будет выполняться, пока позиция не будет равна нужному нам числу. После мы очищаем интервал

Интересная особенность: даже если написать периодичнсть в интервале = 0, то всё равно на уровне кода она может иметь минимум в 4 миллисекунды.

![](_png/cbf91417e6791ede53812718df8bc8f1.png)
![](_png/167cc9fbe83bc941aa08a48bf4f1fa5f.png)



## 005 (д) Сборщик мусора и утечки памяти


Если говорить просто, то JS – это высокоуровневый (все базовые команды прописаны за нас) интерпретируемый (его основа – это не компилятор, а интерпретатор) ЯП.

И вспомним, что в функции можно объявить переменную без `let` и `const`. Если залезть немного внутрь, то это будет то же самое, что и объявить переменную глобально через прототип `window`. Дело в том, что такая переменная неудаляема и сборщик мусора ничего с ней не сделает

![](_png/2300b335de5ce26d6b40e6e70d3033e2.png)

Так же сборщик мусора не может удалить оставленные нами таймеры. Дело в том, что они хранят ссылку на конкретные объекты, которые в данный момент используются. Такие таймеры нужно останавливать и выключать

![](_png/2e3a8f28a222f19d19e4f55189d11cfa.png)

Так же стоит упомянуть и обработчики событий. Дело в том, что в старых браузерах они так же создавали утечку памяти. Если мы удалим объект с ивентом, но не удалим сам ивент, то у нас в памяти останутся оба данных объекта и будут занимать место. Однако современные браузеры могут чистить и оставленные ивенты.

В React и JQery очистка ивентов реализована автоматически. Однако в нативном JS является хорошим тоном стирать ивенты через `removeEventListener()`.

Так же если мы удалим DOM-элемент с сайта, то при наличии другой ссылки в JS на этот элемент, он останется в памяти и сборщик не сработает

В этом примере у нас будет утечка памяти. Дело в том, что функция `deleteElement` удалит элемент из ДОМ-дерева, а переменная divBlock сохранит этот блок в памяти страницы – **так делать не надо.** Чтобы исправить ситуацию, нам нужно поместить переменную в такие условия, чтобы после создания она была удалена

![](_png/0d1887b432a27872d110cfbe7f6543da.png)

Сейчас мы убрали лишнюю переменную из глобальной области видимости и создали оторванный от кода объект. При удалении этого объекта – он удалится полностью (и из ДОМ-дерева и из памяти)

![](_png/a378e1816d48275e9f647f44bd7d6ea5.png)

Чтобы решать проблемы с памятью (если такое будет нужно), можно воспользоваться специальным инструментарием в DevTools

[https://developer.chrome.com/docs/devtools/memory-inspector/](https://developer.chrome.com/docs/devtools/memory-inspector/)
![](_png/5228cc8431229dad6e8919280c4a45b8.png)

## 006 () WeakMap и WeakSet


Как мы знаем, сборщик мусора удаляет объекты, на которых уже нет ссылок в проекте. В данном примере ссылка на объект остаётся в массиве и поэтому он не стирается

![](_png/c51bf7b41d8b6a8706da3fa1b8b41b55.png)

Уже в этом примере объект не стирается, так как ссылку на объект хранит в себе карта

![](_png/4dbb49ae73541f61f49e0f854e2a65ba.png)

И дальше у нас идёт объект `WeakMap`. Это объект, у которого

1) ключи – только объекты
2) При отсутствии ссылки на объект извне – объект будет удалён сборщиком мусора
- Если сейчас мы решим проверить значения через `keys()`, то мы получим ошибку, так как таких методов как `keys`, `values` и entries` `– не существует для такой карты. Get, set, delete, has – единственные методы, которые у нас остаются от обычной карты. Поэтому проверим через наличие значения `has()`

Если мы выведем просто карту, то наш интерпретатор не будет понимать, что за объект находится в карте

![](_png/7516b319c6c8eb7703a59a71ec6b3ab0.png)
![](_png/802bf584afd635cc290614e53e34df91.png)

Самый простой пример использования `WeakMap` – это отображение пользователей в онлайне в каком-нибудь чате. Если пользователь offline, то он получает значение `null` и скрывается из онлайна чата.

![](_png/b7683f1adb1f818c36b73a433276d44a.png)

И уже дальше у нас идёт `WeakSet`. Если `Set` хранит в себе только уникальные значения массива, то `WeakSet` хранит эти значения только до тех пор, пока хоть какой-то объект ссылается на них в проекте. `WeakSet` поддерживает только `add`, `has`, `delete`.

Пример реализации прочитанных сообщений. `WeakSet` принимает в себя значения массива с сообщениями. Как прочитать сообщение можно один раз, так и добавить в прочитанные сообщения система одно сообщение может только один раз.

И тут у нас сразу видна такая структура `WeakSet`. В него мы добавили 3 разных объекта. Далее мы обращаемся к наличию третьего элемента в этом сете. Но так как мы из массива удалили первый элемент, то он съехал на одно значение назад и сам виксет теперь имеет только 2 значения вместо трёх, как это было до стирания первого элемента (при стирании объекта из массива все элементы по индексам сдвигаются на один элемент к началу)

![](_png/dc4af9b1bdc059a804a3969f5e72a904.png)


## 007 Работа с датами


Дата задаётся обычно через конструктор `Date()`

![](_png/13e98930ac05f1a337ab0479bd6766d1.png)

Однако можно вписать и цифрами через запятую все нужные даты. Как можно увидеть, месяцы идут с 0, а время идёт по гринвичу. Поэтому при вводе 5 месяц 20 часов, мы получим – 6 месяц (так как он имеет индекс пять) и 17 часов (так как пояс +3 МСК)

![](_png/4494ab9788bb32e64fe592fc05075442.png)

Так же интересно знать, что все даты в JS выражаются в миллисекундах и их можно перевести как в дату, так и обратно в мс. Так же отсчёт времени идёт от 1970 года

![](_png/4dfc1c3d27c7cdf03b499c5a392afeb3.png)
![](_png/9ac9573819367205da04d871640aec31.png)

Так же мы можем быстро посмотреть все нужные методы дат через `get`

![](_png/ea733044dff7d95c58df46e49913ff5b.png)

Так же у нас есть возможность получить два разных часовых пояса

![](_png/2ceb8019a576385094243b65331d765a.png)

Через `set` мы можем установить нужное нам время. Проверять такой код в консоли не получится – это нужно делать сразу в браузере

![](_png/a93f1b94ca607c765e508eb167c295eb.png)
![](_png/dc71e20ae95d54aaaafe279a43910227.png)

Ну и не самая очевидная часть заключается в том, что можно так же вставить и остальные значения времени

![](_png/c827b3006782ba3b46b138e19265b286.png)

Два варианта записи даты: первый обычный, второй через парсинг

![](_png/8b497186d8495f014181fdf9801064cc.png)

Так же дата позволяет сделать таймер и высчитывать миллисекунды между выполнением операций.

Тут было подсчитано время выполнения операции

![](_png/20b1f4b1d773d7f98c89b06549e71294.png)


## 008 Создаем таймер обратного отсчета на сайте


Собственно, блок кода, в котором у нас и происходит всё действо

![](_png/088025292bf1ed6f94d9e10cad3a7057.png)
![](_png/b4c64c6aac059f2c31459e7dcf2375d4.png)

Первая константа хранит в себе конечное время, когда таймер прекратит свою работу. Внутри функции `getTimeRemaining` мы получаем всё время, дни, часы, минуты и секунды по-отдельности (получаем из разницы между нынешним временем и дедлайном) и возвращаем объект с данными значениями

![](_png/b2a25d767fe5b13cfa097db7f2eb4faf.png)

Дальше в функции `clockTime` мы производим изменение времени. Время меняется через функцию `updateClock`, которая вызвается каждую секунду через `setInterval`. Внутри обновления часов мы получаем данные из нашей первой функции и подставляем значения полученного объекта в `innerHTML` наших блоков со временем.

Если время к моменту вызова часов уже уйдёт в минус (например, на дворе уже будет 1ое сентября), то интервал очистится.

Так же для вставляемых значений времени была применена отедельная функция, которая подставляет 0 к числам из одной цифры.

![](_png/875b0bd9fdf1c00b87b240421a1badf7.png)

А вот и сама функция, которая переводит одиночные цифры в двуциферные(да-да)

![](_png/3a4852d574c2458208f15ca671e98b6a.png)

И теперь мы имеем прекрасный счётчик на нашем сайте!

![](_png/8fea9cbc6a745b4096c18151599cab2a.png)


## 009 () Обработка прошедшей даты


Первый вариант починки даты, которая может уйти в минус – это при отрицательной дате не проводит расчёты самой даты, а просто выдать «0»

![](_png/39bc3651fb094579b096253967aa3fd0.png)

Так же можно при минусовом времени вместе с остановкой интервала просто выдать в текстовых блоках нули

![](_png/3f83c79f3550e79e76a73cf591a97cfd.png)

Любой из этих вариантов будет работать нормально и очистит таймер

![](_png/79c4a41584339e216172ce9527edc4dd.png)

## 010 Параметры документа, окна и работа с ними


Есть три основных понятия среди глобальных объектов: `document` (сам документ с элементами), `window` (отображаемое окно, размер которого уменьшается, например, когда мы уменьшаем браузер) и `screen` (весь видимый монитор)

И в первую очередь хочется поговорить про получение размеров элемента через его свйоства, которые мы моежем получить через JS

![](_png/057d4abc724c55c05e9200526da569b7.png)

Пример использования:

Тут стоит отметить, что на получаемые значения так же влияет и тип `box-sizing` (тот же `border-box`, который часто используется на страницах)

![](_png/ecb7df1f714c1b272a93a1137ac8ca19.png)
![](_png/e73fc67f1f9baff42db2d787d68bedc7.png)

Так же мы можем показать полностью свёрнутое окно через свойство бокса, в котором хранится полная высота свёрнутого объекта

![](_png/c24c26b02cca4abc801ff5ea6d8c6078.png)
![](_png/edc081468f9ea554c96b8c86983f18eb.png)

Так же мы можем отобразить свойство JS, которое хранит в себе положение по скроллу в пикселях

![](_png/6ac259fefa407e2e6f259f84b35cbaa7.png)
![](_png/af63c4a84ee9c6c4c373a248af7ce070.png)

Данные методы позволяют отобразить *Computed Styles* конкретного объекта

![](_png/41d33fbe9cc7a8cafa847777eeddc18b.png)
![](_png/e2fac4891df591fe8a94021354c51846.png)

И тут хочется немного прояснить про *Computes Styles* (вычисленные стили). Это стили, которые уже применены на объект. Они могут вычисляться автоматически как `margin: 0 auto`, который под копотом постоянно вычисляется браузером

![](_png/b3e48f2acd6b3eb73577f3b96144b608.png)

И мы можем получить данные стили с помощью JS

![](_png/68da20a369cfadd4d662e2d58dbf4e44.png)
![](_png/efa84af6ebe199c3b1c817963540e515.png)

Такой код и использование метрик относительно объектов позволяет, например сделать быстрый скролл по кнопке от начала страницы к середине (например)

Так же тут стоит отметить особенности обращения к самому документу, так как операции проходят не с самим document, а с `documentElement`

![](_png/a7d00c8fb43922cc067e5222f18444cc.png)

Уже данный метод позволяет проскроллить относительно текущего положения по нужным нам координатам

![](_png/eff3025e41e51590a0a7ef983ea9877d.png)

Второй метод будет уже работать относительно всей страницы

![](_png/e9bd602c5d819092f7e61d5ce1d1c012.png)

## 011 Создаем модальное окно


**Важно!** В HTML есть кастомные атрибуты, которые мы можем задавать самостоятельно. Это атрибуты, которые начинаются на «`data-`» - после дефиса мы можем прописывать свои значения

![](_png/233b85611b625532137d4562c84f5986.png)

Блок кода модального окна (display: none – по умолчанию)

![](_png/27b324136c3eb91936df28a63b3c9ac6.png)

Это кнопка вызова модального окна

![](_png/1865d6134ff88b03a0f4ff591fe36ecb.png)
![](_png/0fcd7f4f150072aaeef0569c587e6c9a.png)

Это код для стоковой странички. Тут стоит отметить, что при вызове модельного окна мы скрываем оверфлоу Так же при использовании в качестве значения для стилей «“”» пустой строки – добавляется значение по умолчанию самим браузером

![](_png/e426fe6cabd1079048368d0c3c6b7435.png)
![](_png/b611df4d183cae7b3c0ccb04518c4610.png)

Если мы хотим сделать отображение или закрытие через тугл, то нужно будет убрать настройки дисплея из стилей и добавить класс хайд изначально

![](_png/2f1ee31b74bf36b417a274d47c3d29ec.png)

Так же будет удобно для пользователя, если мы позволим закрывать модальное окно через клик по пустому пространству

![](_png/32ef0e9e60a35e0ea8016788aa1d6b9d.png)

Так же в плохом коде можно встретить и такое объявление ивента. Дело в том, что ивент уже объявлен внутри обработчика события. Однако такая запись считается плохим тоном

![](_png/6dee5b66ddd18401605618ef9ec3ee35.png)

Ну и добавим закрытие модального окна через Escape. Тут уже нужно проверять кнопку через событие «`keydown`» (кнопка нажата) и параметр внутри «`e.code`»

![](_png/ffd5a3ea4e6d3e772edfd4aa16e86bf4.png)

Чтобы определить нужную нам кнопку, можно воспользоваться уже заранее заготовленными таблицами [кейкодов](https://www.toptal.com/developers/keycode) или нужными сайтами

![](_png/7f7dbabe7d75d2e2e4b4b127c01a3400.png)

Примечание: если бы мы добавляли и удаляли класс с объекта через `add()-remove()`, то нужно было бы дописать ещё и такое условие

![](_png/b0d3899b4ba24f61056f3bd6ada54694.png)

## 012 Модификации модального окна


Сейчас перед нами стоит задача: проявить модальное окно через определённое время либо, когда пользователь прокрутит до конца страницы

Первая задача выполняется крайне просто через `setTimeout` и очистку этого таймаута внутри функции, которая его вызывает (чтобы окно не открывалось, если его уже открывал пользователь)

![](_png/c9d7aed853b25f0c102d2e148e44fa31.png)
![](_png/f409bb277d06e68594352c6c66df51e2.png)

Вот код, который выполняет вторую поставленную задачу. Срабатывание тут устроено немного сложно.

Для решения некоторых багов нужно добавить -1 пиксель от высоты всего документа пользователя

![](_png/c56cec17eb300333a0642f57a00ae4e4.png)

Тут нужно кое-что отметить – нам нужно сделать срабатывание только **однажды**. И первое, что приходит в голову – это использовать настройку для ивент-листенера. Однако проблема заключается в том, что ивент скролла срабатыает сразу, как мы сделали первый скролл на странице

![](_png/bfbc0f3467e1dffbf43cc1a5e4f890a5.png)

Уже такой код позволит нам вызвать ивент ровно один раз в самом конце страницы

![](_png/409ae98b41d84316d331d59d0ca2b582.png)


## 013 (д) MutationObserver, ResizeObserver и contenteditable


Атрибут `contenteditable="true"`позволяет нам редактировать контент внутри определённого блока. Это интересный тег, который позволяет нам менять контент внутри блока

Такой атрибут используют чаще в CMS, когда нужно отредактировать контент на готовой странице. Сохранение данного контента уже выполняет логика бэкэнда

![](_png/33cff78a5a6ecbf1b43fb328bb5e5fa2.png)
![](_png/8f3c71b3c28ee06ae671368fecd64027.png)

И примерно таким образом мы можем задать слежку за элементом через `observer`. Конкретно тут обсервер получает в себя колбэк-функцию, которая хранит в себе рекорды (логи изменений). Далее мы инициализируем слежку через `observe(элемент, выполняемая функция)`

Отключить слежку можно через `observer.disconnect()`

![](_png/e68bf14493b1fe8422593ad8bb535f54.png)

[тут](https://developer.mozilla.org/ru/docs/Web/API/MutationObserver) находятся все опции мутировщика

И теперь мы можем просмотреть изменения элемента.
1) `Observer` срабатывает уже после изменений. Мы работаем с результатом изменений
2) Это асинхронная операция. Поэтому она может выполниться чуть позже или чуть раньше
3) При остановке `Observer`, он так же стирается и сборщиком мусора

![](_png/95e9de6a0bf1e31190b163d4fb5623ae.png)

Так же есть `Perfomance`, `Resize` и `Intersection` обсёрверы


## 014 Функции-конструкторы


Как можно увидеть – новые объекты можно создать через конструктор. Такой синтаксис через `new` означает, что дальше мы будем вызвать конструктор, который создаст экземпляр класса

И так же нужно сказать, что функции в JS – это объекты

![](_png/bc28ab279bd786cf4ec8b637273be01c.png)

И вот пример создания функции-конструктора. Внутри неё мы создаём внутренние переменные данной функции через «`this`» (обращение к самому себе) и присвоение к ним внешних значений. Такая функция создаёт объект

![](_png/ebe84f22ee3f8f29654c28505b35f9c6.png)

Так же мы можем создать внутреннюю функцию, которую можно будет вызывать из всех экземпляров данного конструктора. Так же в прототип можно записать и дополнительные значения (например, функцию, которая будет наследоваться всеми экземплярами)

![](_png/bdcf85f445c137c901a046b5c964ef9e.png)


## 015 Контекст вызова. This


Понимать контекст вызова с «`this`», стоит как присваивание переменной к определённому контексту (функции). То есть любая переменная, которую мы создаём – принадлежит всей области видимости. Если мы создаём переменную с «`this`», то она будет принадлежать только данной области

Так же тут стоит отметить, что при обычном вызове функции с `this` внутри, у нас будет выходить глобальная переменная `Window`. Если мы добавим `“use strict”`, то получим `undefined`

![](_png/ae9d827f0f2347d147d24fb12d90b773.png)
![](_png/938524befd029c90b95b2a12d019fc61.png)

И тут представлен пример, когда мы используем «**this**» и избегаем его. Благодаря «**замыканию функции**» в обычной ситуации (первый скрин) у нас переменные ищутся сначала внутри самой функции, потом поиск заходит в функцию родителя.

На втором изображении уже используется вызов переменной через «`this`» и функция ищет переменную **только** внутри себя и дальше не выходит. Поэтому и возвращается `undefined`

![](_png/7499b9c1090511a01b835bcb6f9cdfd9.png)
![](_png/8d42f9d06a1ce97491ce90a33bfa1f94.png)

> Контекст вызова у методов объекта – это сам объект

![](_png/4d9339a09ed0e386425c44a149c8320b.png)

Уже в данном примере контекст вызова (объект) теряется, так как внутри метода просто вызывается функция

![](_png/8e8edea7f19120616f1c73927f21f4ba.png)

> This в конструкторах и классах – это новый экземпляр объекта

То есть при создании свойства в конструкторе через «`this`», это значение будет присваиваться только созданным экземплярам через данный конструктор

![](_png/030fc814a5bb727308037ab61ed0f243.png)

Ручная привязка `this`: `call`, `apply`, `bind`

Так же мы можем вызывать функцию и подвязать ей контекст вызова через методы `call` и `apply` (оба метода выполняют одно и то же, но по-разному передают аргументы в функцию)

Так же можно сделать много вариаций одной и той же функции, используя контекст вызова и функцию `bind`. `bind` принимает в себя значение «`this`» и возвращает в переменную новую функцию, где `this` заменён на данный аргумент метода

![](_png/2e3132310e41c4898d13dafaeb9655bb.png)
![](_png/4b7a7fa37cb58a153655d89733ab0fca.png)

И когда мы используем конструкцию с `function()` в ивенте мы так же можем пользоваться и «`this`», так как он будет вызывать конкретно наш нажатый объект

![](_png/a17652c3dfb9dfa00837ba43c73f7957.png)
![](_png/e3f83e7ac1b8e80ed30b2196beb66c24.png)

И работать с этим объектом мы так же можем

![](_png/28cb25bfb25adea2052cbdd86324919c.png)
![](_png/a5531352b0c7be6869fd075bdbb288e3.png)

Как помним из примера выше – функция внутри функции имеет свой контекст вызова и поэтому в объекте такая вложенная функция вернёт `undefined`. Но отличительной особенностью **стрелочных функций** является то, что у них **нет своего контекста вызова**. Контекст вызова они наследуют от родителя и поэтому код, приведённый ниже, будет работать

![](_png/96f6de4b8e4aae84b12a4a18abf00903.png)

Ну и так как нет собственного контекста вызова у стрелочной функции, то берём пример чуть выше с `function()` и переделываем его на стрелочную функцию. Работать уже такой ивент не будет, так как контекст, опять же, берётся у родителя

![](_png/6e0f194108da1796b6e625bdb82fddba.png)
![](_png/6dfaf0a8c2ea2ea391763925a5e47911.png)

И чтобы заменить «`this`» в таких функциях, используют таргет ивента

![](_png/790bdc2c5ad0dc6169663b9c638d5314.png)
![кнопка|400](_png/e5bd9e4be27e942a4646530073c27c40.png)


## 016 Классы (ES6)


Классы появились в стандарте ECMA2015. Если нам нужно будет перевести код в старый стандарт, то для этого используются трансплиттеры (тот же babel)

Синтаксис классов немного отличается от синтаксиса функции. Внутри класса обязательно описывается конструктор. Конструктор представляет собой те начальные значения, которые мы задаём концепции экземпляра. Синтаксис достаточно схож по смыслу с функциональными конструкторами

Дальше мы пишем методы класса. Внутри них мы спокойно можем обращаться к тем начальным значениям, что мы задали для экземпляра

![](_png/cfd3fd12bb583146fdd8da9207b06384.png)
![](_png/00acea9ae115532ca2e382f6aa42123f.png)
![Button|400](_png/39a50559144d3fc1067811030ec453a4.png)

И далее у нас идёт синтаксис **наследования**. Он представляет из себя передачу кода дочерним элементам. Реализуется наследование через `extends`.

Метод `super` вызывает код родителя. Помещать его нужно всегда до написания остального кода

![](_png/b1695d2b106989161c8d3e1788d1b923.png)
![](_png/8d758b03cd6ac514d24b5146ebe22f04.png)
![](_png/e1a1581104cdd9a6038b1a8aed5e6894.png)


## 018 Используем классы в реальной работе


Сама вёрстка. Она содержит в себе блок «menu», внутри которого располагаются три `menu__item`, которые и являются нашими карточками

![](_png/4f81f4a65c760e624258e9ce58848c2d.png)

Первым делом мы создаём класс и конструктор, который будет в себя принимать уникальную для каждой карточки информацию. Так же чуть дальше пропишем метод, который будет переводить доллары (единица из БД) в рубли. Вызываем перевод прямо в конструкторе при создании

![](_png/94c6705256c9d1d7ef4298110ddb764a.png)

И дальше у нас идёт самый важный метод, который и выводит саму карточку на страницу. Первым делом мы инициализируем блок, в котором будет находиться карточка. Дальше мы в этот элемент помещаем саму карточку и забиваем её элементы нашими переменными.

В самом конце мы аппендим карточку на страницу через аппенд по родителю

![](_png/b8f03b876f0bcbc341cdcb2dad6de66c.png)

Так же хочется упомянуть, что создать новый объект можно и без его объявления и присвоения в переменную. Конкретно тут, мы не собираемся над карточками проводить никаких операций, поэтому их можно просто создать через `new`. Ну и сразу вызвать метод `render`, который сконструирует блоки на сайте

![](_png/7c511e5f731aa594250698a66e5f7d6f.png)
![](_png/fb157d14341f2da3528bc4cc4417ac8f.png)

Ну и дальше нам нужно создать три этих карты (вёрстку из html нужно будет удалить)

![](_png/9125e3dcf3603770be628cf8e9052d9d.png)


## 019 Rest оператор и параметры по умолчанию (ES6)


В JS есть оператор `spread` – "`…`", который деструктуризирует объект (массив). Однако так же есть и оператор `rest`, который собирает отдельные элементы в один массив – «`…название`»

![](_png/9042d11b9b4b7f544f9cf3ab0e68154f.png)

![](_png/15870e520b6876d880e4e7671777ce0e.png)
![](_png/4226c448957778341ad3a12d3a270d1c.png)

И попытаемся вставить данный оператор в наш проект. Представим, что нужно дать возможность вставить сразу несколько классов на карточку и для этого можно воспользоваться рестом, который вернёт массив этих значений

![](_png/a9826e0435251486d68344f7858f0670.png)

Так же нам нужно внусти изменения в рендер наших карточек. В условии нужно проверить, переданы ли вообще классы и присвоить эти классы (если нет или если их передали). В первом случае, мы проверяем массив, который нам возвращает рест. Если ничего в качестве классов не будет передано, то сработает первое условие (так как рест всегда возвращает массив, даже если значений 0). Если что-то будет передано, то сработает второе условие, которое через `forEach` передаст все нужные значения в качестве класса в наш див-элемент.

![](_png/ae835940937e3ef76b0fa10a39e17087.png)

И сейчас у нас есть возможность не писать классы или написать сразу несколько

![](_png/38a98ad877ea1f9599d1a30ad1c3e6d4.png)

И примерно так это выглядит на странце

![](_png/96c1671d7a0690fe5cfd01809ff84399.png)
