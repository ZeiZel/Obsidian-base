## **04 Продвинутые типы**
### **020** **Union**
- Юнион – это способ определения типа данных, когда мы в переменную можем поместить один из перечисленных через «|» типов данных

Сразу хочется отметить, что при использовании такого типа данных, в обычных условиях, компилятор не понимает, что в нём находится и не предлагает нормальный автокомплит
![](_png/72a0b41fb35da90df4f7f93e584dc54b.png)
- Сужение типов. Для того, чтобы использовать методы строк, или чисел, или булеана, нам нужно сузить типы, с которыми мы работаем (потому что юнион объект – это ни рыба, ни мясо)

Сузить можно через условие, в котором мы пропишем, что оно будет срабатывать при равности типа указанному
![](_png/3e163e33e5577c0d3625c318150fb34f.png)![](_png/77ad82e506419c8cee6160916b2030f4.png)
- Так же можно увидеть, что мы исключили возможность того, что тип может быть строчным и компилятор нам показывает, что нынешний аргумент у нас либо число, либо булеан значение
![](_png/18bd84223ca64c86a8ec161a2bfb5935.png)
- Больше примеров богу примеров. Это пример выборки либо строки, либо массива из передаваемых типов
![](_png/29d8f89bdcce411b395cb5e76a4cbcde.png)
- А вот уже пример с типизацией объектов. Тут мы можем проверить в придачу в принципе наличие определённого ключа в объекте + его типа и обработать это всё
![](_png/8682c4f2dba4b88b47bd684aff6ac211.png)
- Ну и так же мы можем проверять два разных типа на разные действия при их соответствии
![](_png/166ca0d893c170a31409daa35ee40dc6.png)
### **021** **Literal** **Types**
- Литеральные типы данных – это типы данных, которые выражаются в определённых значениях. Эти типы определяют, что будет находиться в этой переменной. По умолчанию константы имеют тип данных равный значению. Если let присвоить литеральный тип данных (например, 1), то и хранить сможет только число «1»
![](_png/18fec13ea59ffbba06c5a8cbdd7adb08.png)![](_png/1ef02bed2efccb02082510814adc4568.png)
- Используются литеральные типы, чтобы не делать на каждый чих енамы
![](_png/334da118c6688e4dbd34535deda9acde.png)
- Литеральные типы принимают в себя только значения, которые мы зададим для этих значений. Так же мы можем задать фиксированные значения на получения таковых из функции
![](_png/58a015b9655e505395ff7839c192e376.png)
- Однако тут нужно так же и помнить, что при отправке тех же данных в функцию, где аргумент имеет литеральный тип, может привести к неочевидным результатам. Если мы захотим отправить не чистый аргумент, а переменную, объявленную через let, то мы словим приколыч, так как у нас сравниваюся типы при отправке (аргумент ведь имеет только два типа – тут пост и гет). Лет тут является стрингой, а стринга не является постом или гетом
![](_png/57d4952265bc0e76a22d5d8d4f0d3807.png)
Чтобы исправить ситуацию, нужно будет поменять лет на конст и тогда значение автоматом присвоится в тип данных переменной
![](_png/03ffb82570d62dadeaf7f176db148ea3.png)
Либо можно кастануть переменную и задать ей определённый тип данных. Это уже стоит делать только в том случае, если мы данные получаем не из переменной, а из объекта. Делается каст через оператор «as»
![](_png/786b0ef0fe42bafbee6882ef68ced576.png)
Однако берём в учёт, что мы не должны использовать каст в роли фикса от ТСки. Используем только по надобности, когда нет возможности привести типы
![](_png/a0e1167f6a673009dccccc28c2556099.png)
### **022** **Type** **Aliases**

- И вот пример тайп элиаса (псевдонима). Через ключевое слово «type» мы можем как обычную переменную задать любой тип и использовать этот псевдоним
![](_png/de38073a69d2533e4f3a73d3e95517d7.png)
- Элиасы позволяют сократить достаточно сильно код и делать свои шаблоны типизированных объектов. На первом примере стандартное объявление одного объекта. На втором примере можно увидеть тайп элиас (с помощью которого можно объявить сразу несколько новых объектов)
![](_png/a07838f9fc84b7d2ac998955a29f6672.png)![](_png/3d84b9c3ceb1893a78a024422cc205ac.png)
- Так же есть и интерсекшн типы. На первом скрине можно увидеть, как были соединены два типа через юнион **«|»** и теперь мы можем запихнуть в объект либо первый тип, либо второй, либо все вместе. Уже оператор **«&»** определяет интерсекшн, который говорит нам, что в данной переменной должны находиться сразу оба типа вместе и никак иначе

Интерсекшн откидывает повторяющиеся поля
![](_png/d016611580019fded512dfb28fffb4db.png)![](_png/a5dd7273c4ac153f3f757e446f0bc99f.png)
### **023** **Interfaces**

- Интерфейсы – это технология, которая позволяет записать типизацию объекта в виде подобным классам. Так же интерфейсы экстендятся как классы (в тайпах нужно было использовать интерсекшн)
![](_png/d062fc79c7c221f4eea6df8bffdac704.png)
- Пометочка: функции так же можно вписывать и в тайпах
![](_png/5d86adbcea1ce574572a89b082941db6.png)
- Уже таким образом мы можем создать объект-словарь

1) Неопределённое количество свойств – [наименование: тип]

2) Значение – тут Юзер

Однако словари создаются обычно через третью запись (дженерик)
![](_png/09d9a8f205f9b4881d7d9fb5fbf34154.png)
### **024** **Types** **или** **Interfaces**

- Первой отличительной особенностью интерфейсов является их возможность мёрджа. Если мы объявим два одинаковых интерфейса, то они слипнутся и будут себя вести как один интерфейс
![](_png/3b0ada4a0c90abd1286a76ae75431fb2.png)
- Так же тайпы крайне просто работают с простыми типами и позволяют их быстро задать. Интерфейсы же подходят только для работы с объектами
![](_png/de065232a86df2563167255ad7e15276.png)
- Если подытожить, то для создания объектов стоит использовать интерфейсы. Они чаще используются так же вместе с классами. Тайпы стоит использовать для простых типов и быстрой реализации

### **025** **Optional**

- Оператор «?», который мы пишем сразу после наименований ключей, свойств, аргументов и так далее говорит нам о том, что этот параметр не обязателен.

Конкретно в примере с интерфейсом нам не обязательно теперь в объекте подобного типа указывать свойство пароля. И, как можно было подумать, записать без «?», но пометить, что свойство должно быть андефайндом мы не можем (в объекте придётся явно указать, что значением будет андефайнд)

В функции же «?» говорит, что нам необязательно передавать такой аргумент. Однако в функции мы уже можем указать, что второй аргумент может быть неопределённым типом и это будет работать подобно «?»
![](_png/1c9ab20a6ed3d1febc54b0e6fd4e55ef.png)
- Так же нужно упомянуть, что при обращении к свойству объекта с «?», нам нужно обязательно прописывать опциональный чейн, так как значения может и не быть (ТС выдаст ошибку в компайл-тайме)
![](_png/acf97b5119423a0747cf4000106a31c2.png)![](_png/44782458a9beeacaf0a9347df138441f.png)
- «!» – этот оператор, в свою очередь, говорит, что мы точно знаем, что вернётся не undefined, а именно наше значение, которое было задано нашему объекту
![](_png/8552c9e22c205f77e38c2aef42cebc20.png)
- Так же мы можем устроить проверку и через короткую запись
![](_png/2cf3d434112a6e0fc211b161b1ec75d8.png)
- «??» - оператор, который проверяет на null или undefined. Конкретно тут используется такая конструкция, так как парам – это опциональный аргумент и его мы можем не передать, а значить проверить на его наличие нам нужно
![](_png/d9faaff80a7731136cccb95b1cf28a73.png)
### **026 Упражнение - Типизируем ответ сервера**

- Это первый способ типизации. Он имеет небольшие минусы в виде того, что нам нужно будет как-то разделять успешный запрос от неуспешного
![](_png/dd29a0d6c1f063bf445a90d0391f0fca.png)
- Это уже более удачный вариант запроса, который поделен на два разных интерфейса
![](_png/53474d38567e87aec41e5242aa7263c5.png)
- И вот примерно так реализуется вывод удачного и неудачного запроса на сервер (функция возвращает объекты по типу этих двух интерфейсов)
![](_png/3d724c87e7ac43b7b9da4d73a122b7f0.png)
### **027** **Void**

- **void** – это особый тип данных, который нам говорит, что функция ничего не возвращает. Функция может возвращать какое-либо значение, но мы ни в коем случае не будем его принимать и не будем ничего возвращать. **void** **!=** **undefined**

Конкретно в этом случае, константа «а» будет иметь тип войд
![](_png/fdf13c218c37181b5bf8e9bdb2f928b7.png)
- А уже в этом примере вернётся хотя бы undefined
![](_png/74b00ca62a4d460782e5487d58079bb3.png)
### **028** **Unknown**

- unknown – это более строгий тип any. Он запрещает себя присваивать в другие типы, которые не являются такими же unknown или any. Используется этот тип в тех случаях, когда мы не знаем, что за тип нам предстоит получить в переменную. И вообще, когда не понятно, что мы получаем, этот тип стоит вставлять
![](_png/c359f7193830ce44aeab1130f3e6e1e6.png)![](_png/001b5549579e36aa066e31340039e5b5.png)
- Привычное сужение типов указать для переменной не получится (в одном условии получится указать тип, но в остальных так же останется unknown)
![](_png/073c213aa7045b3f8907613e3fbee2ef.png)
- Ну и дальше идёт кейс по ошибкам. Раньше еррор имел тип эни, но с версии «4.4», еррор – это непонятный тип. Теперь чтобы работать с ошибкой, нужно добавлять дополнительную конструкцию, которая будет проверять нам, что мы работаем конкретно с ошибкой

1) Проверяем ошибку по инстансу объекта

2) Делаем проверку через присваивание переменной к ошибке (не самый лучший вариант)
![](_png/42bb4f7ac57dd3bf43c639aa5e2f4636.png)
- И тут нужно пояснить, что или «|» выбирает тип для переменной из более общего значения (всегда будет unknown), а «&» выбирает самое меньшее (string более конкретный тип данных)
![](_png/2b9afe6b638529c524fb379b3e860389.png)
### **029** **Never**

- И как можно увидеть по первым примерам, тип данных **never** говорит нам, что функция никогда не возвращает значение. Объекты с таким типом абсолютно никогда ничего не возвращают и ничего возвращать нельзя
![](_png/8b4ce1fe9fb5bc98d8a00fd7eacdd9d4.png)
- Если void вполне себе может хранить undefined, так как войд – это отсутствие значения, то невер запрещает возвращать значение
![](_png/ad36374c7cac1d9ed33cf91b737d189d.png)
- И вот первый кейс, где можно использовать тип невер. Он позволяет показать, что программа не заходит в данную ветку

Тут нужно пометить, что если константу назвать «_», то компилятор не будет ругаться на то, что в ней нет значений
![](_png/857d3b84e32cdcaa1ffae809deb5269d.png)![](_png/a33bfd66ae360b0b4002766d6ef495ca.png)
- И тут представлен пример, когда мы явно задаём аргументу типы строки и числа. На выходе мы должны получить булеан значение. Внутри функции мы проверили получаемое значение и видим, что компилятор говорит нам, что может вернуться из функции «undefined» (если нет ретёрна, то функция возвращает андефайн, тут - третий ретёрн)
![](_png/d34dfa9be152772d7ba8e9bf5c3c9a88.png)
Однако, если мы добавим срабатывание функции, которая будет иметь тип невер (никогда ничего не возвращается), то наш третий андефайн будет закрыт этой функцией
![](_png/feb61e76d538e47ecdf13703c8a668bb.png)
- Невер используется для явной блокировки определённых веток выполнения программы

### **030** **Null**

- Первым делом нужно отметить, что в ТС нельзя (в отличие от нативки) присвоить любому типу налл. Мы это можем сделать только изначально наллу или для эни.
![](_png/9b98266dd008c64d18a199d3c6569c3d.png)
- Однако это спокойно настраивается из под настроек компилятора ТС
![](_png/7fdef6d2186f859ec22095a0779225a3.png)![](_png/2b968666d2e63e328c239721df80b9e0.png)
- Однако эту проверку убирать не стоит. Она может во многом помочь.

Конкретно в данном коде мы возвращаем с вероятностью в 50% либо пустое значение, либо объект (который возвращаем в качестве юзера, так как мы не задали тип для функции)
![](_png/03622a27a3215db616cc4982e7b1c3c1.png)
- Однако стоит разграничить между друг другом эти понятия: null и undefined. Первый мы используем осознанно (подставляем самостоятельно) и не можем получить в результате выполнения кода JS. Второй же мы можем получить в результате выполнения кода JS

И примерно так уже должна выглядеть правильное написание кода, когда мы точно знаем, что можем не вернуть значение и впоследствии проверяем на это
![](_png/a641977b8c0a9779745d712208e9d086.png)
### **031 Приведение типов**

- Обычное приведение типов в нативке
![](_png/e167c01d96a83f5d0c15941c01049713.png)
- Тут нужно отметить, что при создании новой переменной через интерфейс конструктора, тип данных будет не «string», а «String»
![](_png/8a6f10d2e8abd0fc860bf367e18b617f.png)
- Типизирование объекта тремя способами:

Последний способ лучше не использовать – он будет конфликтовать с Реактом
![](_png/146d9c4c39c50a719ab0870dfd1655be.png)![](_png/d1272efa9afd0ce069d2bc0b62ceb838.png)
![](_png/a0c60b77eae7e11df2f61b704f0112e1.png)
- И так же тут представлен пример создания отдельного пользователя через деструктуризацию прошлого объекта. Однако тут у нас получится объект шире, чем изначальный
![](_png/c3ee9cccedfa407d18d3ebdbf9cdbfee.png)
- Рекомендуется возвращать объекты через функцию (тогда в админе останутся только данные свойства)
![](_png/87767426714f20e12a3bb9c9ea52d924.png)
### **032** **Type** **Guard**

- Это представлено обычное сужение типов, через которое мы можем обратиться к нужному нам типу определённого значения
![](_png/9f471ad27f6c285cfc2df3f5d409bce8.png)
- Тут уже показана реализация тайпгуарда. Он всегда возвращает нужный нам тип объекта (проводит проверку на тип). По сути своей он заменяет нам работу булеана на более прозрачную и показывает нам точно, что должна вернуть такая проверка
![](_png/0e6f360f67d2c254bdd8a1d00104bcd3.png)
- И вот пример, где мы создали гуардиана для более сложного типа данных
![](_png/977e8e8ca258d1e08a9a49ef5baa91ab.png)
- А уже тут проверка идёт через присвоение юзера к админу и если у юзера имеется нужное нам свойство (не = андефайнду), то вернётся админ (нужный интерфейс)
![](_png/ce8a45448f04ad4d6c1176819b761be9.png)
### **033 Упражнение - Делаем typeguard ответа**
- Отправная точка написания кода
```TypeScript
interface IPayment {  
   sum: number;  
   from: number;  
   to: number;  
}  
  
enum PaymentStatus {  
   Success = 'success',  
   Failed = 'failed',  
}  
  
interface IPaymentRequest extends IPayment { }  
  
interface IDataSuccess extends IPayment {  
   databaseId: number;  
}  
  
interface IDataFailed {  
   errorMessage: string;  
   errorCode: number;  
}  
  
interface IResponseSuccess {  
   status: PaymentStatus.Success;  
   data: IDataSuccess;  
}  
  
interface IResponseFailed {  
   status: PaymentStatus.Failed;  
   data: IDataFailed;  
}
```
- Задание. Написать функцию, которая будет возвращать число (id ответа от респонса)
```TypeScript
type f = (res: IResponseSuccess | IResponseFailed) => number;
```
- Решение. Сразу хочется сказать, что это излишний код для проверки свойства
```TypeScript
type res = IResponseSuccess | IResponseFailed;  
function responseChecker(res: res): number {  
   if (responseGuard(res)) {  
      return res.data.databaseId; // в фейле нет свойства databaseId  
   } else {  
      throw new Error(res.data.errorMessage); // только в фейле есть свойство ошибки  
   }  
}  
  
function responseGuard(res): res is IResponseSuccess {  
   if (res.data === "IDataFailed") {  
      return true;  
   }  
   return false;  
}
```
