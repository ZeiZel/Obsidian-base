---
tags:
  - FP
  - javascript
  - functions
  - procedures
---



## Основные определения

Функциональное программирование (ФП) - это такая же, как и ООП, парадигма разработки. Она предписывает концепции, которыми мы должны пользоваться во время разработки.

ФП не построено поверх функций - мы пользуемся программным кодом, как математическими функциями

### Распространённость

Есть языки, которые находятся только в рамках одной парадигмы: 
- ООП
	- Java
	- C#
- ФП
	- Haskell
	- Lisp
	- F#

Но так же есть и мультипарадигменные языки, как JS

JS - это мультипарадигменный ЯП, кооторый поддерживает как императивный, так и функциональный стили.



---
## Базовые концепции ФП

Процедура - это блок кода, который выполняет набор заданных действий. 

Функция - это блок кода, который возвращает результат. Обычно, это результат каких-то вычислений. Внутрь мы передаём данные и получаем неизменный от раза к разу результат.

### Декларативность

Есть в программировании глобально два подхода:
- Императивный -> Как хотим получить? -> Описываем действия
- Декларативный -> Что хотим получить? -> Описываем результат

В основе всего всегда стоит императивный подход, на базе которого создаются декларативные

Императивная функция

```JS
const arr = [1, 2, 3, 4, 5, 6];

function getEvens(arr) {
	const evens = [];
	
	for (let i = 0; i < arr.length; i++) {
	  if (arr[i] % 2 === 0) {
	    evens.push(arr[i]);
	  }
	}
	
	return evens;
}


console.log(getEvens(arr)); // [2, 4, 6]
```

А уже поверх императивных функций, мы можем строить декларативные, в которых мы просто будем описывать действия, которые должен выполнять код

```JS
const arr = [1, 2, 3, 4, 5, 6];
const evens = getEvens(arr)
console.log(evens); // [2, 4, 6]
```

>[!success] Декларативность - это свойство любого хорошего кода. Нужно стремиться реализовывать максимум абстракций над низкоуровневыми операциями.

### Чистые функции

Чистая функция — это такая функция, которая всегда ведет себя предсказуемо и не влияет на внешнее окружение.

Основные признаки чистых функций:

- детерминированность - при одних и тех же входных аргументах всегда возвращает один и тот же результат
- отсутствие сайд-эффектов - не изменяет внешние переменные, не работает с сетью/файлами, не пишет в консоль, не влияет на состояние вне самой функции
- не использует и не изменяет состояния вне своих аргументов - не опирается на глобальные переменные, не мутирует их

Эти функции при одних и тех же значениях всегда будут возвращать одинаковый результат

```JS
function add(a, b) {
	return a + b;
}

function multiplyBy2(arr) {
	return arr.map(x => x * 2);
}

function isEven(n) {
	return n % 2 === 0;
}
```

А уже эта функция зависит от внешнего состояния и не является чистой

```JS
let counter = 0;

function increment() {
	counter += 1;
	return counter;
}
```

### Иммутабельность

Иммутабельность (неизменяемость) — концепция, согласно которой данные после создания не изменяются. 

Вместо изменения оригинального объекта создается его новая копия с нужными изменениями. 

Преимущества такого подхода:

- Предсказуемость - нет скрытых изменений в других частях программы
- Упрощает отладку и тестирование
- Легче работать с историей изменений (например, undo)

Проблемы мутабельности:
- данные будут несогласованными в разных местах кода
- будут происходить неявные побочные эффекты
- усложнится дебаг и тестирование кода

#### Примеры

Если нам нужно изменить массив по своим критериям, то лучшим вариантом будет создать новый массив

```JS
const arr = [1, 2, 3];
const plusOne = arr.map(x => x + 1); // [2, 3, 4], arr не изменился
```

Если нам нужно добавить значение в массив, то так же лучшим вариантом будет создать копию прошлого и добавить уже в него новое значение

```JS
const arr = [1, 2, 3];
arr.push(4); // arr теперь [1, 2, 3, 4] — оригинальный массив изменился!

const arr = [1, 2, 3];
const newArr = [...arr, 4]; // arr остался прежним, newArr — [1, 2, 3, 4]
```

#### Проблемы

В JS мы используем ссылки на объекты и массивы, поэтому при обращении к ним, мы воздействуем с корневым объектом, а не с его копией

Опасно использовать методы:
- `sort`
- `splice`

Нужно использовать:
- `toSorted`, копировать старый массив и сортировать его `[...arr].sort`
- `immer` / `immutable js`
- map, filter, reduce

### Функции первого класса и высшего порядка







- Декларативность
  - Описываем *что*, а не *как*
  - Примеры: сравнение императивного и декларативного кода (filter, sort, reduce)
- Чистые функции
  - Определение: результат зависит только от входных данных
  - Критерии: нет сайд-эффектов, не используют внешние переменные
  - Примеры: умножение — чистая функция; random — нечистая
  - Сайд-эффекты - Внешние действия: запросы, мутация внешней переменной, изменения UI
- Иммутабельность данных
  - Работать с копиями, не изменять оригинал
  - JS-примеры: методы `map`, `filter` — иммутабельные; `sort` — мутирующий
  - Важность глубокого клонирования при работе с объектами
  - Плюсы/минусы мутабельности и иммутабельности
- Функции первого класса, функции высшего порядка

## 
- **Функции первого класса**
  - Можно передавать, возвращать, сохранять как объекты
- **Функции высшего порядка**
  - Принимают/возвращают другие функции
  - Встроенные примеры: `map`, `reduce`, замыкания, мемоизация, debounce/throttle

## Композиция функций
- **Compose**
  - Сборка сложной логики из простых функций
  - Реализация композиции: вызовы справа налево
- **Pipe**
  - Альтернатива compose, вызовы слева направо

## Каррирование и частичное применение
- **Частичное применение**
  - Привязка части аргументов заранее
- **Каррирование**
  - Пошаговая подстановка аргументов; создание нового варианта функции на каждом этапе
  - Реализация на JS (пример с логированием)

## chaining — цепочки вызовов
- Сценарии: вызовы методов массива подряд, промисы (then chaining)

## Контейнеры, функторы и монады
- **Контейнеры**
  - Простейшая структура-обертка для значения
- **Функторы**
  - Контейнеры, поддерживающие `map`
- **Монады**
  - Дополнительные операции: `flatMap/chain`
  - Примеры: `Maybe`, `Either`, `Promise`, `Writer`, `Future`

## Аппликативные функторы и спецификация Fantasy Land

- Стандартизированные интерфейсы для контейнеров, функторов и монад в JS



---
## Итоги

- Декларативность, чистота функций, иммутабельность и функции высшего порядка — основа гибкости ФП.
- В JS доступны и базовые, и продвинутые ФП-практики.
