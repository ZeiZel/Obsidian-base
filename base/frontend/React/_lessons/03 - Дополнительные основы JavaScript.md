## 002 (д) Оператор нулевого слияния (Nullish) ES11

И тут у нас представлен код, который изменяет размер элемента.
Как мы видим, перед нами встаёт проблема: нам нужно проработать ситуацию, когда значение пользователь не передал. Чтобы быстро решить проблему с тем, что нам нужно заменить отсутствующее значение на значение по умолчанию, можно внутрь `${}` поместить быструю проверку, которая будет срабатывать в том случае, если переданное значение будет иметь: `null`, `undefined`, `0`, `null`, `NaN`.

Сейчас мы можем не передать неверное значение или не передавать его, но встаёт другая проблема: а если нам нужно передать 0?

![](_png/6aa947d5bf572406364d5a1edbe10fcb.png)

В ==JS== есть оператор ==Nullish==, который возвращает результат в любом случае, кроме `null` и `undefined`

То есть, если `username` существует, то выведем `User`, в противном случае, то, что идёт дальше. И только в последнем случае `username` существует, поэтому выводится он (его значение)

![](_png/96b56240dba010b91d1a685df12956c0.png)

И тут мы уже поправили логику программы. Теперь она может принять в себя `0` и выдать нужный результат. Так же можно использовать данный оператор в математических операциях

![](_png/edd5fef9862977cf8e178120ad11af53.png)

Нулиш операторы нельзя использовать вместе с логическими операторами

![](_png/f83e8f0e5e3970e2f2f7983119c1a821.png)

## 003 (д) Оператор опциональной цепочки (.) ES11

Оператор опциональной цепочки проверяет значение слева от него. Если оно имеет значение `null` или `undefined`, то выполнение после оператора останавливается.

В данном случае, нам нужно вывести контент блока, если тот существует. Чтобы сделать это обычным способом, нам нужно использовать конструкцию с `if` (потому что без проверки выпадет ошибка). Но можно сократить её и просто поставить `?.` после этого блока, проверяя его

![](_png/f693039e5b26dc80422db48d42bd1a66.png)

![](_png/86197f4d5d56c27cff8dd4219fe8b340.png)

Однако проверка не работает на присвоение значения

![](_png/7e2560b02f8d7f639ee3a192623444de.png)

![](_png/9b1197097b24f396d8bdd132db624820.png)

Пример реального использования такого оператора. К нам пришло много огромных объектов от сервера и нужно всех их обработать. Нам нужно достать по элементу из каждого объекта, коих тысячи (а ведь в каком-то из них может и не быть нужной вложенности). Чтобы проверить наличие объекта для вывода и чтобы ничего не поломалось, мы должны прописать огромное условие на наличие каждой вложенности в объекте.

Мы можем избежать насилия наших мозгов и просто вставить оператор `?.` там, где мы не уверены в наличии объекта в принципе (а он мог и не прийти)

![](_png/6a5cc5138db10ffc930d76ddad51053c.png)

Однако стоит отметить, что оператор нужно ставить только там, где предполагается ошибка. Дело в том, что сайт может начать ломаться, а найти проблему будет, благодаря операторам, сложно

Так же можно проверять наличие определённых методов через полное написание `?.`. Использовать его стоит только для проверки потенциально несуществующих функций (хотя ==WebStorm== явно укажет на существование функции в проекте)

![](_png/899fb818c692057464de86449c4a5875.png)

## 004 (д) Живые коллекции и полезные методы

В консоли мы видим коллекции, которые были созданы благодаря `querySelector` и `getElementByClassName`

```JS
const boxesQuery = document.querySelectorAll('.box');
const boxesGet = document.getElementByClassName('box');

console.log(boxesQuery);
console.log(boxesGet);
console.log(document.body.children);
```

![](_png/499276c03c891653b787b18b116f8675.png)

И сейчас перед нами встаёт разница между живыми коллекциями и статическими.

Современный способ обращения к объектам представляет из себя статическую коллекцию, которая статично хранит в себе состояние DOM-дерева. Старый способ обращения к объектам отображает текущее состояние DOM-дерева

```JS
const boxesQuery = document.querySelectorAll('.box');
const boxesGet = document.getElementByClassName('box');

boxesQuery[0].remove();
boxesGet[0].remove();

console.log(boxesQuery);
console.log(boxesGet);
console.log(document.body.children);
```

![](_png/880185a67ec6e0f492942291fdb8694f.png)

И встаёт иногда такая потребность, чтобы следить за состоянием DOM-дерева в течение его жизни. Мы можем сделать массив из данной коллекции, но тут уже встаёт проблема: массив – это уже статичный объект и следить за DOM-деревом не получится

```JS
// генерируем массив из псевдомассива элементов страницы
console.log(Array.from(boxesGet));
```

![](_png/56c0128e769ca11bc1ff078b7d9b2362.png)

Тут мы добавляем дополнительно пять боксов через цикл

![](_png/9f9f5091c6ac58f8eb17a7b7ee55b491.png)

И тут представлены два метода, которые можно применять на псевдомассивах.

1. `matches()` – принимает в себя селектор и при его нахождении в объекте возвращает `true`
2. `closest()` – принимает в себя класс и выводит ближайший родительский элемент с таким классом.

Мы имеем структуру: `wrapper > innerWrapper > box`. И при поиске враппера выведется вся эта структура

![](_png/69d1fbeddcc313c1271919fe4a38bc2a.png)

## 005 (д) Тип данных Symbol

Символы используются для создания уникального идентификатора – они уникальны и неизменяемы

В качестве ключа у нас всегда используется строка. Мы можем записать её как в кавычках, так и без. Кроме **строк** свойствами объектов могут быть ещё и **символы** – _и только эти два типа данных_

```JS
const person = {
	'name': 'Alexey'
};
```

Символы – это всегда уникальные идентификаторы (даже если есть идентификаторы с одинаковыми значениями). По точечной записи обратиться к ним нельзя. Создать через `new` – не получится

![](_png/9d1212a41238bb264fb596e6987054f1.png)

Символы позволяют создать скрытые при обычном доступе свойства, которые не показываются при переборе объекта

![](_png/df7732e4723ade6495883eff8901264e.png)

Получаем значение ключа:

![](_png/93ed1545cd14531c3089cb7cfa581c36.png)

Получаем сам ключ:

![](_png/82c81577ead204b5f400e08bd4812ab5.png)

Мы можем написать отдельный метод через `this[]`, чтобы получить символ из объекта

![](_png/4b09c50ad7a16dd00600c65901e667cc.png)

И так же есть отдельный метод, который позволяет получить массив символов из объекта

![](_png/91239001a590d15fb5c7b34c0c2aa664.png)

![](_png/62530548996fd1c3690daea8b04b3c9b.png)

Основная причина создания символов – это защита данных. Символы исключают возможность перезаписи нужных данных в объекте. Когда в проекте огромное количество строк кода и множество библиотек, то сложно будет уследить за тем, не будут ли перезаписаны нужные нам данные

![](_png/22329ed755538018a3d047b56f35c77e.png)

Тут мы записываем ключ `id` в объект, но не меняем при этом символ `id`

![](_png/bf65c7ad4bfa15a4f3e31517caf40474.png)

Когда мы формируем символ через синтаксис `Symbol.for(‘id’)`, то у нас формируется глобальный реестр символов и теперь это описание не будет уникальным

![](_png/6d5fc0f17eb1c6c94cd7cfc3611463eb.png)

Есть и обратный метод, который получает ИЗ глобального реестра значение

![](_png/4174e11a2b7991f17449f224a8d38803.png)

## 006 (д) Дескрипторы свойств и полезные методы объектов

Дескрипторы определяют как работают свойства. Ещё они называются флагами:

- `writable(true)` – свойство можно изменить. `False` – свойство только для чтения
- `enumerable(true)` – свойство будет перечисляться в циклах
- `configurable(true)` – свойство можно удалить, а его атрибуты можно будет изменить

Для всех создаваемых свойств они всегда имеют значение `true`

Через метод отображения дескрипторов `getOwnPropertyDescriptor` ОДНОГО свойства (есть метод `getOwnPropertyDescriptors`, который выводит дескрипторы для нескольких свойств) можно отобразить ключ-значение и его дескрипторы

![](_png/b190a3113f8a422d3026b23f8c13b766.png)

Через `defineProperty()` мы можем поменять значение флага

![](_png/f8237677173306294e2bcf3c8a901086.png)

Если мы создадим свойство через `defineProperty()`, то по умолчанию все флаги будут иметь значение `false`

![](_png/bec09323688948ee206358be89d6d927.png)

И тут мы запретили изменение значения свойства объекта

![](_png/0a91df07257a2b98e0e616cc64201a4d.png)

А тут мы создали это свойство через промпт и оно сразу имеет все значения в `false`

![](_png/df420124c7f049548e4be409d7f63a78.png)

И так же можно прописать нужные флаги отдельно при создании свойства

![](_png/cb2931e91ead9e3d14a2351b97d76329.png)

И тут уже показан пример как скрыть метод в объекте через `defineProperty()`

После того, как свойство было установлено, оно уже не будет реагировать на данный метод и поменять его буде невозможно. Поставить так флаг – это дорога в один конец

![](_png/9a0c5360754c5e8e43aab69d5eb29e23.png)

Через `defineProperties()` мы можем поменять флаги сразу для нескольких значений объекта

![](_png/c9b3b636923b3a22eb378b70a939cbe8.png)

И так же стоит отметить и символы. Даже при положительных значениях флагов они работают ровно так же, как и при отрицательных. Они не отображаются при переборе и им нельзя придать другое значение

![](_png/0cf754ec0d1b73ba586becdcff9149b3.png)

![](_png/18b7f4edc20a5971dcf4e222020f80ea.png)

И вот все методы объектов, которые по-хорошему нужно знать

![](_png/5129a930e78c57555a3a435a33387495.png)

## 007 () Итерируемые конструкции

Кратко повторим конструкцию `for-in`. Она проходится по всем элементам объекта (массива). Однако его главная проблема в том, что он может проходиться не по порядку

![](_png/28988acd8472ce9e0f83441b1c503e53.png)

Когда мы говорим уже про конструкцию `for-of`, то она сразу уже выдаёт значение. Однако может выдать значение только итерируемого объекта. То есть перебрать массив или строку через `for-of` - возможно, а уже при переборе объекта выйдет ошибка, так как объект – это неитерируемая единица.

Основной плюс `for-of` заключается в том, что он выведет все значения из массива именно в том порядке, в котором они записаны.

![](_png/2314b84065633c27b2544d52d5709b73.png)

И тут опять же можно увидеть, что `for-of` перебирает только те значения, которые являются собственными (проверить можно через `hasOwnProperty()`)

![](_png/63cadcccf867561e0c47d7b2d353ba02.png)

![](_png/d1a7fab26d20a09f26845ee909f4a3f8.png)

Грубо говоря, итерируемые объекты – это те структуры, которые хранят в себе символ-итератор

Итератор – это метод, который возвращает объект с методом `next()`

Чтобы перебрать объект, нужно ему добавить итератор самостоятельно

Когда мы используем `for-of`, то он вызывает этот прописанный метод (на скрине) 1 раз и этот метод должен нам вернуть итератор (а именно объект с методом `next()`). И дальше `for-of` будет работать с тем объектом, который вернулся из этого метода.

Внутри метода находится само отображение выполнения возврата значения и само значение

![](_png/bf6532d0e90b3094cf43999229b9167c.png)

И тут уже более подробно опишем:

Мы имеем объект `salary`. После него мы создаём через символ наш итератор. Итератор хранит в себе функцию. Функция возвращает объект, внутри которого имеется несколько свойств и метод `next()`.

Метод `next()` в себе имеет определённую логику – тут мы остановим выполнение цикла только тогда, когда внутри объекта первое свойство будет иметь значение больше, чем последнее.

Цикл будет продолжаться, пока возвращаемый `done` будет иметь значение `false`. Чтобы передать значение в следующий цикл, нужно передать его через `value`. Останавливается цикл через `done: true`

Тут ещё нужно отметить, что функция должна иметь вид: `function(){}`. Стрелочная работать не будет

![](_png/4b2cd6540c94cd35b6d64ca8ce231c7a.png)

И вот через `for-of` наконец-то мы можем перебрать объект. Однако перебор будет выполнять определённую логику

![](_png/fce6afced2eb24d0e71398cc3923f55f.png)

Так же такой итератор можно вызывать и вручную. Мы можем присвоить итератор в переменную и так как это метод, то его можно вызвать сразу через `()`

![](_png/afd15ec65c9c4bbb0a533fb8f00e2323.png)

## 008 () Map

Тут хочется пояснить, что в качестве ключа объекта всегда используется строка. Даже если мы напишем число, то оно переведётся в строку. Однако, если вставить `{}` объект, то мы получим ошибку

![](_png/7525d7e1efd424ab6edd1081dd5ae27a.png)

`Map` – это специфический тип данных, который выглядит как объект, но по-сути может представлять из себя и массив, и строку, и число и любой другой тип данных

Тут можно увидеть, как `map` используется для создания объекта, у которого в качестве ключа используется объект

![](_png/97c0199554de4642b3cf47a52d0753e5.png)

![](_png/2603125ead5620d7b03a1c602ba38e3b.png)

Так же можно сократить запись, если записывать через цепочку либо можно делать присваивание через цикл

Однако самым рациональным методом будет присваивать значения через цикл из массива или определённой базы данных, которая может к нам подгрузиться

![](_png/d1622de37289a5d2ec2328a1dc193f98.png)

![](_png/400ddc279a51d25197d427a377d87a16.png)

Так же мы имеем метод `get()`, который позволяет получить map-значение из массива

![](_png/7f6cfd0bbff01a4d62b98d98b01766d3.png)

Метод `has()` проверяет наличие значения в мапе

![](_png/6b7c93204d665f2dd0fa1849cd757bec.png)

И вот несколько методов для работы с нашей картой

![](_png/fb53d8f26003dba522ea46056b42f2ab.png)

`Map` по сути своей представляет из себя массив массивов. Это можно было определить через `[entries]` в консоли браузера. Начальные данные через конструктор можно задать так:

![](_png/25e038af72ea02b121806113740d8458.png)

Ну и через перебор можно вывести ключи из нашей карты

![](_png/ea481b2d75442bfbea6e693ef14471a3.png)

Тут представлен код, который в массив закинет ключи ключей объектов карты. Тут мы берём через метод `keys()` ключи из карты и внутри `push()` (закидывания элемента в массив) мы вычленяем из объекта - бывшего ключа (который до этого был ключом элемента карты) ключ

Коротко: `keys()` -> берёт ключи из карты, `Object.keys()` -> берёт ключ объекта (который является ключом карты)

Получается такое получение ключей

![](_png/3c3bf5584dfd6d705d1b2ad1005bc3de.png)

Сейчас мы получаем вторую часть от элементов карты – значения. Получаем их просто перебирая `Map` через метод `values()`, который возвращает значения

![](_png/6ecd0f0b97e1ff8913bd3030e9c88a1d.png)

Тут мы получаем сами значения, записанные в карту

![](_png/ee3fd44be9c648663bfd80327eccaee8.png)

Так же можно произвести отдельно получение значений объекта-ключа и значения через деструктуризацию массива (карта – хранит каждое значение в виде массива)

Нужно отметить, что метод `entries()` возвращает как-раз таки массивы

![](_png/cfacda1e05a257a26f4ada365867acc8.png)

Ну и самый рекомендуемый способ перебора – через встроенный метод `forEach`. В его колбэк-функцию передаётся значение, ключ и сама карта (к ней вполне можно обратиться)

![](_png/9d3a2aaafe7285d0fd911b4a1a037c0e.png)

Перевод объекта в карту

![](_png/f0f21429d19ffc87fef206b496fd27d9.png)

Перевод карты в объект

![](_png/30617ba9f190b8c11d08925628ee994e.png)

> [!info] Все особенности `Map()`:
>
> 1.  У карт ключами могут быть любые типы данных: строки, массивы, объекты, функции, числа (В объектах только строки)
> 2.  Карты добавляют новые значения всегда в конец и всегда в них соблюдается порядок (В объектах могут добавляться куда угодно)
> 3.  В картах при создании нет никаких наследуемых свойств через прототип (В объектах могут быть)
> 4.  Карты легко перебирать
> 5.  Размеры карты легко получить (`size()`)

## 009 () Set

Это массив, где каждое значение встречается только один раз

![](_png/a632e01c409f054bfda33222e63ff781.png)

И так же мы можем добавить новые значения в такой массив

![](_png/cb362851980943591c6ef65272326a1c.png)

Ну и так же нам доступна ещё и цепочная запись через точку

![](_png/a12418025ceca435400bbb55e3079931.png)

![](_png/5da7c705c4e414c9230457ec63023e20.png)

![](_png/d230491e1c5c2e44319d9f4e86749a0c.png)

И второй способ – перебор через `forEach()`. Его особенность заключается в том, что у нас нет ключей в таком массиве и поэтому в качестве второго аргумента передаётся это же значение, но снова. Последний аргумент – сам сет

![](_png/a82faf99842aa2f93d38eae7be33c9bf.png)

Ну и у нас так же есть методы, присущие структуре Map. Методы `keys()` и `entries()` созданы для обратной совместимости с `Map`

![](_png/c35075c0738da71a297c62f57e114136.png)

В практическом применении `Set` используют для быстрой фильтрации массивов. Писать фильтр самому – это долго и неэффективно. Сет изначально хорошо оптимизирован и будет работать быстрее, чем самописный фильтр

![](_png/3a3345f2539a2c4de16272c46143e592.png)

## 010 () BigInt

Таким способом мы можем вывести максимальное число в интеджере. Иногда появляются ситуации, когда нам нужно использовать числа больше (например, при работе в банках)

![](_png/7c5b88a7d396685fb7b6a598f5f64a31.png)

И для этого уже используется тип данных `BigInt`. Его можно написать двумя способами:

1. Через `n` на конце
2. Через метод `BigInt`. Этот метод может принимать как число, так и строку

![](_png/333fa3cfdf865c6cba42e050da6a86e7.png)

Большие числа нельзя складывать с обычными и нельзя использовать внутри методов `Math` – это два их самых основных ограничения. Так же они работают почти со всеми унарными операторами (кроме `+`). Обычные операции с двумя большими числами – работают. При делении друг на друга большие числа округляются в меньшую сторону

![](_png/a6ecf552e223eb29fe7e55ab8fdf8c88.png)

К операциям сравнения большие числа относятся нормально и их можно сравнить даже с обычными числами

![](_png/7ee6cad7af1be0ce1abbda901cae2136.png)

Чтобы сложить большие и обычные числа можно воспользоваться таким синтаксисом:

![](_png/83cd18e88dd3d3363e22d2b633be4a9a.png)

> [!info] И самое важное:
>
> - `BigInt` нужно использовать только тогда, когда это реально необходимо. Потому что при переводе большого числа в обычное, все не входящие в диапазон цифры – отпадут.
> - Например, число `21342134721934721347921389421893231` откинет значения до `2134213472193472`

## 011 Дополнительные ссылки

002 -https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator

003 -https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Optional_chaining

004 -

https://drive.google.com/file/d/1TCuJlE6AYEXD9NjW9XinMsZ-1zxHBDAG/view?usp=sharing

005 -

https://tc39.es/ecma262/#sec-well-known-symbols

006 Object.keys-

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/keys

006 Object.values-

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/values

006 Object.entries-

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries

007 The-Essential-Guide-to-JavaScript-Iterators - https://www.javascripttutorial.net/es6/javascript-iterator/

007 hasOwnProperty - https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty

007 for.in-versus-for.of - https://bitsofco.de/for-in-vs-for-of/

007 for-of - https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...of

007 How-to-iterate-over-a-JavaScript-object - https://stackoverflow.com/questions/14379274/how-to-iterate-over-a-javascript-object

008 - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map

009 find - https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/find

009 - https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Set

010 - https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/BigInt
