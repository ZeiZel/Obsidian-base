## 027 Устройство V8

Представление JS выглядит следующим образом:

- ==Javascript code== - это тот код, который мы пишем
- ==Abstract Syntaxis Tree== - это дерево, в которое уже интерпретируется весь наш код
- ==Byte code== - это следующий этап превращения кода, когда всё описывается 1-байтовыми величинами
- ==Машинный код== - код, который воспринимает машина

![](_png/916e404668b7ca17f81b0c970ef36bba.png)

Само дерево выглядит примерно таким образом:
Мы видим функцию, что в ней находится в качестве экспрешшенов, операторы, отдельно связывание переменной и значения.

![](_png/86a3924941ea193812e0ea5196079f94.png)

Дальше у нас идёт байткод. Это набор инструкций, который конкретно по регистрам говорит, что и куда класть, чтобы получить определённый результат.

![](_png/fbe9da2839c7b3a6d0ab29b54cdd794d.png)

Ну и так же мы можем вывести непосредственно байткод нашего приложения, если на то будет потребность

```bash
node --print-bytecode byte.js
```

![](_png/4b206f9bfc4615aefd28c528225b9242.png)

Как выглядит компиляция кода в нашем движке `V8`:

1. Мы имеем наш исходный ==Javascript code==
2. Дальше он проходит через парсер и преобразуется в ==AST==
3. После он преобразуется в ==байт код== интерпретатором
4. После чего выбираются два основных пути:
    1. Используем компилятор `Turbofan`, если наш написанный код можно оптимизировать (например, если у нас постоянно повторяется операция умножения в коде, то её можно заоптимизировать)
    2. Используем компилятор `Sparkplug`, если наш написанный код нельзя оптимизировать

![](_png/d2137a969cc54215f989b3b254da0c89.png)

Пример:
Если мы создаём инстанс какого-либо объекта, то нужно сохранять порядок его свойств и количество свойств, чтобы код обрабатывался через оптимизированный компилятор

![](_png/36e3260c62bd15fcce6d5cb6e22ca015.png)

Используя TS такую оптимизацию будет поддерживать куда проще

![](_png/24fa281c35ad6506224bca0ac839507f.png)

## 028 Работа с памятью

![](_png/8e92710d919bc3bcb766a5621d2c1c36.png)

Данные очищаются ровно тогда, когда ни них не остаётся ссылок

![](_png/88aecf355c43ad99f3ea3095d7c74da9.png)

Если в этом дереве у нас пропадёт ссылка на другой объект и он окажется отвязанным от общего дерева, то этот объект удалится

![](_png/1679c1c10fa1c8d041c5a7037ce00cac.png)

Проблема может оказаться в том, что объекты на удаление могут ссылаться друг на друга и тогда они не удалятся

![](_png/efe47948f046ec2074dd3e1112c7641f.png)

Тогда была придумана технология, которая помечала бы все объекты и очищала те, до которых она не может добраться.
Однако такая технология в реально работающем приложении очень сильно его стопорит и на каждое действие придётся вести пересчёт, что ведёт к потере ресурсов.

![](_png/5c38f6edfb5ec37346f54fe254cbc13a.png)

Тут уже представлен более продвинутый алгоритм, который используется в современных движках.
Основная идея трёхцветной маркировки заключается в том, что мы красим сначала самые ближние объекты к глобальному (прямая связь) в чёрный цвет, связанные с ними объекты - в серый. Дальше все связанные объекты, до которых мы можем достучаться, красим в чёрный. Все, до которых мы не достучались, являются у нас белыми, то есть никак от изначального не помеченными. Их мы удаляем.
Этот подход отличается тем, что мы запоминаем состояние связей и мы помечаем после каждого действия в программе по одному дополнительному уровню связей

![](_png/ecc7f2b328e871cd54a77c27fe47c366.png)
![](_png/2c509506868b4ceb9816e8c15e4fe8ce.png)
![](_png/0db425f8e4e9cde3ec589bace99d8079.png)

Ещё одна проблема, которая может образоваться, когда мы пользуемся нашим приложением - это фрагментация памяти, которая появляется тогда, когда мы попользовались объектом (1), а потом после этого объекта появились ещё объекты. Впоследствии объект (1) был удалён из-за чего образовалась дырка

![](_png/b609af1da6d7f88b3e5e9b65d956c9ec.png)

Для решения этой проблемы используется технология `from > to`, при которой мы копируем из области `from` наши оставшиеся объекты в область `to`, чтобы память осталась дефрагментированной

![](_png/c4662a1407f572b45d322def545e46ab.png)

Идеально в нашем случае было бы иметь Reference counting, который бы производился инкрементально и периодически прогонять стопорящие технологии

(`Copying CG = Stop and Copy`)

![](_png/5798dbdf76b15fe41c5bd8044468478e.png)

Поколения памяти в движке `V8` делятся на три вида:

![](_png/112b1156a51a3de6de9a870f3f0cf163.png)

Что компилятор делает с молодой памятью и что со старой:

![](_png/aee2ff0f2acb97d30f80427a20e8b1e2.png)

Так выглядит график потребляемой памяти приложением и на падения пиков работает сборщик мусора

![](_png/a953bac6623db251df2706d35de9ffcc.png)

Данный код, представленный ниже, раньше вызывал сильные утечки данных в браузере. Сейчас эта проблема уже решена.

```JS
let outer = null;
let run = function () {
	let inner = outer;
	let unused = function () {
		if (inner) console.log("hi");
	};
	outer = {
		longStr: new Array(1000000).join("*"),
	};
};
setInterval(run, 1000);
```

Если нам нужно запустить этот код и посмотреть, как он отработает:

```bash
node --expose-gc --trace_gc_verbose app.js
```

`survival rate` определяет, сколько из нашего приложения осталось объектов после очистки. Далее мы можем увидеть все наши пространства и сколько они занимают места. Пространств больше, чем два (наше `old | new`), но описанные выше являются самыми основными

![](_png/b41d4ef522af4e7c524a1612356cd5d6.png)
