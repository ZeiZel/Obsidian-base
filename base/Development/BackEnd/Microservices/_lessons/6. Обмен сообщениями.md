
## Методы обмена

Типы обмена делятся на синхронные/асинхронные и по отношениям.

Синхронные процессы могут блокировать исполнение каких-либо дальнейших операций и замедлять работу сервиса.

Асинхронные методы обмена не стопорят работу сервиса, а просто продолжают работать и когда-нибудь ещё возвращают ответ на запрос либо принимают его и уже потом включают в работу.

Чтобы сделать сервисы максимально отвязанными друг от друга и постоянно работающими, мы должны использовать подписки на события, когда мы отправляем запрос в любой из инстансов одного сервиса или во многие сервисы, а уже затем получаем нужный нам результат в определённом будущем.
Однако если это событие с ожиданием, то мы можем заранее предполагать, что на наше прокинутое событие могут прийти ответы из разных источников с разной интерпретацией результата.

|             | 1 к 1                                           | 1 ко многим                                             |
| ----------- | ----------------------------------------------- | ------------------------------------------------------- |
| Синхронный  | Стандартный запрос / ответ                      |                                                         |
| Асинхронный | 1. Асинхронный запрос / ответ<br>2. Уведомление | 1. Подписка на событие<br>2. Событие с ожиданием ответа |
 
![](_png/Pasted%20image%2020250118180659.png)

Так же у нас и есть разные форматы данных для разных случаев:
- Если у нас не высоконагруженный сервис и нам важна обратная совместимость, то мы используем просто текстовый формат, потому что его можно легко читать и добавление в запрос нового поля не поломает логику работы других сервисов
- Если у нас хайлод с огромным количеством передаваемой информации, то нам нужен движок, который будет кодировать и декодировать ответы. Например Protobuf от Google. Такой подход позволит быстрее обмениваться сообщениями за счёт их компактности.

![](_png/Pasted%20image%2020250118184943.png)

Конракт - это договорённость, как должен выглядеть запрос и ответ определённого сервиса.

![](_png/Pasted%20image%2020250119095706.png)

- HTTP (запрос/ответ) и gRPC (удалённый вызов процедур) - это группа синхронных запрос/ответов
- RabbitMQ - основан на протоколе AMQP и позволяет на огромных скоростях обмениваться сообщениями, хорошо сохраняет персистентность (если важные очереди упадут, то )
- Redis - ОЗУ БД, которая позволяет нам так же обмениваться сообщениями и работать с очередями. Но так как это БД, то он хоть и более быстрый, но паттернов поддерживает меньше, просто разбирает запросы и не заботится о персистентности данных
- Kafka - сохраняет максимум логов и информации для реплеев, восстановления очередей, их проекта. Самый надёжный и мощный сервис. Однако и самый медленный из представленных.

Можно использовать RabbitMQ + Kafka для разных целей и задач в одном проекте. Стандартное общение через кролика, а уже через кафку очень важные запросы, которые нужно уметь логировать, отсматривать и обязательно выполнять.

![](_png/Pasted%20image%2020250119100828.png)

## Простая коммуникация

Пример простой коммуникации, где используется синхронный 1 к 1 запрос. Оба сервиса зависят друг от друга.

![](_png/Pasted%20image%2020250119104048.png)

И обычно выглядит выполнение такого сервиса так:

![](_png/Pasted%20image%2020250119104235.png)

### Проблемы

1. Хрупкость 

Отсутствует отказоустойчивость при падении одного из сервисов.

Если один из сервисов упал, то может упасть и всё остальное по каскаду, потому что ответа от зависимого сервиса нет. 

![](_png/Pasted%20image%2020250119104302.png)

2. Service Discovery

Мы точно должны понимать, на каком хосте и порту находится наш сервис. Каждый раз мы должны точно знать, куда должен полететь запрос.

3. Слабая доступность

Если у нас будет 10 сервисов с доступностью в 98%, то общая доступность будет в районе 80%

### Решение проблем

1. На все запросы к определённому сервису у нас должен стоять таймаут по выполнению
2. При накоплении запросов, которые не обрабатываются вторым сервисом, нужно будет отрабатывать лимитером. Если запросы будут копиться бесконечно, то первый сервис будет расти по памяти до огромных размеров

![](_png/Pasted%20image%2020250119110843.png)

3. Service Discovery

-  Паттерн саморегистрации

Заносим сервис, при поднятии, в registry (аля DNS), который хранит в себе книгу с соотношением `домен - ip + port`, по которому можно будет достучаться до сервиса и получить нужные данные.  

Для реализации можно воспользоваться: [Apache ZooKeeper](https://zookeeper.apache.org/), [Consul](https://www.consul.io/) (регистрирует сервисы, проводит healthcheck)

![](_png/Pasted%20image%2020250119113301.png)

- Авторегистрация

Авторегистрация уже присуща ближе к Docker Swarm / Kubernetes. При поднятии сервиса, он получает виртуальный ip и к нему другие сервисы могут обращаться по имени, который был указан в конфиге оркестратора.

Инструменты уже сами с помощью своего Discovery сохраняют нужную информацию по соотношениям имён. При отправке запроса, он идёт на внутренний Router, который перенаправляет запрос в нужное место.

![](_png/Pasted%20image%2020250119113852.png)

### Когда использовать?

Используем синхронный метод обмена, когда:
- Небольшой набор сервисов со слабой связанностью
- Есть готовый Service Discovery
- Хочется использовать преимущества документации HTTP (Swagger)

## Коммуникация через брокера

Брокер - это посрденик выполнения задач. 

Единственное, что знает определённый сервис это то, что ему нужно отправить в брокер задачу и он вернёт ему результат. Брокер сам разберётся куда нужно кинуть эту задачу и когда её вернуть. 

Никакой прямой коммуникации между сервисами Нет.

Такой подход позволяет реализовать все 4 паттерна асинхронного обмена данными.

![](_png/Pasted%20image%2020250119120847.png)

### Асинхронный запрос/ответ 

Подразумевают под собой не мгновенное получение ответа, а за какое-то разумное время, но не сею секунду.

Зачастую запрос представляет из себя:
- Header - метаданные, по которым определяем запрос / ответ
	- correlationId - идентификатор запроса, по которому отправим ответ и сопоставим задачи
	- replyChannel - канал, куда нужно ответить
	- другие параметры - куда отправить, одному или нескольким сервисам и так далее
- Body - данные запроса

Сам брокер зачастую делится на два канала: request (запрос) и reply (ответ) channel. 

![](_png/Pasted%20image%2020250119121342.png)

### Уведомление

Уведомление - это запрос в одну сторону, когда мы просто сообщаем другому сервису, что произошла определённая операция. 

![](_png/Pasted%20image%2020250119122018.png)

### Подписка на события

В отличе от уведомления, подписка распространяется сразу на несколько сервисов. В таком случае что-то сделают оба сервиса, а не один.

Например, у нас появился новый курс и сервис сообщает остальным, что нужно выделить место под оплату это курса и уведомить учащихся о появлении нового курса.

![](_png/Pasted%20image%2020250119134715.png)

### Событие с ожиданием ответа

Событие с ожиданием ответа уже включает подписку на событие и подразумевает ответ на это событие. 

![](_png/Pasted%20image%2020250119135713.png)

### Что даёт использование брокеров?

- Слабую связанность сервисов
	- сервисы могут быть на разных языках и выполнять разные задачи, но самое главное - они не зависят друг от друга
- Буферизацию сообщений
	- сообщение летит не напрямую, а через посредника
- Разные паттерны коммуникаций
	- можно использовать не просто запрос из одного места в другое, а более гибко работать со всеми своими сервисами в сети
- Персистентность. 
	- брокер будет держать у себя запрос до тех пор, пока конечный сервис не поднимется и не разберёт его
	- ну и так же сам брокер может восстановить историю запросов и продолжить работу

### Проблемы брокеров

- Работа с несколькими инстансами сервиса. Нужно заранее определить для брокера, как он будет балансировать нагрузку и запросы на оба из этих сервисов, чтобы не дублировать запросы или не перенагружить один из сервисов.
- Повторные сообщения при падениях. Брокеры доставляют сообщения хотя бы один раз. Не всегда брокеры при падении успевают записать, что это сообщенние они уже отправили, поэтому могут два или более раз отправить один и тот же запрос.
- Отправка сообщения в транзакции. Если вместе с сообщением идёт запись в БД, то может появиться такая проблема, что данные могут быть неконсистентными, потому что запись будет, а сообщение доставлено не будет.

### Решение проблем

1. Несколько инстансов

Множество брокеров имеет встроенный балансировщик, который работает с несколькими одинаковыми сервисами. Например, в RMQ мы можем каналу задать Round Robin балансировку, которая будет раскидывать запросы поровну между сервисами.

![](_png/Pasted%20image%2020250119153134.png)

2. Повторные сообщения

Мы решаем эту проблему двумя способами:
- сам брокер просматривает acknowledge и notacknowledge статусы запросов и в первом случае удаляет этот запрос из очереди
- делать проверки в самом сервисе и чекать на исполнение уже этой операции (изменение статуса прилетело во второй раз и отбраковать его, если статус пришёл ровно такой же)

![](_png/Pasted%20image%2020250119153358.png)

3. Отправка сообщения в транзакции

Когда нам нужно совершить запрос и записать что-то в БД, мы записываем данные транзакции сразу в Data и в Outbox. Outbox - это вспомогательная таблица, которая хранит список отправленных сообщений и их статус (отправлен / не отправлен).

Например, мы записываем статус платежа и записываем сразу данные в таблицы БД. Записываем данные по платежу и в табличку Outbox вносим состояние запроса: совершён / не совершён. Далее по этому Outbox сверяется наш брокер и отправляет сообщение.

>[!info] Этот паттерн нужен в крайних случаях, когда операция очень важна для исполнения и не повсеместно применяется

![](_png/Pasted%20image%2020250119154714.png)

## Минимизация синхронности











## Доработка схемы взаимодействия












