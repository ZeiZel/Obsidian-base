
## Методы обмена

Типы обмена делятся на синхронные/асинхронные и по отношениям.

Синхронные процессы могут блокировать исполнение каких-либо дальнейших операций и замедлять работу сервиса.

Асинхронные методы обмена не стопорят работу сервиса, а просто продолжают работать и когда-нибудь ещё возвращают ответ на запрос либо принимают его и уже потом включают в работу.

Чтобы сделать сервисы максимально отвязанными друг от друга и постоянно работающими, мы должны использовать подписки на события, когда мы отправляем запрос в любой из инстансов одного сервиса или во многие сервисы, а уже затем получаем нужный нам результат в определённом будущем.
Однако если это событие с ожиданием, то мы можем заранее предполагать, что на наше прокинутое событие могут прийти ответы из разных источников с разной интерпретацией результата.

|             | 1 к 1                                           | 1 ко многим                                             |
| ----------- | ----------------------------------------------- | ------------------------------------------------------- |
| Синхронный  | Стандартный запрос / ответ                      |                                                         |
| Асинхронный | 1. Асинхронный запрос / ответ<br>2. Уведомление | 1. Подписка на событие<br>2. Событие с ожиданием ответа |
 
![](_png/Pasted%20image%2020250118180659.png)

Так же у нас и есть разные форматы данных для разных случаев:
- Если у нас не высоконагруженный сервис и нам важна обратная совместимость, то мы используем просто текстовый формат, потому что его можно легко читать и добавление в запрос нового поля не поломает логику работы других сервисов
- Если у нас хайлод с огромным количеством передаваемой информации, то нам нужен движок, который будет кодировать и декодировать ответы. Например Protobuf от Google. Такой подход позволит быстрее обмениваться сообщениями за счёт их компактности.

![](_png/Pasted%20image%2020250118184943.png)

Конракт - это договорённость, как должен выглядеть запрос и ответ определённого сервиса.

![](_png/Pasted%20image%2020250119095706.png)

- HTTP (запрос/ответ) и gRPC (удалённый вызов процедур) - это группа синхронных запрос/ответов
- RabbitMQ - основан на протоколе AMQP и позволяет на огромных скоростях обмениваться сообщениями, хорошо сохраняет персистентность (если важные очереди упадут, то )
- Redis - ОЗУ БД, которая позволяет нам так же обмениваться сообщениями и работать с очередями. Но так как это БД, то он хоть и более быстрый, но паттернов поддерживает меньше, просто разбирает запросы и не заботится о персистентности данных
- Kafka - сохраняет максимум логов и информации для реплеев, восстановления очередей, их проекта. Самый надёжный и мощный сервис. Однако и самый медленный из представленных.

Можно использовать RabbitMQ + Kafka для разных целей и задач в одном проекте. Стандартное общение через кролика, а уже через кафку очень важные запросы, которые нужно уметь логировать, отсматривать и обязательно выполнять.

![](_png/Pasted%20image%2020250119100828.png)

## Простая коммуникация

Пример простой коммуникации, где используется синхронный 1 к 1 запрос. Оба сервиса зависят друг от друга.

![](_png/Pasted%20image%2020250119104048.png)

И обычно выглядит выполнение такого сервиса так:

![](_png/Pasted%20image%2020250119104235.png)

### Проблемы

1. Хрупкость 

Отсутствует отказоустойчивость при падении одного из сервисов.

Если один из сервисов упал, то может упасть и всё остальное по каскаду, потому что ответа от зависимого сервиса нет. 

![](_png/Pasted%20image%2020250119104302.png)

2. Service Discovery

Мы точно должны понимать, на каком хосте и порту находится наш сервис. Каждый раз мы должны точно знать, куда должен полететь запрос.

3. Слабая доступность

Если у нас будет 10 сервисов с доступностью в 98%, то общая доступность будет в районе 80%

### Решение проблем

1. На все запросы к определённому сервису у нас должен стоять таймаут по выполнению
2. При накоплении запросов, которые не обрабатываются вторым сервисом, нужно будет отрабатывать лимитером. Если запросы будут копиться бесконечно, то первый сервис будет расти по памяти до огромных размеров

![](_png/Pasted%20image%2020250119110843.png)

3. Service Discovery

-  Паттерн саморегистрации

Заносим сервис, при поднятии, в registry (аля DNS), который хранит в себе книгу с соотношением `домен - ip + port`, по которому можно будет достучаться до сервиса и получить нужные данные.  

Для реализации можно воспользоваться: [Apache ZooKeeper](https://zookeeper.apache.org/), [Consul](https://www.consul.io/) (регистрирует сервисы, проводит healthcheck)

![](_png/Pasted%20image%2020250119113301.png)

- Авторегистрация

Авторегистрация уже присуща ближе к Docker Swarm / Kubernetes. При поднятии сервиса, он получает виртуальный ip и к нему другие сервисы могут обращаться по имени, который был указан в конфиге оркестратора.

Инструменты уже сами с помощью своего Discovery сохраняют нужную информацию по соотношениям имён. При отправке запроса, он идёт на внутренний Router, который перенаправляет запрос в нужное место.

![](_png/Pasted%20image%2020250119113852.png)

### Когда использовать?

Используем синхронный метод обмена, когда:
- Небольшой набор сервисов со слабой связанностью
- Есть готовый Service Discovery
- Хочется использовать преимущества документации HTTP (Swagger)

## Коммуникация через брокера

Брокер - это посрденик выполнения задач. 

Единственное, что знает определённый сервис это то, что ему нужно отправить в брокер задачу и он вернёт ему результат. Брокер сам разберётся куда нужно кинуть эту задачу и когда её вернуть. 

Никакой прямой коммуникации между сервисами Нет.

Такой подход позволяет реализовать все 4 паттерна асинхронного обмена данными.

![](_png/Pasted%20image%2020250119120847.png)





## Минимизация синхронности



## Доработка схемы взаимодействия




