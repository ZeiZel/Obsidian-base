
## Методы обмена

Типы обмена делятся на синхронные/асинхронные и по отношениям.

Синхронные процессы могут блокировать исполнение каких-либо дальнейших операций и замедлять работу сервиса.

Асинхронные методы обмена не стопорят работу сервиса, а просто продолжают работать и когда-нибудь ещё возвращают ответ на запрос либо принимают его и уже потом включают в работу.

Чтобы сделать сервисы максимально отвязанными друг от друга и постоянно работающими, мы должны использовать подписки на события, когда мы отправляем запрос в любой из инстансов одного сервиса или во многие сервисы, а уже затем получаем нужный нам результат в определённом будущем.
Однако если это событие с ожиданием, то мы можем заранее предполагать, что на наше прокинутое событие могут прийти ответы из разных источников с разной интерпретацией результата.

|             | 1 к 1                                           | 1 ко многим                                             |
| ----------- | ----------------------------------------------- | ------------------------------------------------------- |
| Синхронный  | Стандартный запрос / ответ                      |                                                         |
| Асинхронный | 1. Асинхронный запрос / ответ<br>2. Уведомление | 1. Подписка на событие<br>2. Событие с ожиданием ответа |
 
![](_png/Pasted%20image%2020250118180659.png)

Так же у нас и есть разные форматы данных для разных случаев:
- Если у нас не высоконагруженный сервис и нам важна обратная совместимость, то мы используем просто текстовый формат, потому что его можно легко читать и добавление в запрос нового поля не поломает логику работы других сервисов
- Если у нас хайлод с огромным количеством передаваемой информации, то нам нужен движок, который будет кодировать и декодировать ответы. Например Protobuf от Google. Такой подход позволит быстрее обмениваться сообщениями за счёт их компактности.

![](_png/Pasted%20image%2020250118184943.png)

Конракт - это договорённость, как должен выглядеть запрос и ответ определённого сервиса.

![](_png/Pasted%20image%2020250119095706.png)

- HTTP (запрос/ответ) и gRPC (удалённый вызов процедур) - это группа синхронных запрос/ответов
- RabbitMQ - основан на протоколе AMQP и позволяет на огромных скоростях обмениваться сообщениями, хорошо сохраняет персистентность (если важные очереди упадут, то )
- Redis - ОЗУ БД, которая позволяет нам так же обмениваться сообщениями и работать с очередями. Но так как это БД, то он хоть и более быстрый, но паттернов поддерживает меньше, просто разбирает запросы и не заботится о персистентности данных
- Kafka - сохраняет максимум логов и информации для реплеев, восстановления очередей, их проекта. Самый надёжный и мощный сервис. Однако и самый медленный из представленных.

Можно использовать RabbitMQ + Kafka для разных целей и задач в одном проекте. Стандартное общение через кролика, а уже через кафку очень важные запросы, которые нужно уметь логировать, отсматривать и обязательно выполнять.

![](_png/Pasted%20image%2020250119100828.png)

## Простая коммуникация

Пример простой коммуникации, где используется синхронный 1 к 1 запрос. Оба сервиса зависят друг от друга.

![](_png/Pasted%20image%2020250119104048.png)

И обычно выглядит выполнение такого сервиса так:

![](_png/Pasted%20image%2020250119104235.png)

#### Проблемы

1. 

Однако, если один из сервисов упал, то может упасть и всё остальное по каскаду, потому что ответа от зависимого сервиса нет. 

![](_png/Pasted%20image%2020250119104302.png)

2. Мы точно должны 




## Коммуникация через брокера



## Минимизация синхронности



## Доработка схемы взаимодействия




