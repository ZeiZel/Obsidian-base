
## Бизнес логика и события

### Слои архитектуры

Если монолите мы можем воспользоваться layer, гексогональной и другими архитектурами, то в МС нам нужно реализовыать её иначе. Тут мы должны переходить на Event Sourcing и доменные события. 

Верхний слой сервиса:
- Event Handler - обрабатывает доменные события
- Command Handler - обрабатывает команды, изменяющие данные
- Query Handler - обработка запроса данных

Средний слой:
- Core Service - ключевой сервис бизнес-логики. С ним работает весь верхний слой. Сам он работает с публикацией ивентов (и уведомляет об изменении состояния) и моделью сущности. 
- Event Publisher - отправка ивентов

Нижний слой: 
- Entity Model - явялется представлением данных и кладётся в репозиторий
- Repository - получает данные и отправляет энтити в БД

База данных - конечная точка

![](_png/Pasted%20image%2020250129204434.png)

### Верхний слой архитектуры

У нас есть два подхода при работе с данными:
1. Использовать только Controller. Он будет в себя принимать ивенты, хэндлеры, запросы, а потом только получать какие-то данные
2. Event Handler + Command Handler + Query Handler. Использовать вместе разные хэндлеры для отдельных запросов в сервис. В таком случае, мы реализуем отдельно котроллеры либо МС, которые отвечают за свою область работы
	1. Event - обрабатывает ивенты из других МС
	2. Command - обрабатывает команды на изменение данных
	3. Query - будет обрабатывать только запросы на получение данных

![](_png/Pasted%20image%2020250130185153.png)

### Средний слой архитектуры

Core Service - ядро всей бизнес логики

Его функционал:
- Он напрямую работает с Entity
- Имеет бизнес-логику того, как работать с Entity
- Публикует события
- Обрабатывает запросы в него (запросы из event, command, query)

![](_png/Pasted%20image%2020250201144728.png)

### Нижний слой архитектуры

Entity Model

- **Это представление предметной обалсти домена** (например Mail, который хранит свои: шаблон, получателя и тд)
- **Вся работа с доменом происходит через Entity**. Работа для модификации себя самого. Мы не работаем с объектами, потому что мы можем подифицировать их как угодно, но нам это не нужно, поэтому нам нужно рабоать с сущностью её методами.
- **При чтении из базы мы восстанавливаем Entity**. Когда мы берём из Repository данные, мы переводим их в Entity.
- **В базу может быть записана только Entity**. Передаём обратно в Repository тоже так же Entity.

### Доменные события

Доменные события (ДС/EventSourcing) - это ивенты с payload, в котором описано, что поменялось (либо включает полный слепок Entity), которое оповещает всех заинтересованных о произошедшем событии

Они создаются при создании либо изменении Entity и её сохранении.

- Для консистентности данных в других сервисах
- Для поддержки реплики View
- Для вызова бизнес-логики из другого сервиса
- Для перехвата и логирования изменений модели

>[!important] В рамках микросервисов нам обязательно работать больше не с коммандами, а с ивентами
>Все наши МС должны быть максимально независимы друг от друга и общаться друг с другом посредством ивентов, а не команд, потому что команда обязует дождаться результата и выполниться, а ивент мы можем отложить и когда-нибудь потом дождтаться его выполнения.

Примерно такой путь мы должны проходить, когда пишем микросервисы:

> Что-то произошло -> Мы всех уведомили -> Остальные как-то отреагировали и выполнили действие в зависимости от ивента

## Доработка архитектуры Accounts



> Я, как пользователь, хочу купить курс, чтобы его пройти

> Я, как пользователь, хочу получить список моих курсов, чтобы выбрать курс для прохождения



![](_png/Pasted%20image%2020250201163546.png)



## Код Структурируем сервис Accounts









## Упражнение Реализуем Commands









