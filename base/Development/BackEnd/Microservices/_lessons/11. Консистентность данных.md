 
## Саги консистентность данных

### Сохранение консистентности

Когда нам нужно выполнить операцию, которая затронет сразу несколько МС, и при этом сохранить состояния между всеми сервисами, стоит обратить внимание на саги. 

Транзакция данных в монолите не ломает консистентность данных, так как она происходит в одном приложении и агрегирует данные внутри себя.

Мы можем откатить изменения, которые конфликтуют друг с другом через отмену коммита транзакции в БД.  

 >[!example] Если человек попытался купить курс, которого нет на платформе, то мы просто не коммитим эту запись и оплата отменяется.

![](_png/Pasted%20image%2020250202200121.png)

Но когда мы переходим в плоскость МС, у нас встаёт проблема с тем, что наша транзакция должна пройти по нескольким сервисам и вернуть свои определённые результаты. 

![](_png/Pasted%20image%2020250202201256.png)

### Сага

Сага - это паттерн выполнения набора действий, при котором есть свои противодействия

Например, покупка курса:
1. В первом сервисе проверяем, что курса нет на аккаунте и добавляем процесс покупки сервиса
2. Запрашиваем покупку сервиса в курсах
3. Получаем ссылку на оплату из сервиса платежей
4. Отправляем ссылку пользователю, чтобы он совершил оплату

![](_png/Pasted%20image%2020250203175506.png)

Во время выполнения операции, мы можем столкнуться с тем, что курс может быть недоступен, а в статус покупки мы уже перевели в первом сервисе

![](_png/Pasted%20image%2020250203180020.png)

В таком случае, мы должны компенсировать запись в базу, отменив её

![](_png/Pasted%20image%2020250203180104.png)

### Как планировать саги

Во время составления саги, нам стоит вести таблицу, по которой мы будем сверяться, какие методы и из какого сервиса нам нужно вызывать. А так же обязательно указать возможные компенсации для отката ЭТОЙ операции.

Компенсации на провверки курсов и генерации ссылки на оплату нам не нужны, так как проверка и генерация ссылки не вызовут нигде никаких коллизий.
Если на этапе создания ссылки оплаты произошла ошибка, то нам так же придётся дёрнуть компенсацию на аккаунт.

Если у нас произошла ошибка во время добавления курса на аккаунт, то нам нужно будет компенсировать это действие удалением курса с аккаунта.

![](_png/Pasted%20image%2020250203182252.png)

### Типы саг

#### Хореографическая Сага

Для реализации саг есть несколько подходов, одним из которых является Хореографическая Сага.

Такой тип саг подразумевает, что каждый сервис знает, куда должно полететь продолжение операции. Всю логику по прокидыванию операции дальше, мы храним в этом сервисе.

Можно так же создавать и целевые команды, которые мы отправим в определённый сервис, но ивенты будут более мобильными, когда определённую команду мы будем обрабатывать несколькими сервисами. Например, как показано в приложении: 
1. Сгенерировали ссылку для оплаты `link.generated.event`
2. Отправили обратно клиенту + отправили уведомление другим сервисом

![](_png/Pasted%20image%2020250203182939.png)
 
| Плюсы              | Минусы                           |
| ------------------ | -------------------------------- |
| Прост в реализации | Сложны для восприятия            |
|                    | Возможны циклические зависимости |
|                    | Большая связность сервисов       |

#### Оркестрируемая сага

Но когда в нашей последовательности используется больше 2-3 сервисов, мы не сможем воспользоваться Хореографической сагой. В таком случае, нам стоит воспользоваться Оркестрируемой сагой. 

В данном паттерне мы реализуем **оркестратор**, который сам будет отвечать за исполнение саги. Он хранит в себе информацию о ивентах, которые нужно будет вызывать, чтобы продолжить операцию, либо компенсировать её.

Такой метод лучше подходит под паттерн State.

Например: 
1. В Account прилетел запрос на покупку курса. Он отправляет ивент на добавление курса
2. Сервис курсов среагировал на ивент: 
	1. обработал его
	2. проверил, что курс существует и стоит он больше 0 рублей
	3. и отправил результат в отдельную **очередь саги**, на которую реагирует сервис Account
3. Затем account: 
	1. обработал этот прилетевший ивент
	2. проверил, что ему прилетела не ошибка и компенсировать этот запрос не нужно
	3. и отправляет следующий ивент на оплату в Payments

И так далее происходит проходка по всем сервисам. Тут у нас получилось 4 основных сервиса, из которых 1 занимается оркестрацией запросов и собирает ответы на заэмиченные ивенты из одной централизованной очереди данной саги.

В отличие от Хореографичечской саги, мы тут добавили отдельный шаг для отправки уведомления о завершении операции.  

![](_png/Pasted%20image%2020250203184306.png)

| Плюсы                                                                                                                                             | Минусы                                                                                                       |
| ------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| Слабое связывание (за счёт того, что ни один из сервисов не знает друг о друге ничего, кроме потребности отправить ответ в очередь оркестратора ) | Централизация саги как части домена (сервис Accounts начал знать всё то, что должно происходить в других МС) |
| Простое восприятие и зависимости (легко прочитать сагу)                                                                                           |                                                                                                              |

По итогу мы получим некоторый недо-супер-сервис, который в себя вбирает свою доменную область и ещё немного от других. Но этот подход будет правильнее, так как уменьшает связывание между остальными сервисами.

### Исполнение саг через команды

Так же все из саг мы можем выполнять через обычные команды, которые должны будут выполниться синхронно, но это снижает производительность работы сервисов. 

На командах стоит строить ТОЛЬКО простые саги, когда мы отправили запрос на получение данных и генерацию чего-то простого и быстрого. 

Более приоритетным всё равно остаётся взаимодействие через ивенты между сервисами. 

![](_png/Pasted%20image%2020250708201746.png)

### Паттерн State

Любая сага представляет из себя state-машину, которую можно легко описать последовательностью: 

1. Мы имеем входной параметр
2. Совершаем попытку добавления курса:
	1. Курс не проверифицирован
		1. Отменяем транзакцию добавления курса на аккаунт 
	2. Курс проверифицирован
		1. Генерируем ссылку
		2. Отравляем уведомление

![](_png/Pasted%20image%2020250708202114.png)

### Сложности взаимодействия саг

- Обновление одной саги может перетирать другую
	- нам нужно лочить данные в моменте выполнения саги
		- один человек оформляет курс бесплатно по промо ссылке, а другой по ссылке платно, нужно проверять, чтобы не возникало коллизий от разных состояний одного элемента
- Данные, прочитанные одной сагой, меняются другой сагой
	- нужно повторно проверять данные перед завершением транзакции
		- Если цена на продукт изменилась в моменте и мы отправили запрос на покупку курса сразу перед повышением цены 

## Паттерн State

У нас есть приложение, в котором вся бизнес логика поделена на определённые стейты и нам обязательно нужно менять состояние айтема из одного статуса в другой. 

1. У нас есть пост, который мы можем отправить на модерацию
2. Модерацию пост может не пройти и обратно уйти в черновик, либо модератор может опубликовать пост
3. Из статуса "опубликован" можно скинуть пост обратно в черновик, чтобы его исправить

В обычном мире мы пишем достаточно большое количество стейтментов, чтобы проверить определённое состояние отдельного элемента и перевести его в другое состояние

![](_png/Pasted%20image%2020250708203251.png)

Чтобы решить эту проблему, мы можем делегировать задачу для определения состояния отдельного айтема в надкласс, который и будет свитчить состояние айтема

![](_png/Pasted%20image%2020250708203655.png)

У нас есть элемент `DocumentItem`, который представляет из себя документ.

Опишем для него абстрактный класс, который `DocumentItemState` имеет метод `setContext` для подцепления контекста статуса к данным из `DocumentItem` и два метода `publish` и `delete`, которые будут описывать поведение определённого состояния. 

Далее мы опишем два класса с состояниями, которые будут выполнять сугубо предписанную логику для этого состояния. Эти два класса реализуют абстрактные методы `delete` и `publish`, но реализуют их согласно того состояния, к которому они относятся.

В самом `DocumentItem` нам нужно реализовать сохранение поля `state`, в котором хранится инстанс с состоянием, реализованным по описанию из абстрактного `DocumentItemState`. Для этого у нас реализованы `getState` и `setState`. А в методах `publishDoc` и `deleteDoc`, которые должны выполнять разные действия в зависимости от состояния объекта, мы исполняем действия, которые описали в стейтах.

Теперь при инстанциировании айтема документа и вызове методов, мы автоматически меняем стейты и, тем самым, триггерим методы этих стейтов, которые имеют разную логику.

```TS

// Наш отдельный элемент
class DocumentItem {
    public text: string;
    private state: DocumentItemState;

    constructor() {
      this.setState(new DraftDocumentItemState());
    }

    public getState() {
      return this.state;
    }
    public setState(state: DocumentItemState) {
      this.state = state;

      // Цепляем контекст исполнения, чтобы не было ошибки при передаче данных из текущего класса в методы состояния
      this.state.setContext(this);
    }

    public publishDoc() {
      this.state.publish();
    }
    public deleteDoc() {
      this.state.delete();
    }
}

abstract class DocumentItemState {
    public name: string;
    public item: DocumentItem;

    public setContext(item: DocumentItem) {
        this.item = item;
    }

    public abstract publish(): void;
    public abstract delete(): void;
}

class DraftDocumentItemState extends DocumentItemState {
    constructor() {
      super();
      this.name = 'DraftDocument';
    }

    public publish(): void {
      console.log(`Пост опубликован: ${this.item.text}`);
      this.item.setState(new PublishDocumentItemState());
    }

    public delete(): void {
      console.log(`Черновик очищен!`);
    }
}

class PublishDocumentItemState extends DocumentItemState {
    constructor() {
      super();
      this.name = 'PublishDocument';
    }

    public publish(): void {
      console.log(`Пост уже опубликован!`);
    }

    public delete(): void {
      console.log(`Пост перенесён в черновик!`);
      this.item.setState(new DraftDocumentItemState());
    }
}

const item = new DocumentItem();
item.text = 'Это мой новый пост!';
console.log(item.getState());
item.publishDoc();
console.log(item.getState());
item.publishDoc();
item.deleteDoc();
console.log(item.getState());
```

## Код Подготовка саги

Сначала нам нужно подготовить логику изменения состояния курсов. Добавляем в сущность пользователя методы на добавление, удаление и обновление статуса курсов.

Именно ЭТИ методы будет дёргать **сага** для изменения данных по клиенту. 

`apps/ account / src / app / user / entity / user.entity.ts`
```TS
// добавление курса
public addCourse(courseId: string) {
	const exist = this.courses.find(c => c._id === courseId);
	if (exist) {
		throw new Error('Добавляемый курс уже существует');
	}
	this.courses.push({
		courseId,
		purchaseState: PurchaseState.Started
	});
}

// удаление курса
public deleteCourse(courseId: string) {
	this.courses = this.courses.filter(c => c._id !== courseId);
}

// обновление статуса курса
public updateCourseStatus(courseId: string, state: PurchaseState) {
	this.courses = this.courses.map(c => {
		if (c._id === courseId) {
			c.purchaseState = state;
			return c;
		}
		return c;
	})
}
```

Далее наконец реализуем саму сагу. 

Эта сага будет отвечать за контроль состояния покупки курса. 

Сама сага не является частью дерева зависимостей неста, поэтому нам самим придётся передавать все пропсы класса в конструктор. 

Пока наша сага будет представлять из себя базу: 
1. Передаём в неё сущность пользователя, чтобы изменять его состояние, идентификатор курса и сервис по работе с RMQ
2. Храним состояние, которое представляет из себя абстрактный класс, на котором базируется интерфейсы будущих состояний
3. Получаем стейт
4. Устанавливаем стейт через свитч. В будущем тут будут находиться классы с логикой для определённого состояния.

`apps / account / src / app / user / sagas / buy-course.saga.ts`
```TS
import { PurchaseState } from '@purple/interfaces';
import { RMQService } from 'nestjs-rmq';
import { UserEntity } from '../entities/user.entity';
import { BuyCourseSagaState } from './buy-course.state';

export class BuyCourseSaga {
	private state: BuyCourseSagaState;

	constructor(private user: UserEntity, private courseId: string, private rmqService: RMQService) {}

	setState(state: PurchaseState, courseId: string) {
		switch (state) {
			case PurchaseState.Started:
				break;
			case PurchaseState.WaitingForPayment:
				break;
			case PurchaseState.Purchased:
				break;
			case PurchaseState.Canceled:
				break;
		}
		// установка контекста для стейта 
		this.state.setContext(this);
		// связывание сущности и саги через обновление статуса курса
		this.user.updateCourseStatus(courseId, state);
	}

	getState() {
		return this.state;
	}
}
```

Базовый класс-стейт будет иметь методы для покупки, проверки платежа и отмены покупки курса

`apps / account / src / app / user / sagas / buy-course.state.ts`
```TS
import { UserEntity } from '../entities/user.entity';
import { BuyCourseSaga } from './buy-course.saga';

export abstract class BuyCourseSagaState {
	public saga: BuyCourseSaga;

	public setContext(saga: BuyCourseSaga) {
		this.saga = saga;
	}

	public abstract pay(): Promise<{ paymentLink: string, user: UserEntity }>;
	public abstract checkPayment(): Promise<{ user: UserEntity }>;
	public abstract cancel(): Promise<{ user: UserEntity }>;
}
```

## Код Состояния саги









## Упражнение Доработка состояний









## Код Реализация Commands









## Код Доменные события








