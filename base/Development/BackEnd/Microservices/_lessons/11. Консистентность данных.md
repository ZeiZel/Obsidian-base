 
## Саги консистентность данных

### Сохранение консистентности

Когда нам нужно выполнить операцию, которая затронет сразу несколько МС, и при этом сохранить состояния между всеми сервисами, стоит обратить внимание на саги. 

Транзакция данных в монолите не ломает консистентность данных, так как она происходит в одном приложении и агрегирует данные внутри себя.

Мы можем откатить изменения, которые конфликтуют друг с другом через отмену коммита транзакции в БД.  

 >[!example] Если человек попытался купить курс, которого нет на платформе, то мы просто не коммитим эту запись и оплата отменяется.

![](_png/Pasted%20image%2020250202200121.png)

Но когда мы переходим в плоскость МС, у нас встаёт проблема с тем, что наша транзакция должна пройти по нескольким сервисам и вернуть свои определённые результаты. 

![](_png/Pasted%20image%2020250202201256.png)

### Сага

Сага - это паттерн выполнения набора действий, при котором есть свои противодействия

Например, покупка курса:
1. В первом сервисе проверяем, что курса нет на аккаунте и добавляем процесс покупки сервиса
2. Запрашиваем покупку сервиса в курсах
3. Получаем ссылку на оплату из сервиса платежей
4. Отправляем ссылку пользователю, чтобы он совершил оплату

![](_png/Pasted%20image%2020250203175506.png)

Во время выполнения операции, мы можем столкнуться с тем, что курс может быть недоступен, а в статус покупки мы уже перевели в первом сервисе

![](_png/Pasted%20image%2020250203180020.png)

В таком случае, мы должны компенсировать запись в базу, отменив её

![](_png/Pasted%20image%2020250203180104.png)

### Как планировать саги

Во время составления саги, нам стоит вести таблицу, по которой мы будем сверяться, какие методы и из какого сервиса нам нужно вызывать. А так же обязательно указать возможные компенсации для отката ЭТОЙ операции.

Компенсации на провверки курсов и генерации ссылки на оплату нам не нужны, так как проверка и генерация ссылки не вызовут нигде никаких коллизий.
Если на этапе создания ссылки оплаты произошла ошибка, то нам так же придётся дёрнуть компенсацию на аккаунт.

Если у нас произошла ошибка во время добавления курса на аккаунт, то нам нужно будет компенсировать это действие удалением курса с аккаунта.

![](_png/Pasted%20image%2020250203182252.png)

### Типы саг

#### Хореографическая Сага

Для реализации саг есть несколько подходов, одним из которых является Хореографическая Сага.

Такой тип саг подразумевает, что каждый сервис знает, куда должно полететь продолжение операции. Всю логику по прокидыванию операции дальше, мы храним в этом сервисе.

Можно так же создавать и целевые команды, которые мы отправим в определённый сервис, но ивенты будут более мобильными, когда определённую команду мы будем обрабатывать несколькими сервисами. Например, как показано в приложении: 
1. Сгенерировали ссылку для оплаты `link.generated.event`
2. Отправили обратно клиенту + отправили уведомление другим сервисом

![](_png/Pasted%20image%2020250203182939.png)
 
| Плюсы              | Минусы                           |
| ------------------ | -------------------------------- |
| Прост в реализации | Сложны для восприятия            |
|                    | Возможны циклические зависимости |
|                    | Большая связность сервисов       |

#### Оркестрируемая сага

Но когда в нашей последовательности используется больше 2-3 сервисов, мы не сможем воспользоваться Хореографической сагой. В таком случае, нам стоит воспользоваться Оркестрируемой сагой. 

В данном паттерне мы реализуем **оркестратор**, который сам будет отвечать за исполнение саги. Он хранит в себе информацию о ивентах, которые нужно будет вызывать, чтобы продолжить операцию, либо компенсировать её.

Такой метод лучше подходит под паттерн State.

Например: 
1. В Account прилетел запрос на покупку курса. Он отправляет ивент на добавление курса
2. Сервис курсов среагировал на ивент: 
	1. обработал его
	2. проверил, что курс существует и стоит он больше 0 рублей
	3. и отправил результат в отдельную **очередь саги**, на которую реагирует сервис Account
3. Затем account: 
	1. обработал этот прилетевший ивент
	2. проверил, что ему прилетела не ошибка и компенсировать этот запрос не нужно
	3. и отправляет следующий ивент на оплату в Payments

И так далее происходит проходка по всем сервисам. Тут у нас получилось 4 основных сервиса, из которых 1 занимается оркестрацией запросов и собирает ответы на заэмиченные ивенты из одной централизованной очереди данной саги.

В отличие от Хореографичечской саги, мы тут добавили отдельный шаг для отправки уведомления о завершении операции.  

![](_png/Pasted%20image%2020250203184306.png)

| Плюсы                                                                                                                                             | Минусы                                                                                                       |
| ------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| Слабое связывание (за счёт того, что ни один из сервисов не знает друг о друге ничего, кроме потребности отправить ответ в очередь оркестратора ) | Централизация саги как части домена (сервис Accounts начал знать всё то, что должно происходить в других МС) |
| Простое восприятие и зависимости (легко прочитать сагу)                                                                                           |                                                                                                              |

По итогу мы получим некоторый недо-супер-сервис, который в себя вбирает свою доменную область и ещё немного от других. Но этот подход будет правильнее, так как уменьшает связывание между остальными сервисами.

### Исполнение саг через команды

Так же все из саг мы можем выполнять через обычные команды, которые должны будут выполниться синхронно, но это снижает производительность работы сервисов. 

На командах стоит строить ТОЛЬКО простые саги, когда мы отправили запрос на получение данных и генерацию чего-то простого и быстрого. 

Более приоритетным всё равно остаётся взаимодействие через ивенты между сервисами. 

![](_png/Pasted%20image%2020250708201746.png)

### Паттерн State

Любая сага представляет из себя state-машину, которую можно легко описать последовательностью: 

1. Мы имеем входной параметр
2. Совершаем попытку добавления курса:
	1. Курс не проверифицирован
		1. Отменяем транзакцию добавления курса на аккаунт 
	2. Курс проверифицирован
		1. Генерируем ссылку
		2. Отравляем уведомление

![](_png/Pasted%20image%2020250708202114.png)

### Сложности взаимодействия саг

- Обновление одной саги может перетирать другую
	- нам нужно лочить данные в моменте выполнения саги
		- один человек оформляет курс бесплатно по промо ссылке, а другой по ссылке платно, нужно проверять, чтобы не возникало коллизий от разных состояний одного элемента
- Данные, прочитанные одной сагой, меняются другой сагой
	- нужно повторно проверять данные перед завершением транзакции
		- Если цена на продукт изменилась в моменте и мы отправили запрос на покупку курса сразу перед повышением цены 

## Паттерн State

У нас есть приложение, в котором вся бизнес логика поделена на определённые стейты и нам обязательно нужно менять состояние айтема из одного статуса в другой. 

1. У нас есть пост, который мы можем отправить на модерацию
2. Модерацию пост может не пройти и обратно уйти в черновик, либо модератор может опубликовать пост
3. Из статуса "опубликован" можно скинуть пост обратно в черновик, чтобы его исправить

В обычном мире мы пишем достаточно большое количество стейтментов, чтобы проверить определённое состояние отдельного элемента и перевести его в другое состояние

![](_png/Pasted%20image%2020250708203251.png)

Чтобы решить эту проблему, мы можем делегировать задачу для определения состояния отдельного айтема в надкласс, который и будет свитчить состояние айтема

![](_png/Pasted%20image%2020250708203655.png)















## Код Подготовка саги









## Код Состояния саги









## Упражнение Доработка состояний









## Код Реализация Commands









## Код Доменные события








