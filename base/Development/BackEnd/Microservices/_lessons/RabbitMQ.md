
## Устанавливаем RabbitMQ

Поднимаем композ с нужным образом

`docker-compose.yml`
```YML
---
services:
  rmq:
    image: rabbitmq:4-management
    restart: always
    ports:
      - 15672:15672  # админка
      - 5672:5672  # отправка сообщений
```

И, без заданных переменными пароля и логина, вводим для авторизации везде `guest`

## Устройство RabbitMQ

Наши микросервисы в схеме работы RMQ будут делиться на:
- Publisher -  публикует сообщения (отправитель)
- Subscriber - тот, кто подписывается на получение сообщений (получатель). Он достаёт сообщения из очереди.
- Queue - очередь (почтовый ящик). Сюда перенаправляются сообщения. 
- Exchange - обменный ящик (почтовое отделение). Решает, как доставить сообщение адресату и получает все сообщения.

- Routing Key - маршрут передачи сообщения. Это ключ, который указывает, куда отправить сообщение
- Binding - связь очереди с маршрутом. Помогает Exchange понимать, по какому Routing Key в какоую Queue нужно отправлять сообщение.
- Channel - канал передачи/приёма сообщения.
- Connection - соединение клиента RMQ

![](_png/Pasted%20image%2020250120183234.png)

Тут у нас отображены все connections к нашему RMQ из всех сервисов. 

Мы можем развернуть несколько инстансов RMQ и объединить их в кластер, чтобы поднять отказоустойчивость.

![](_png/Pasted%20image%2020250124181517.png)

Все каналы для передачи сообщений

![](_png/Pasted%20image%2020250124184402.png)

Тут отображены дефолтные очереди

![](_png/Pasted%20image%2020250124184924.png)

Отображение, создание и управление очередьми

![](_png/Pasted%20image%2020250124184956.png)

Создаём директовый Exchange с произвольным именем, который будет определять тип нашего сообщения.

![](_png/Pasted%20image%2020250124185133.png)

Далее создаём очередь, которая будет классического типа (quorum - это более персистентная, а stream - поток), durable (сохраняется после падения) и не auto delete (не будет удаляться при отключении всех пользователей).

![](_png/Pasted%20image%2020250124185359.png)

Теперь нам нужно подключить Exchange к созданной череди через биндинг. По ключу my-key, exchange будет класть сообщения в очередь my-queue

![](_png/Pasted%20image%2020250124185950.png)

В самой очереди тоже появилась связь с передатчиком

![](_png/Pasted%20image%2020250124190136.png)

- Headers - это доп информация, которая нужна для очередей, использующих эти данные
- Properties - свойства сообщений (идентификатор приложения, путь ответа)
- Payload - сами данные сообщения

![](_png/Pasted%20image%2020250124185034.png)

Из Exchange мы можем передать сообщение по ключу роутинга в нашу очередь. Передать можно в любом виде

![](_png/Pasted%20image%2020250125093327.png)

Передача сразу отобразится на графике

![](_png/Pasted%20image%2020250125093414.png)

И теперь в самой очереди у нас появляется статистика о:
- Ready - сообщение пришло, но никем не разобрано. Если число стабильное, то что-то зависло.
- Unacked - необработанные сообщения
- Total - всего сообщений

![](_png/Pasted%20image%2020250125093458.png)

Так как у нас нет потребителей, привязанных к очереди, то мы можем только сами получить сообщение из поля Get messages. Там мы можем указать, что делать дальше с этим сообщением. 

- Ack mode - выбираем, что будет дальше при получении этих сообщений (накаем - возвращаем в очередь, акаем - убираем сообщение)
- Encoding - дефолтное преобразование
- Messages - количество сообщений

![](_png/Pasted%20image%2020250125093931.png)

График очереди так эе отображает:
- количество текущих запросов, которые висят
- rate limit очереди

![](_png/Pasted%20image%2020250125094249.png)

Свойства сообщения:
- Контент
	- `content_type` - тип контента (json, binary)
	- `content_encoding` - кодировка контента, чтобы правильно декодировать
	- `type` - тип контента (binary or not)
- Приоритизация
	- `priority` - приоритетность сообщения (чем выше, тем быстрее разбирают эти сообщения)
	- `expiration` - истечение запроса за определённое время
- Временная метка
	- `timestamp` - временной штамп
- Доставка сообщений
	- `correlation_id` - идентификатор сообщения, которое помогает понять сервису, что он получил ответ на определённое сообщение (связывает этот запрос с этим ответом)
	- `reply_to` - ожидает сообщение в определённой очереди
	- `message_id` - идентификатор конкретного сообщения, который понадобится для соотнесения `correlation_id`
- Адресат
	- `user_id` - от какого пользователя отправлено сообщение
	- `app_id` - идентификатор приложения (в логах можно сослаться на конкретное приложение)
	- `cluster_id` - идентификатор кластера RMQ

Свойства очереди:
- Durable - после перезагрузки очередь сохранится
- Exclusive - очередь может использоваться только в одном подключении и удалится после окончания
- Auto-delete - удаляется после потери последнего потребителя. Важно использовать эту опцию, чтобы не мусорить в RMQ и когда мы сами умеем создавать очереди
- Arguments - дополнительные аргументы (приоритеты, длина и прочее)

#### Реализация общения

Publisher кладёт в Exchange сообщение (с ключём роутинга, настройками (+ обязательным correlation_id) и пейлодом), которое через binding на определённый route кладётся в Queue, а оттуда разбирается подписчиком. Уже сам подписчик отправляет в ReplyQueue ответ с correlation_id (из запроса). Очередь ответов имеют эксклюзивный статус, чтобы к ней никто другой не мог подключиться - она существует конкретно для ответов этому паблишеру. 

Этот паттерн с Exchange является более правильным, так как у нас есть возможность подключить ещё один МС, который сможет получать по определённому ключу значения. Этого нельзя будет сделать без подписок через Exchange. 

![](_png/Pasted%20image%2020250125111227.png)

Чтобы реализовать уведомление, нам сейчас нужно просто класть в Exchange наше сообщение с ключом, которое закинет в нужные очереди сообщение, откуда подписчики их заберут.

![](_png/Pasted%20image%2020250125112351.png)

## Типы exchange

#### Direct

Это тип, который соотносит routing_key с наименованием биндинга и отправляет запросы только туда 

![](_png/Pasted%20image%2020250125112715.png)

#### Topic

Отправляет запрос по RegExp и ищет соответствия биндингов к ключу роутера

>[!important] Естественно, тут нужно определиться с конвенцией, по которой будут даваться имена

Например, можно давать имена по типу: `[domain].[action].[type]`. И выделить для себя из доменов МСы, из экшенов `[set, put, delete]`, а для type `[event, command]`

>[!example] courses.set.command

Это более предпочтительный вариант, чем Direct, потому что Topic ведёт себя ровно так же, но добавляет дополнительную логику задания сообщений

![](_png/Pasted%20image%2020250125113039.png)

#### Fanout

Отправляет сообщение всем прибинженным очередям вне зависимости от того, что они хотят получать

Используется для массовой рассылки уведомлений по всем подписчикам вне зависимости от того, что они планируют получать

![](_png/Pasted%20image%2020250125114843.png)

#### Headers

Он уже не смотрит на routing_key, а ориентируется на headers, который есть в сообщении. По этим заголовкам сообщение отправляется во все подписанные очереди, которые имеют такой же заголовок.

> Такой подход важен для сложных систем, где нужно сверять не только доменную область и тип сообщения, но и множество других параметров.

![](_png/Pasted%20image%2020250125120100.png)

#### Default

Отправляет почти напрямую запрос в указанную в routing_key очередь

![](_png/Pasted%20image%2020250125120538.png)

#### Dead Letter

Это очередь, которая собирает все мёртвые сообщения. 

К этой очереди могут подключиться и попробовать разобрать оттуда неправильно отправленные или разобранные сообщения

![](_png/Pasted%20image%2020250125120832.png)

#### Остальные

Trace - это трейсинг запросов. В этой очереди мы можем делать себе копии сообщений, которые были отправлены в процессе жизни другой очереди. 

![](_png/Pasted%20image%2020250125121414.png)

Match - это то же самое, что и Headers

Durability - это сохранение запросов после падения
Internal - это невозможность отправлять запросы напрямую от клиента, а только возможность биндингов с Exchange на Exchange

![](_png/Pasted%20image%2020250125121137.png)

## Администрирование RabbitMQ

Queued Messages. Если он постоянно заполнен, то какие-то потребители не могут разобрать сообщения.

Обычно все метрики из RMQ выносят в Prometheus / Grafana

Nodes. Тут отображаются все инстансы RMQ в кластере. 
- socket descriptors - количество занятых подключений к сокетам

![](_png/Pasted%20image%2020250125145351.png)

Так же мы можем попасть в такую ситуацию, что нам нужно будет переместить RMQ на другой сервер.

Самый идеальный вариант - код сам создаёт нужные Queue и Exchange, с которыми он будет работать. Либо можно дёрнуть API нашего менеджмент-плагина и создать нужные очереди через код.

Но в крайнем случае мы можем сами забэкапить все нужные реквизиты, которые у нас уже есть и развернуть их в другом месте.

![](_png/Pasted%20image%2020250125163723.png)

Иногда под каждый отдельный микросервис создают отдельного пользователя, чтобы из него выполнялись все операции. 

![](_png/Pasted%20image%2020250125164216.png)

Так же мы можем разделить группы микросервисов по виртуальным хостам, чтобы отделить их выполнение

![](_png/Pasted%20image%2020250125170051.png)

Указание лимитов по группам

![](_png/Pasted%20image%2020250125170350.png)

Изменение имени кластера

![](_png/Pasted%20image%2020250125170341.png)

Так же мы можем получить доступ к [HTTP API](http://localhost:15672/api/index.html) нашего иснтанса RMQ и выполнять все операции менеджерской панели прямо из нашей конфигурации.

Обычно для этого выделяют отдельный сервис, который выполняет всю настройку по конфигурации, а всем остальным сервисам отключают возможность создавать очереди и посредников. 

![](_png/Pasted%20image%2020250125170946.png)

## Код - Простой обмен сообщении

За работу с RMQ в ноде отвечает библиотека amqplib.

Описываем работу первого сервиса - паблишера. Он должен:
1. Коннектиться к RMQ
2. Добавлять exchange для отправки запросов
3. Создавать канал ответа. Канал должен быть `exclusive`, чтобы к нему не могли подключиться левые сервисы и чтобы очередь была удалена при отпадании сервиса. Эта очередь должна быть уникальной и использоваться только этим сервисом.
4. Публиковать данные в канал через `publish`

`publisher.ts`
```TS
import { connect } from 'amqplib';

const run = async () => {
	try {
		// подключаемся к RMQ
		const connection = await connect('amqp://localhost');
		// создаём канал, через который будем коммуницировать
		const channel = await connection.createChannel();
		// добавляем exchange с именем test и по типу topic
		await channel.assertExchange(
			'test', // имя
			'topic', // тип
			{ durable: true } // персистентная
		);
		// создаём replyQueue (канал ответов)
		const replyQueue = await channel.assertQueue(
			// без имени, так как овтет летит по replyTo 
			// и correlationId
			'',
			// удаляется с отключением МС 
			// и не имеет сторонних подключений
			{ exclusive: true }
		);
		// отрабатываем потребление ответа из очереди ответов 
		channel.consume(replyQueue.queue, (message) => {
			console.log(message?.content.toString());
			console.log(message?.properties.correlationId);
		})
		// отправляем в канал команду test с телом в виде буффера и хедером, в котором указаны путь ответа и correlationId
		channel.publish(
			'test', // имя exchange
			'my.command', // имя queue
			Buffer.from('Работает!'), // тело
			// параметры 
			{
				// указываем, на какую очередь нужно отсылать ответ
				replyTo: replyQueue.queue, 
				// уникализируем сообщение
				correlationId: '1' 
			}
		);
	} catch (e) {
		console.error(e);
	}
};

run();
```

И описываем работу второго сервиса - подписчика. Он должен:
1. Так же коннектиться
2. Создавать очередь
3. Создавать Exchange
4. А так же подвязываться под нужную очередь
5. Брать из подвязанной очереди запросы `consume` и отвечать через `sendToQueue`

`subscriber.ts`
```TS
import { connect } from 'amqplib';

const run = async () => {
	try {
		// коннект к RMQ
		const connection = await connect('amqp://localhost');
		// создание канала
		const channel = await connection.createChannel();
		// добавление exchange
		await channel.assertExchange(
			'test', 
			'topic', 
			{ durable: true }
		);
		// добавление очереди
		const queue = await channel.assertQueue(
			'my-cool-queue', 
			{ durable: true }
		);
		// привязка к очереди
		channel.bindQueue(queue.queue, 'test', 'my.command');
		// потребление очереди
		channel.consume(queue.queue, (message) => {
			if (!message) {
				return;
			}
			console.log(message.content.toString());
			if (message.properties.replyTo) {
				console.log(message.properties.replyTo);
				// отправка ответа на запрос тут мы напрямую указываем очередь, в которую полетит ответ, потому что нам не нужно чтобы exchange разруливал этот ответ
				channel.sendToQueue(
					message.properties.replyTo, 
					Buffer.from('Ответ'), 
					{ 
						// указываем в ответе correlationId сервиса, который отправил нам это сообщение
						correlationId: 
							message.properties.correlationId 
					}
				)
			}
		}, {
			// если true, то мы не будем автоматически признавать запрос
			noAck: true
		})
	} catch (e) {
		console.error(e);
	}
};

run();
```

>[!done] Теперь у нас реализован классический паттерн запрос/ответ RMQ

Мы использовали параметр `noAck`, чтобы сразу определять сообщения, как acknowledged или нет. Однако чтобы определить сообщение как опознанное, мы можем триггернуть команду `ack` канала и передать в него наше сообщение

`subscriber.ts`
```TS
channel.consume(queue.queue, (message) => {
	channel.ack(message)
	...
```

Сабскрайбер при поднятии паблишера получает сообщение

![](_png/Pasted%20image%2020250125174844.png)

И теперь на графиках можно увидеть запрос / ответ между сервисами. Запрос будет висеть в ready, потому что мы не отработали запрос и не перевели его в acknowledge

![](_png/Pasted%20image%2020250125174916.png)

Появился обменник test с нужным биндингом на очередь

![](_png/Pasted%20image%2020250125174958.png)

И была сгенерирована сама очередь

![](_png/Pasted%20image%2020250125175037.png)
