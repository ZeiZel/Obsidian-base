
## Устанавливаем RabbitMQ

Поднимаем композ с нужным образом

`docker-compose.yml`
```YML
services:
	rmq:
		image: rabbitmq:3-management
		restart: always
		ports:
			- "15672:15672" # админка
			- "5672:5672" # отправка сообщений
```

И, без заданных переменными пароля и логина, вводим для авторизации везде `guest`

## Устройство RabbitMQ

Наши микросервисы в схеме работы RMQ будут делиться на:
- Publisher -  публикует сообщения (отправитель)
- Subscriber - тот, кто подписывается на получение сообщений (получатель). Он достаёт сообщения из очереди.
- Queue - очередь (почтовый ящик). Сюда перенаправляются сообщения. 
- Exchange - обменный ящик (почтовое отделение). Решает, как доставить сообщение адресату и получает все сообщения.

- Routing Key - маршрут передачи сообщения. Это ключ, который указывает, куда отправить сообщение
- Binding - связь очереди с маршрутом. Помогает Exchange понимать, по какому Routing Key в какоую Queue нужно отправлять сообщение.
- Channel - канал передачи/приёма сообщения.
- Connection - соединение клиента RMQ

![](_png/Pasted%20image%2020250120183234.png)

Тут у нас отображены все connections к нашему RMQ из всех сервисов. 

Мы можем развернуть несколько инстансов RMQ и объединить их в кластер, чтобы поднять отказоустойчивость.

![](_png/Pasted%20image%2020250124181517.png)

Все каналы для передачи сообщений

![](_png/Pasted%20image%2020250124184402.png)

Тут отображены дефолтные очереди

![](_png/Pasted%20image%2020250124184924.png)

Отображение, создание и управление очередьми

![](_png/Pasted%20image%2020250124184956.png)

Создаём директовый Exchange с произвольным именем, который будет определять тип нашего сообщения.

![](_png/Pasted%20image%2020250124185133.png)

Далее создаём очередь, которая будет классического типа (quorum - это более персистентная, а stream - поток), durable (сохраняется после падения) и не auto delete (не будет удаляться при отключении всех пользователей).

![](_png/Pasted%20image%2020250124185359.png)

Теперь нам нужно подключить Exchange к созданной череди через биндинг. По ключу my-key, exchange будет класть сообщения в очередь my-queue

![](_png/Pasted%20image%2020250124185950.png)

В самой очереди тоже появилась связь с передатчиком

![](_png/Pasted%20image%2020250124190136.png)

- Headers - это доп информация, которая нужна для очередей, использующих эти данные
- Properties - свойства сообщений (идентификатор приложения, путь ответа)
- Payload - сами данные сообщения

![](_png/Pasted%20image%2020250124185034.png)

Из Exchange мы можем передать сообщение по ключу роутинга в нашу очередь. Передать можно в любом виде

![](_png/Pasted%20image%2020250125093327.png)

Передача сразу отобразится на графике

![](_png/Pasted%20image%2020250125093414.png)

И теперь в самой очереди у нас появляется статистика о:
- Ready - сообщение пришло, но никем не разобрано
- Unacked - необработанные сообщения
- Total - всего сообщений

![](_png/Pasted%20image%2020250125093458.png)

Так как у нас нет потребителей, привязанных к очереди, то мы можем только сами получить сообщение из поля Get messages. Там мы можем указать, что делать дальше с этим сообщением. 

- Ack mode - выбираем, что будет дальше при получении этих сообщений (накаем - возвращаем в очередь, акаем - убираем сообщение)
- Encoding - дефолтное преобразование
- Messages - количество сообщений

![](_png/Pasted%20image%2020250125093931.png)

Разраборы так же указываются на графике очереди

![](_png/Pasted%20image%2020250125094249.png)

Свойства сообщения:
- Контент
	- `content_type` - тип контента (json, binary)
	- `content_encoding` - кодировка контента, чтобы правильно декодировать
	- `type` - тип контента (binary or not)
- Приоритизация
	- `priority` - приоритетность сообщения (чем выше, тем быстрее разбирают эти сообщения)
	- `expiration` - истечение запроса за определённое время
- Временная метка
	- `timestamp` - временной штамп
- Доставка сообщений
	- `correlation_id` - идентификатор сообщения, которое помогает понять сервису, что он получил ответ на определённое сообщение (связывает этот запрос с этим ответом)
	- `reply_to` - ожидает сообщение в определённой очереди
	- `message_id` - идентификатор конкретного сообщения, который понадобится для соотнесения `correlation_id`
- Адресат
	- `user_id` - от какого пользователя отправлено сообщение
	- `app_id` - идентификатор приложения (в логах можно сослаться на конкретное приложение)
	- `cluster_id` - идентификатор кластера RMQ

Свойства очереди:
- Durable - после перезагрузки очередь сохранится
- Exclusive - очередь может использоваться только в одном подключении и удалится после окончания
- Auto-delete - удаляется после потери последнего потребителя
- Arguments - дополнительные аргументы (приоритеты, длина и прочее)




## Типы exchange









## Администрирование RabbitMQ









## Код - Простой обмен сообщении_1









## Код - Реализация запрос - ответ













