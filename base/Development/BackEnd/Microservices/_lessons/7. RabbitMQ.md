
## Устанавливаем RabbitMQ

Поднимаем композ с нужным образом

`docker-compose.yml`
```YML
services:
	rmq:
		image: rabbitmq:3-management
		restart: always
		ports:
			- "15672:15672" # админка
			- "5672:5672" # отправка сообщений
```

И, без заданных переменными пароля и логина, вводим для авторизации везде `guest`

## Устройство RabbitMQ

Наши микросервисы в схеме работы RMQ будут делиться на:
- Publisher -  публикует сообщения (отправитель)
- Subscriber - тот, кто подписывается на получение сообщений (получатель). Он достаёт сообщения из очереди.
- Queue - очередь (почтовый ящик). Сюда перенаправляются сообщения. 
- Exchange - обменный ящик (почтовое отделение). Решает, как доставить сообщение адресату и получает все сообщения.

- Routing Key - маршрут передачи сообщения. Это ключ, который указывает, куда отправить сообщение
- Binding - связь очереди с маршрутом. Помогает Exchange понимать, по какому Routing Key в какоую Queue нужно отправлять сообщение.
- Channel - канал передачи/приёма сообщения.
- Connection - соединение клиента RMQ

![](_png/Pasted%20image%2020250120183234.png)

Тут у нас отображены все connections к нашему RMQ из всех сервисов. 

Мы можем развернуть несколько инстансов RMQ и объединить их в кластер, чтобы поднять отказоустойчивость.

![](_png/Pasted%20image%2020250124181517.png)

Все каналы для передачи сообщений

![](_png/Pasted%20image%2020250124184402.png)

Тут отображены дефолтные очереди

![](_png/Pasted%20image%2020250124184924.png)

Отображение, создание и управление очередьми

![](_png/Pasted%20image%2020250124184956.png)

Создаём директовый Exchange с произвольным именем, который будет определять тип нашего сообщения.

![](_png/Pasted%20image%2020250124185133.png)

Далее создаём очередь, которая будет классического типа (quorum - это более персистентная, а stream - поток), durable (сохраняется после падения) и не auto delete (не будет удаляться при отключении всех пользователей).

![](_png/Pasted%20image%2020250124185359.png)

Теперь нам нужно подключить Exchange к созданной череди через биндинг. По ключу my-key, exchange будет класть сообщения в очередь my-queue

![](_png/Pasted%20image%2020250124185950.png)

В самой очереди тоже появилась связь с передатчиком

![](_png/Pasted%20image%2020250124190136.png)

- Headers - это доп информация, которая нужна для очередей, использующих эти данные
- Properties - свойства сообщений (идентификатор приложения, путь ответа)
- Payload - сами данные сообщения

![](_png/Pasted%20image%2020250124185034.png)

Из Exchange мы можем передать сообщение по ключу роутинга в нашу очередь. Передать можно в любом виде

![](_png/Pasted%20image%2020250125093327.png)

Передача сразу отобразится на графике

![](_png/Pasted%20image%2020250125093414.png)

И теперь в самой очереди у нас появляется статистика о:
- Ready - сообщение пришло, но никем не разобрано
- Unacked - необработанные сообщения
- Total - всего сообщений

![](_png/Pasted%20image%2020250125093458.png)

Так как у нас нет потребителей, привязанных к очереди, то мы можем только сами получить сообщение из поля Get messages. Там мы можем указать, что делать дальше с этим сообщением. 

- Ack mode - выбираем, что будет дальше при получении этих сообщений (накаем - возвращаем в очередь, акаем - убираем сообщение)
- Encoding - дефолтное преобразование
- Messages - количество сообщений

![](_png/Pasted%20image%2020250125093931.png)

Разраборы так же указываются на графике очереди

![](_png/Pasted%20image%2020250125094249.png)

Свойства сообщения:
- Контент
	- `content_type` - тип контента (json, binary)
	- `content_encoding` - кодировка контента, чтобы правильно декодировать
	- `type` - тип контента (binary or not)
- Приоритизация
	- `priority` - приоритетность сообщения (чем выше, тем быстрее разбирают эти сообщения)
	- `expiration` - истечение запроса за определённое время
- Временная метка
	- `timestamp` - временной штамп
- Доставка сообщений
	- `correlation_id` - идентификатор сообщения, которое помогает понять сервису, что он получил ответ на определённое сообщение (связывает этот запрос с этим ответом)
	- `reply_to` - ожидает сообщение в определённой очереди
	- `message_id` - идентификатор конкретного сообщения, который понадобится для соотнесения `correlation_id`
- Адресат
	- `user_id` - от какого пользователя отправлено сообщение
	- `app_id` - идентификатор приложения (в логах можно сослаться на конкретное приложение)
	- `cluster_id` - идентификатор кластера RMQ

Свойства очереди:
- Durable - после перезагрузки очередь сохранится
- Exclusive - очередь может использоваться только в одном подключении и удалится после окончания
- Auto-delete - удаляется после потери последнего потребителя. Важно использовать эту опцию, чтобы не мусорить в RMQ и когда мы сами умеем создавать очереди
- Arguments - дополнительные аргументы (приоритеты, длина и прочее)

#### Реализация общения

Publisher кладёт в Exchange сообщение (с ключём роутинга, настройками (+ обязательным correlation_id) и пейлодом), которое через binding на определённый route кладётся в Queue, а оттуда разбирается подписчиком. Уже сам подписчик отправляет в ReplyQueue ответ с correlation_id (из запроса). Очередь ответов имеют эксклюзивный статус, чтобы к ней никто другой не мог подключиться - она существует конкретно для ответов этому паблишеру. 

Этот паттерн с Exchange является более правильным, так как у нас есть возможность подключить ещё один МС, который сможет получать по определённому ключу значения. Этого нельзя будет сделать без подписок через Exchange. 

![](_png/Pasted%20image%2020250125111227.png)

Чтобы реализовать уведомление, нам сейчас нужно просто класть в Exchange наше сообщение с ключом, которое закинет в нужные очереди сообщение, откуда подписчики их заберут.

![](_png/Pasted%20image%2020250125112351.png)

## Типы exchange

#### Direct

Это тип, который соотносит routing_key с наименованием биндинга и отправляет запросы только туда 

![](_png/Pasted%20image%2020250125112715.png)

#### Topic

Отправляет запрос по RegExp и ищет соответствия биндингов к ключу роутера

>[!important] Естественно, тут нужно определиться с конвенцией, по которой будут даваться имена

Например, можно давать имена по типу: `[domain].[action].[type]`. И выделить для себя из доменов МСы, из экшенов `[set, put, delete]`, а для type `[event, command]`

>[!example] courses.set.command

Это более предпочтительный вариант, чем Direct, потому что Topic ведёт себя ровно так же, но добавляет дополнительную логику задания сообщений

![](_png/Pasted%20image%2020250125113039.png)

#### Fanout

Отправляет сообщение всем прибинженным очередям вне зависимости от того, что они хотят получать

Используется для массовой рассылки уведомлений по всем подписчикам вне зависимости от того, что они планируют получать

![](_png/Pasted%20image%2020250125114843.png)

#### Headers

Он уже не смотрит на routing_key, а ориентируется на headers, который есть в сообщении. По этим заголовкам сообщение отправляется во все подписанные очереди, которые имеют такой же заголовок.

> Такой подход важен для сложных систем, где нужно сверять не только доменную область и тип сообщения, но и множество других параметров.

![](_png/Pasted%20image%2020250125120100.png)

#### Default

Отправляет почти напрямую запрос в указанную в routing_key очередь

![](_png/Pasted%20image%2020250125120538.png)

#### Dead Letter

Это очередь, которая собирает все мёртвые сообщения. 

К этой очереди могут подключиться и попробовать разобрать оттуда неправильно отправленные или разобранные сообщения

![](_png/Pasted%20image%2020250125120832.png)

#### Остальные

Trace - это трейсинг запросов. В этой очереди мы можем делать себе копии сообщений, которые были отправлены в процессе жизни другой очереди. 

![](_png/Pasted%20image%2020250125121414.png)

Match - это то же самое, что и Headers

Durability - это сохранение запросов после падения
Internal - это невозможность отправлять запросы напрямую от клиента, а только возможность биндингов с Exchange на Exchange

![](_png/Pasted%20image%2020250125121137.png)

## Администрирование RabbitMQ









## Код - Простой обмен сообщении_1









## Код - Реализация запрос - ответ













