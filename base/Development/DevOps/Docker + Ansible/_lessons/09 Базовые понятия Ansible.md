#Ansible

Ansible - это утилита для автоматиизации выполнения скриптов.

## Задачи Ansible

Для чего нам нужно его использовать:

1. **Автоматиизирует повторяющиеся задачи**. Сразу позволяет выполнить все нужные операции на большом количестве машин.
2. **Автоматизирует сложные задачи**. Позволяет повторять сложные задачи раз за разом без совершения определённых ошибок.
3. **Поддерживает IAC концепцию** (инфраструктура как код).

Какие задачи он решает:

1. Отметает человеческий фактор при исполнении скриптов.
2. Решает проблему недостатка прозрачности настроек и документации
3. Устраняет сложность повторения определённой операции
4. Экономит кучу времени
5. Повышает переносимость решения

Какие плюсы именно Ansible:

1. Нет доп ПО на сервере - только python
2. Можно легко дописывать свои модули
3. Низкий порог вхождения
4. Возможность интеграции API через AWX (через который можно настроить автоматическое выполнение скриптов и scheduling)

## Схема работы Ansible

1. **YML-конфиг** (то, что мы выполняем). Описывает то состояние, к которому нам нужно привести сервера. Тут мы описываем последовательно состояние, к которому мы должны привести систему.
2. **Инвентарь** (на чём выполняем). Это модуль. Описывает все сервера, их состояния, как к ним подключаться, под какими пользователями выполнять операции, ip и переменные.
3. **Ansible**. Он уже приводит сервера к описанному ранее состоянию.
	1. Первым делом, он собирает **факты о серверах**. Подключается / не подключается, тип ОС, прпоисходит первичный коннект.
	2. **Сборка конфигов с серверов**.
	3. Подключение плагинов
	4. Подключение модулей
4. **Транспиляция YAML в python и исполнение кода**. Все конфигурации разбираются на одной хостовой машине в самом Ansible.

![](_png/Pasted%20image%2020250104234939.png)

Системы автоматизации обычно делятся на pull и push. Pull требуют наличия агента на серверах, чтобы проверять изменения и подтягивают исполняемый конфиг сами в себя. Push уже требуют, чтобы мы зсами запихнули конфиг на сервер, чтобы тот выполнился. Второй вариант является более удобным, так как не требует на сервере никакого дополнительного ПО и агентов. 

Когда мы используем Ansible на том же Ubuntu сервере (на котором уже есть python) нам не нужно ничего устанавливать кроме ssh, который позволит исполнять нам удалённо скрипты.

Модули и плагины - это подключаемые к Ansible куски кода. 
Сами отличия:

| Модули                      | Плагины                    |
| --------------------------- | -------------------------- |
| Выполняются на клиентах     | Выполняются на host-машине |
| Выполняются при подключении | Выполняются до подключения |

## Установка

Через любой пакетный мендежер (включая `pip`)

```bash
brew install ansible

# Или

sudo [apt|dnf|pacman] install ansible
```

## Inventory

Инвентарь - это описание всех хостов и серверов, на которых будут исполняться команды Ansible и playbooks.

Написать конфиг инвентаря можно с помощью менее многословного `.ini` либо через `.yml`

Когда мы указываем домены `[group]` в квадратных скобках, то мы можем исполнять скрипты на целых группах доменов. Такие группы можно, например, использовать для установки nginx на множество серверов.

![](_png/Pasted%20image%2020250105111959.png)

Так же мы можем:
1. Если у машины есть порядковые номера, то можно указать период
2. Можем использовать определённые переменные
3. Так же можно для сервера без названия указать алиас, к которому будет удобно обращаться (так на третьем примере сервер будет называться `coolhost`, а не `192.68...`)

![](_png/Pasted%20image%2020250105112523.png)

4. Так же можно спокойно указать переменные для группы через `[group:vars]`

![](_png/Pasted%20image%2020250105113053.png)

Параметры подключения к хосту состоят из 4ёх блоков:
1. Параметры подключения
	- connection - ssh / sftp / scp
	- host - имя хоста, к которому подключаемся
	- port - порт (тут может понадобится кастомный ssh-порт не 22, а 2222)
	- user - имя пользователя
	- password - пароль. Используется, если не заданы ssh-ключи для подключения.
2. Параметры ssh / scp / sftp
	- private_key_file - путь к приватному ключу, но дефолтно используется файл в `.ssh`
	- common_args - общие аргументы для всех типов подключения
	- extra_args - дополнительные аргументы
	- pipelining - ограничение количества ssh-подключений (чтобы не открывать 100 подключений одновременно)
	- executable - дополнительная настройка выполнения
3. Привилегии (применение команды из под sudo)
	- become - нужно ли выполнять от sudo
	- method - метод перехода (su/sudo)
	- exe, flags - настраивает поведение перехода к sudo
4. Настройки shell
	- shell_type - выбор shell (bash/zsh)
	- интерпретатор питона
	- екзекутер скрипта

![](_png/Pasted%20image%2020250105113153.png)

Напишем файл инвентаря нашего клиента. Тут мы описали сервер, который крутится у нас на localhost и подключаемся к нему по заданному пользователю. Порт другой, чтобы не занимать наш корневой ssh.

`hosts.ini`
```
[demo]
127.0.0.1 ansible_user=zeizel ansible_port=2222
```

Далее через `-i` указываем путь к инвентарю и дёргаем модуль `ping` из ansible по всей группе доменов `demo`

```bash
ansible -i hosts.ini -m ping demo
```

И далее нам прилетел ответ с сервера (на котором у нас стоял python, чтобы триггернуть эту операцию)

![](_png/Pasted%20image%2020250106235215.png)

## Modules

Модули - это отдельные блоки кода, которые можно использовать для выполнения команд на хостах и сбора возвращаемых значений.

- service - поднимает сервис
- command - выполняет команду в shell

```bash
# пример использования модуля service и передачи в него аргументов -a
ansible webservers -m service -a "name=httpd state=started"

# указание модуля -m и аргументов -a
ansible webservers -m command -a "/sbin/reboot -t now"
```

Генерирует документацию

```bash
ansible-doc user
```

## Ad-hoc

Ad-hoc - это команда для быстрого выполнения скрипта, которую мы не хотим сохранять для дальнейшего использования.

Используется для:
- быстрых фиксов (например, упал сервер)
- для получения информации с сервера
- для тестирования отдельных команд

Это аналог `docker run -it sh`, когда мы напрямую попадаем в крутящийся докер и выполняем в нём команды.

Ad-hoc команда выглядит следующим образом:
- инвентарь
- модуль - только один в ad-hoc
- аргументы
- указание хостов (all / ip / группа)

Текущая команда создаст определённого пользователя по `name` на всех хостах

![](_png/Pasted%20image%2020250107001230.png)

Теперь, после выполнения команды, мы знаем, что пользователь представлен на сервере.

У нас есть несколько типов вывода:
1. Success - Зелёный - операция ничего не изменила
2. Changed - Жёлтый - операция что-то изменила
3. Failed - Красный - операция не выполнена

![](_png/Pasted%20image%2020250107001643.png)

Чтобы операция выполнилась от sudo, добаляем `become` as `-b` и запрашиваем интерактивно пароль через `-K`. Это первый способ использования sudo.

![](_png/Pasted%20image%2020250107001928.png)

![](_png/Pasted%20image%2020250107002006.png)

Ну и поменяв параметр на absent мы удаляем пользователя из системы (потому что тут мы декларативно управляем пользователями системы)

![](_png/Pasted%20image%2020250107002221.png)

Второй способ - параметры. Так же вместо ключей мы можем просто передать всё параметрами через `-e`

```bash
ansible -i hosts -m user -a "name=zeizel state=absent" -e "ansible_become=true ansible_become_password=123" demo
```

Так же можно пойти третьим способом и выполнить операцию от sudo, передав все параметры сразу в инвентарь.

>[!warning] Это нерекоммендуемый способ, так как в инвентарь класть секретные данные - плохо!
>Положить ip, алиас - это норм. Но работать с паролем и командами - это задача отдельного домена.

`hosts.ini`
```
[demo]
127.0.0.1 ansible_user=zeizel ansible_port=2222 ansible_become=true ansible_become_password=123
```

И дёрнуть

```bash
ansible -i hosts -m user -a "name=zeizel state=absent" demo
```
