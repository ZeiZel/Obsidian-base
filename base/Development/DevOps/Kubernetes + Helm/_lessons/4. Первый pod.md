
## О приложении

Приложение для сокращения ссылок:
- app производит сокращение
- api общается с app
- postgresql занимается хранением данных о ссылках 
- `create` / `delete` / `getAll` - создают, удаляют и получают все ссылки
- `/<rest>` - тут уже происходит редирект

![](_png/Pasted%20image%2020250622092936.png)

## Первый POD

 Главное отличие pod от контейнера заключается в том, что это может быть абстракция над несколькими контейнерами. То есть мы можем запустить контейнер с PGSQL и контейнер, который будет его бэкапить.  

![](_png/Pasted%20image%2020250622095427.png)

Далее укажем такую конфигурацию, в которой будет:
- находиться наш собственный image с docker-образом приложения
- в `ports` укажем `containerPort`, который нам нужно прокинуть наружу, чтобы иметь доступ для получения статики сайта от NGINX
- обязательно указываем `resources`, в котором у нас стоят лимиты, при достижении которых, наш сервис будет перезапущен

`pod.yml`
```YAML
---
apiVersion: v1
kind: Pod
metadata:
  name: short-app
  labels:
    components: frontend
spec:
  containers:
    - name: short-app
      image: antonlarichev/short-app
      ports:
        - containerPort: 80 # прокидываем наружу порт контейнера с NGINX
      # обязательно указываем максимальные ресурсы, которые может кушать контейнер
      resources:
        limits:
          memory: "128mi" # mi - mb
          cpu: "500m" # m - miliprocessors - величина относительная к процессору, но указывает количество доступной нагрузки
```

## Сервис

Сервис позволяет держать с контейнером постоянную связь. Без сервиса нам придётся полчать связь каждый раз по IP, который может в любой момент поменяться после редеплоя , если сервис уйдёт в memory leak или упадёт. 

Сервисы бывают 4ёх типов:
- Ingress - позволяет получить доступ к контейнеру извне
- NodePort - позволяет прокинуть порт изнутри контейнера наружу 
- ClusterIP
- LoadBalancer - балансирует нагрузку

Пользователь обращается к IP-адресу кластера, где запрос уходит на прокси, который проксирует все запросы от кластера до определённого сервиса. Потом на сервис, который прокидывает порт из POD в мир. 
 
![](_png/Pasted%20image%2020250622154540.png)

Kube-Proxy требует, чтобы в конфиге было понятно, откуда и куда какой порт проксировать. Поэтому нам нужно будет указать в спеках порты прохода запросов.

- `nodePort` говорит, что при обращении к кластеру по данному порту, мы должны прокинуть запрос в определённый сервис (в котором мы указали этот порт)
- `targetPort` говорит нам на какой порт пода мы должны стучаться, когда уже попали в сервис
- `port` - это внутренний порт для кластера, по которому другие поды смогут достучаться до нашего пода

Для доступа извне нам нужна связка `nodePort` и `targetPort`. В нашем случае, `targetPort` будет равен `containerPort` из конфига пода, так как через таргетпорт нам нужно достучаться до приложения извне кластера 

![](_png/Pasted%20image%2020250622155305.png)

Дальше нам останется только привязать сервис к определённому поду через селектор. В качестве селектора будет выступать заданный ранее лейбл в поде

`node-port.yml`
```YAML
---
apiVersion: v1
kind: Service
metadata:
  name: short-app-port
spec:
  type: NodePort
  # порты для доступа к контейнеру извне кластера
  ports:
   - port: 3000
     targetPort: 80
     nodePort: 31200
  # селектор для связи пода и сервиса
  selectors:
    components: frontend
```





## Подключение к контейнеру







## Как работает запуск





















































