#tsconfig

### 051 Вводное видео

Сама архитектура ТС:

![](_png/144bdf7d4a43de2d5ac8b231825f452d.png)

### 052 Включение и исключение файлов

Нужно упомянуть, что мы можем сами выбирать, какие файлы мы можем компилировать

```bash
tsc // скомпилирует весь проект
tsc имя_файла1 имя_файла2 // скомпилирует определённые файлы
```

Так же нужно упомянуть, что файл *tsconfig* - олицетворяет для ТС проект и его удаление приведёт к ошибке компиляции 

И тут уже стоит пойти про модификацию тсконфига. Первым делом нужно сказать, что внутри конфига (вне опций компилятора) мы можем определять, какие файлы будут подлежать компиляции. Свойство `files` принимает в себя массив значений, которые будем компилировать

![](_png/48d938d803cd9eb96d43674829373406.png)

Уже `include` поддерживает паттерны, через которые можно определить, какие файлы мы будем компилировать

![](_png/724e99be6f3441516c442604ec4f79c0.png)

`exclude` исключает из компиляции те указанные файлы в `include` и в `files`

![](_png/07eb9d86715283e9068bbfe1e33b81bd.png)

Данный параметр позволяет нам дополнить наш основной конфиг другим *tsconfig* (дополнение и переопределение существующих параметров внешним)

```JSON
"extends": "",
```

Так же нужно упомянуть полезные параметры внутри опций компилятора. Они позволяют аккуратно переводить старый проект на нативном JS в TS и делать его проверки

![](_png/de6c4ddd228f47e04d33f62f227651fa.png)

### 053 Вывод компиляции

Первым делом нужно разобрать отдел `Emit` в настройках компиляции. Он отвечает за вывод компиляции

Первый параметр - `outDir`. Он определяет папку вывода компиляции. 
Уже `outFile` используют куда реже, так как те же модули не получится через него скомпилировать

![](_png/42b0701f9213f06ba8596fd120c442cf.png)

```JSON
{
	"removeComments": true, // ремувнет комментарии в выводимом файле
	"noEmit": true, // позволяет проверить файлы, но не выводить их куда-либо
	"noEmitOnError": true, // запрещает компиляцию при ошибке в коде
	"importHelpers": true, // импортирует хелперы один раз для всего проекта. Позволяет уменьшить размер файла
	// Хелперы - это дополнительные функции из ТС-либы, которые выступают полифиллами между ТС и JS 
	"noEmitHelpers": true, // не компилирует хелперы ТС. 
	"importsNotUsedAsValues": "remove", // удаляет импорты типов из JS (будущая тема). Есть исключения, когда их нужно сохранить, но это бывает редко
	"sourceMap": true // связывает JS-файлы с TS файлами (генерирует вместе с обычным JS файлом ".map", который и реализует связь)
}
```

![](_png/db75ca6325f0954223eb36d047c090e6.png)

`"inlineSourceMap": true` - заменяет стоковый сурсмап на инлайновый, но уже внутри скомпилированного JS (использовать можно только прошлую настройку, либо эту - вместе они не работают)

```JS
"use strict";  
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwMi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3RzL2FwcDIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiJ9
```

```JSON
{
	"inlineSources": true, //  впишет вообще весь сурс-код ТС в компилируемый файл (в виде инлайн-строки). Эта настройка больше актуальна для бэка
	"sourceRoot": "",      // будет искать сурс по определённому пути
	"mapRoot": ""          // будет искать мапу по нужному пути
}
```

`"declaration": true` - создаёт файл, где будет показана декларация всех интерфейсов и классов (без определённой реализации)

![](_png/5aba65af87afbccffd2db5a5f7a395ab.png)

`"emitDeclarationOnly": true` - компилирует только декларации ТС
`"declarationDir": "./types/"` - сохраняет декларации по определённому пути

![](_png/1c8d9389ea16c56671e03063f53361ae.png)

`"stripInternal": true`- не компилирует модуль, который был помечен комментарием - `/ * @internal * / `

```TS
/* @internal */  
class Delivery {  
    constructor(  
        public date: Date  
    ) {  
    }
}
```

`"preserveConstEnums": true` - сохраняет отдельно код `enum` в виде объекта констант в JS

### 054 Язык и окружение

Блок настроек язык и окружение отвечает за общую внешнюю работу компилятора 

В таргете мы указываем в какую версию JS мы компилируем файл

![](_png/9754a2eeffc7d662b5cb45c1c46de755.png)

Настройка `lib` хранит в себе массив тех библиотек, которые будут подключены к TS. Изначально библиотека с консолью или Math уже подключены к нашему файлу, но если нам нужно будет немного обособить среду или добавить свои полифиллы, то нам нужно будет самостоятельно подключить все нужные библиотеки к нашей среде

![](_png/db830063651f9d8812780c3c6d642ab2.png)

Ниже идут настройки непосредственно jsx компиляции ТС

```JSON
{
	"jsx": "preserve",
	"jsxFactory": "",                               
	"jsxFragmentFactory": "",                      
	"jsxImportSource": "",
	"noLib": true, // отключает все библиотеки в ТС
	"useDefineForClassFields": true // включение использования ECMAScript формата классов (эни компилируется в объект с defineProperty)
}
```

### **055 Модули**

Блок настроек *Modules* определяет как будет компилироваться проект из модулей относительно друг друга

```JSON
{
	"module": "commonjs", // способ модулирования (стандартный)
	"rootDir": "./", // расположение компиляции всего проекта
	"baseUrl": "./", // базовый url для резолва модулей. Часто комбинируется с путями
	"paths": {} // пути. Позволяют задать алиасы для путей в проектах, где используются модули и репозитории. Очень удобно использовать, чтобы не переписывать постоянно длинные пути
}
```

```JSON
"baseUrl": "./",
"paths": {  
	// ключ - алиас, значение - путь
	"@lib": ["./lib/lib-path"]  
},
```

```TS
import {} from "@lib/файл.js";
```

```JSON
{
	"rootDirs": [], //используется замен рутдира для объединения проекта в одну дирректорию
	"typeRoots": [], //ищет дополнительные типы для библиотек, которые будем устанавливать
	"resolveJsonModule": true // позволяет импортировать JSON в ТС, конвертировать его в объект и сразу с ним работать. Используется опция для работы с конфигурациями
}
```

### 056 Strict режим

```JSON
/* Type Checking */  
"strict": true, 
 "noImplicitAny": true,  
 "strictNullChecks": true, 
 "strictFunctionTypes": true,   
 "strictBindCallApply": true,  
 "strictPropertyInitialization": false,
```

```JSON
{
	"noImplicitAny": true, // запрещаем неявно задавать any (автоматическая подстановка any). Желательно  закомментировать в новых ТС проектах либо поставить true. Мы сможем как и прежде использовать any, но мы будем знать, что мы не смогли типизировать объект 
	"strictNullChecks": true // позволяет избегать неявного возвращения из функции null или undefined.
}
```

![](_png/a9eab2129573f4015e3bc1c7ab514525.png)

`"strictFunctionTypes": true` - проверяет вкладываемые типы в функцию
Вот пример, когда мы присваиваем функцию в определённый тайп с выключенной настройкой

![](_png/e55d6eecc557c526064e623daaedf117.png)

А вот с включённой настройкой

![](_png/eff251f4a226570e21090235d5717c22.png)

`"strictBindCallApply": true` - отвечает за типизацию тех же тестов в ТС и их корректность

```TS
test.apply(undefined, [1, 3]); // Error
```

`"strictPropertyInitialization": false` - обязует инициализировать свойства классов. Обычно ставят false для использования контрактной системы и классов в качестве интерфейсов

`"noImplicitThis": true` - проверяет переменные контекста this
Конкретно в данном случае, запись функции через function() определяет контекст вызова внутри себя (свои переменные) \

![](_png/db80f7b1f5f79b6cba4d59b982234f4a.png)

`"useUnknownInCatchVariables": true` - определяет современное поведение error (он имеет тип unknown). Стоит всегда оставлять true, так как еррор приобретёт тип any. Данный тип, например, позволит обратиться error.massage, а тот, в свою очередь, не всегда будет содержать ошибку

`"alwaysStrict": true` - добавляет дирриктиву стрикта в JS  

### 057 Проверки кода

`"noUnusedLocals": true` - подсвечивает объявленные, но не прочитанные свойства (помогает избавиться от лишних переменных)
`"noUnusedParameters": true` - подсвечивает аргументы функции, которые мы не используем в самой функции

Так же у нас имеется `@ts-ignore`, который игнорирует ошибки в одной следующей строке после комментария

```TS
// @ts-ignore  
const defualtUser = new User("Defult");
```

Так же нужно упомянуть, что мы можем сократить запись конструктора и сразу создать внутреннее свойство - публичный нейм, добавить его в конструктор и присвоить при инициализации

```TS
class User {  
    name: string;  
  
    constructor(name: string) {  
        this.name = name;  
    }  
}
```

```TS
class User {  
    constructor(public name: string) {  
        this.name = name;  
    }  
}
```

Однако, если мы с настройкой `noUnusedParameters` попробуем записать приватное поле сразу в конструкторе, то опять получим ошибку (так как параметр не получится присвоить и он будет пустой)

```TS
class User {  
    constructor(private name: string) {  // Error
        this.name = name;  
    }  
}
```

`"exactOptionalPropertyTypes": true` - запрещает присваивать опциональным свойствам класса значение `undefined`

![](_png/6c775f0cd2f9ff96b01cf95b342a0127.png)

`"noFallthroughCasesInSwitch": true` - не выполняет следующий кейс, если мы не написали `break` или `return` (без настройки в данном примере выполнились бы сразу оба кейса)

![](_png/ef761dc1798082256824c6bad6c30b1a.png)

`"allowUnreachableCode": true` - код, который не получится достичь и выполнить, будет подсвечиваться как недостижимый

![](_png/3c789cb6e0e014b3a54d8a2c80ef9c8f.png)

`"noUncheckedIndexedAccess": true` - если мы будем обращаться к объекту, интерфейс которого нечётко задан, мы можем позволить себе вернуть undefined

В этот интерфейс попадает любой объект со свойством строка и значением булеан. Конкретно тут со включенной настройкой, мы получим юнион между `(boolean | undefined)`, что позволит нам избежать ошибок в коде (так как у нас нет свойства `drive` в константе `c`)

![](_png/b0cbc2eea713c2072d73f3e937e1b806.png)

`"noPropertyAccessFromIndexSignature": true` - запрещает обращаться к несуществующему ключу объекта через точечную запись (не создаст новый ключ при обращении).
Требует использования обращения через 

```TS
c["имя_ключа"]
```

`"noImplicitOverride": true` - заставляет всегда явно задавать `override` при наследовании (стоит всегда включать)