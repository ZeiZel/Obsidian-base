
### 001 Введение в классы и прототипы

![](_png/b521d9d1efae76cf84d72e63aca1b8d1.png)![](_png/4aa0e82c55dd4aba3b3e003631151617.png) ![](_png/3b05d3852b1adb03b6dd9961d7a47df7.png)

### 002 Пример класса

Класс – это шаблон для написания экземпляров класса.

Тут показан пример создания экземпляра комментария.

При обращении через `this`, мы обращаемся к элементу класса комментария. Когда мы пишем `this.text = text` (а в конструктор нам передаётся этот самый текст), то мы говорим, что тексту класса комменарий будет присвоено значение текста извне.

Методы `constructor()` и `upvote()` будут наследоваться всеми дочерными элементами класса комментария (то есть ими можно будет воспользоваться из дочерних элементов этого класса)

То есть это работает как методы высшего порядка для массивов (тот же `forEach`, который можно увидеть в прототипе массива)

![](_png/18065cb7e327462e75da1df4bdd55cbe.png)

### 003 Создание экземпляров класса

Создание нового экземпляра происходит через синтаксис:

`ключевое_слово переменная = new названиеКласса(«аргументы»)`

![](_png/34715a91baa760ea70bdc0e2f26eab24.png)

При выводе данного экземлпяра, мы можем увидеть его собственные свойства и в прототипе увидеть его методы, которые располагаются в классе.

**Собственными** свойствами тут являются: `text` и `votesQty`

**Унаследованным** методом тут является метод `upvote` (унаследован с родительского класса `Comment`)

![](_png/7e5eb14dda60f402eb9d7b23d35d6171.png)

Наследование по цепочке представляет из себя все те методы и свойства, к которым мы можем обратиться через точечную запись. А именно, мы сначала увидим **собственные свойства** данного объекта, потом увидим методы класса `Comment` (то есть он их унаследовал) и потом у нас пойдут методы объекта

![](_png/baa164e738331687bbb81bfd2743ec53.png)

### 004 Цепочка прототипов

Такое наследование (методы класса и методы объекта) возможно благодаря цепочке прототипов

![](_png/7b681e7ed2c98acf9c3c541b2af571de.png)

То есть тут можно увидеть цепочку прототипов и по всей этой цепочке у нас наследуются методы всех прототипов (т.е. родительских классов)

![](_png/12781db792f622b3fc38755aa732a3c4.png)

### 005 Проверка принадлежности классу

Чтобы проверить принадлежность определённого элемента к определённому прототипу, нужно воспользоваться оператором `instanceof`. Он нам вернёт булевое значение, которое будет отвечать за принадлежность объекта к определённому прототипу.

Тут объект `firstComment` принадлежит к прототипам `Comment` и `Object` одновременно

![](_png/1bf289e961ee446bb94c189d15967195.png)

### 006 Вызов унаследованных методов

Переменная `this` динамически будет указывать изменение переменной для нашего экземпляра. Если мы создадим другой экземпляр класса комментарий (например, `secondComment`), то `this` будет автоматически ссылаться на переменную внутри другого экземпляра.

То есть `this` указывает на конкретный объект (экземпляр класса), который вызывает данный метод

![](_png/0bb7ade79d90ee85c3326030c8197e5e.png)

### 007 Практика по созданию классов и экземпляров

Когда мы создаём класс, то мы создаём прототип, который является свойством переменной `Comment` (наименование нашего класса)

Когда мы используем `prototype`, мы вызываем прототип нашего объекта и при вызове конструктора данного прототипа мы получим саму переменную нашего созданного класса

Происходит всё так потому, что JS изначально не ООП ЯП и построен внутри на объектах и функциях

![](_png/220065bfbf7a46cf7f19e3d06de18329.png)![](_png/a64ceaa3bb2972556fc7b2bad99da898.png)

### 008 Проверка принадлежности свойств объектов

С помощью метода `hasOwnProperty` (который принадлежит прототипу объекта и является методом высшего порядка) мы можем проверить принадлежность свойства к нашему объекту.

![](_png/eac7bd82f5c55d3f31a2c1dcc3413f40.png)![](_png/3a4faf0c6c50d4e1fe1077d883e85112.png)

### 009 Создание нескольких экземпляров

![](_png/c3f0b5bd66b05e529bad2b21e58c3bbf.png)

### 010 Статические методы

Далее у нас идёт модификатор для нашего метода как `static`. Он позволяет не наследовать нашим экземплярам класса данный метод, что позволяет нам вызывать этот метод без инициализации класса через `new`.

![](_png/a89da42bcb72db7faf97c282352f40f7.png)

### 011 Практика по созданию статических методов

И тут уже нужно сказать, что все статические методы являются частью конструктора и данные методы только потому не наследуются экземплярами класса

![](_png/4b3be53b2ee7084ce2697b132a7ab5a6.png)

### 012 Расширение других классов

Так же мы можем расширять функционал стоковых прототипов в JS.

В данном примере мы создали класс, родителем которого является прототип `Array`. При создании экземпляра данного класса, мы создадим массив, который будет сначала наследовать методы `NumbersArray`, а потом уже будет наследовать методы прототипа `Array`. Тем самым мы расширили функционал Array собственным массивом

![](_png/04f4cdf087537f39840c53ef61ec1191.png)

И примерно так со всеми манипуляциями выглядит наша цепочка прототипов

![](_png/98ee6293c35ca44768822179b1c2bc9b.png)

Так же кратко опишем метод `reduce`. Он принимает в себя два значения: колбэк функцию, внутри которой два значения (одно – аккумулятор, который суммирует все значения, второе – само значение, над которым проводится операция) и начальное значение (которое присваивается аккумулятору – тут 0).

Как итог, мы получаем сумму всех значений массива (так же можно проводить любую другую операцию)

![](_png/0dcc8b664fc6e7f5559670d55f2681f8.png)![](_png/c3ced5ad0b63d05cb33d87a7516ba39f.png)

### 013 Что же такое прототип

У любого экземпляра класса есть скрытое свойство, которое называется `__proto__`

==Прототип== - это класс-предок объекта, всё как в ООП - разница только в том, что ==прототип== в ==JS== - это уже сконструированный "готовый" объект, а в классическом ООП ==прототип== - неотделим от самого класса-потомка: то есть не является ни объектом, ни чем-либо "физическим".

![](_png/ce289a3a295d180a27ade1aded750865.png)

### 014 Строки и числа ведут себя как объекты

Строки и числа хоть и выглядят как примитивные типы, но они имеют под собой список собственных методов, которые к ним относятся (прототипы `String` и `Number`)

![](_png/25ad35fb4cbb6527b8be0c1ab0806e5b.png)

И тут мы можем увидеть, что у нашей строки есть собственные методы, которые наследуются от прототипа `String` (у которого, кстати, нет структуры), который в свою очередь наследуется от Object (который имеет структуру)

![](_png/0b488de8a11bb79a920470c0e0f4c7d0.png)