
## Введение

React Native - это фреймворк на котором можно разрабатывать мобильные приложения с помощью React. Он выполняет роль ReactDOM в среде мобильных приложений и позволяет общаться с устройством через своего внутреннего посредника.

![](_png/Pasted%20image%2020241006150342.png)

React Native предоставляет
- набор компонентов, которые преобразуются в нативные
- API для работы с нативными возможностями ОС
- движок, который принимает запросы из JS на выполнение нативной логики

![](_png/Pasted%20image%2020241006150406.png)

## Настройка окружения

Для работы React Native приложения нам понадобится [NodeJs](https://nodejs.org/en). 

Скачиваем [AndroidStudio](https://developer.android.com/studio).

После скачивания и установки всех пакетов, нам нужно будет выбрать эмулятор устройства. Стоить выбирать устройства с поддержкой PlayStore для поддержки его API.

![](_png/Pasted%20image%2020250113192743.png)

![](_png/Pasted%20image%2020241006154343.png)

Далее выбираем операционную систему UpsideDownCake.

![](_png/Pasted%20image%2020241006154444.png)

Далее мы сможем создать виртуальное устройство.

![](_png/Pasted%20image%2020241006154537.png)

Ну и в менеджере устройств остаётся выбрать только наше нужное устройство.

![](_png/Pasted%20image%2020241006154905.png)

На наше физическое мобильное устройство нужно будет установить [ExpoGo](https://expo.dev/go), чтобы у нас была возможность удобно разрабатывать наш проект и тестировать его на реальном устройстве.

## Старт

### Как работает React Native

Если в браузере React работает достаточно стандартно и привычно нам, то в React Native применяется другой подход рендеринга, который включает в себя огромное количество различных библиотек и интерфейсов

![](_png/Pasted%20image%2020241006155418.png)

Для взаимодействия React с браузером используется дополнительная библиотека — ReactDOM. Подобную роль для мобильных устройств выполняет React Native, позволяя React работать с нативными компонентами операционных систем (именно что компоненты RN берёт нативные от каждого устройства).

![](_png/Pasted%20image%2020241006155405.png)

### UI и логика

В RN в 
- качестве блока используется View, который в рантайме переходит в UIView (iOS) и в ViewGroup (Android)
- качестве текста используется Text, который так же переходит в UITextView и TextView соответственно

JSX существует только в рамках разработки. Вся остальная JS логика остаётся существовать в рантайме и переводится уже самим RN в нативные вызовы.

![](_png/Pasted%20image%2020241006163220.png)

Есть два вида архитектуры RN-приложений, которые сложились со временем.

Первая архитектура предполагает то, что наш скомпилированный JS-код будет взаимодействовать с Bridge, который будет сообщать нативному устройству, какие API дёргаются и какие нативные компоненты рендерядтся.

У нас имеется поток JS, внутри которого исполняется JS и отправляет запросы на Bridge. Поток работает на основе JavaScript Core - это движок, который запускает JS на мобильном устройстве.

Через Bridge у нас запросы отправляются в нативный поток. Нативный поток работает с целевой платформой. Он запускает в себе сразу все компоненты приложения (даже те, которые сейчас могут не использоваться во время загрузки).

Нативная платформа общается с теневым потоком, который стилизует нативные компоненты под те, что мы реализовали в JSX.

Основными недостатками данной архитектуры являются:
1. Bridge, который сереализует / десереализует сообщения и может тормозить отрисовку UI
2. Так же Bridge асинхронен, поэтому даже синхронные компоненты будут вызваться асинхронно
3. Все потоки никак не связаны друг с другом. Они не представляют, что происходит друг в друге.

![](_png/Pasted%20image%2020241006163237.png)

В новой архитектуре у нас так же остаются три потока, но вместо одного Bridge, у нас появляется JSInterface, который позволяет общаться с нативными интерфейсами без пересылки сообщений. Всё ядро общения построено на биндингах C++. Интерфейс может быть как синхронным, так и асинхронным. 

Fabric - это новый компонент, который синхронизирует дерево из JS и отображение в Layout.

Turbo Modules - это пакет с модулями, которые не загружаются при первой загрузке приложения (по типу камеры, bluetooth, nfc)

CodeGen - это генератор интерфейса на C++, который взаимодействует с модулями посредников и собирает описанный компонент.

![](_png/Pasted%20image%2020241006163555.png)

### EXPO CLI vs RN CLI

Expo - это удобный инструмент для работы с RN. Он предоставляет свои компоненты и роутинг. Он предоставляет платные услуги, но всё доступно и в бесплатном режиме.

RN - это нативный CLI, который может быть полезен для более гибкого написания нативных компонентов, но с ним тяжелее работать. Лучше дефолтно его не использовать.

Из Expo можно одной командой перейти в RN, а обратно уже нет.

![](_png/Pasted%20image%2020241013191523.png)

### Старт проекта + Обзор проекта

Устанавливаем наш свежий проект

```bash
npx create-expo-app@latest rn-simple-app
```

И далее перед нами открывается большая структура. В файле `app.json` находится начальный конфиг приложения, в котором указано, что, откуда и какие ресурсы нужно брать для сборки приложения, а так же его начальные настройки.

![](_png/Pasted%20image%2020241013194353.png)

1. чтобы запустить приложение, нам нужно будет скачать Expo App на наш мобильный телефон
2. стартануть сервер
3. отсканировать QR либо скопировать сокет подключения
4. Нажать на
	1. `a`, чтобы поднять android
	2. `i` - IOS
	3. `w` - Web

```bash
bun start
```

![](_png/Pasted%20image%2020250208184610.png)

После этих действий на наше устройство закинется бандл с хот релодом

## Компоненты и стили

### Использование компонентов

Заместо использования базовых компонентов из веба, мы должны использовать те, что представляет `react-native` (либо другая библиотека нативных компонентов) по типу: `View`, `Text` или других. 

- `View` - это аналог `div`, в который мы всегда должны оборачивать контент.
- `Text` - это компонент, в который мы должны складывать текст. Помещать в другое место вне него уже нельзя, так как это выдаст ошибку.

```TSX
import { View, Text, Button, TextInput, StyleSheet } from 'react-native';

const styles = StyleSheet.create({
	container: {
		backgroundColor: 'green',
		flex: 1,
		alignItems: 'center',
		justifyContent: 'center',
	},
});

export default function SamplePage() {
	return (
		<View style={styles.container}>
			<Text>Привет!</Text>
			<Button title='Я дефолтный заголовок' />
			<TextInput value='Я значение, которое можно тыкать' />
		</View>
	);
}
```

И примерно так будет выглядеть наш стек компонентов

![](_png/Pasted%20image%2020250209172249.png)

### Стилизация

Стили выглядят похожим образом на то, что есть в вебе, но и сильно отличаются. В RN за стили отвечают объекты стилей, которые определённым образом имплементируют подход из ванильного CSS, но не дублируют его польностью. То есть у нас отсутствует grid либо некоторые свойства разбито на множество других подсвойств.

![](_png/Pasted%20image%2020250209100407.png)

Стили мы можем писать любыми способами, как и в нативном JS, но стоит для их описания использовать `StyleSheet.create`, который предоставит нам удобные типы и автокомплит по стилям

```TS
import { View, Text, Button, TextInput, StyleSheet } from 'react-native';

const outInline = {
	color: 'blue',
};

const stylesPalette = {
	text: {
		color: 'blue',
	},
};

const styles = StyleSheet.create({
	container: {
		backgroundColor: 'green',
		flex: 1,
		alignItems: 'center',
		justifyContent: 'center',
	},
	text: {
		color: 'blue',
		borderColor: 'blue',
		borderWidth: 1,
	},
});

export default function SamplePage() {
	return (
		<View style={styles.container}>
			<Text>Привет!</Text>
			<Text style={{ color: 'blue' }}>Инлайн</Text>
			<Text style={outInline}>Вынесенный инлайн</Text>
			<Text style={stylesPalette.text}>Объект со стилями</Text>
			<Text style={styles.text}>Stylesheet</Text>
			<Button title='Я дефолтный заголовок' />
			<TextInput value='Я значение, которое можно тыкать' />
		</View>
	);
}
```

![](_png/Pasted%20image%2020250209181245.png)

#### Flex

Изначально все элементы внутри `View` располагаются через `flex` и `column`. 
В `display` у нас есть только `flex` и `none` отображение.

Контейнером, в нашем случае, будет являться любой элемент, на который накинут `display: flex`, а айтемом - все вложенные. 

![](_png/Pasted%20image%2020250209185336.png)

#### align/justify

Дефолтно, `flexDirection` у нас равен `column`, поэтому основная ось, относительно которой работают align и justify - это вертикальная. Вспомогательной же будет горизонтальная. Если мы поменяем направление на `row`, то горизонтальная станет основной, а вертикальная вспомогательной.

- `alignItems` - отвечает за выравнивание элементов по вспомогательной оси
- `justifyContent` - отвечает за выравнивание элементов по основной оси

>[!info] Все базовые свойства работают точно так же, как и в вебе.

![](_png/Pasted%20image%2020250209185305.png)

То есть дефолтно мы опишем такой конфиг, когда элементы выравниваются по основной оси по центру и на вспомогательной с равными отступами

```TSX
<View
	style={{
		flexDirection: 'column',
		alignItems: 'center',
		justifyContent: 'space-between',
		height: 500,
		backgroundColor: 'yellow',
	}}
>
	<View style={{ width: 100, height: 100, backgroundColor: 'tomato' }} />
	<View style={{ width: 100, height: 100, backgroundColor: 'blue' }} />
	<View style={{ width: 100, height: 100, backgroundColor: 'violet' }} />
</View>
```

![](_png/Pasted%20image%2020250209203047.png)

Но если поменяем основную ось, то у нас так же останется, что `jc` раскидал элементы по основной оси, а `ai` распределил по вспомогательной (тут - по-центру)

```TSX
flexDirection: 'row',
```

![](_png/Pasted%20image%2020250209203108.png)

#### self

Так же ничто нам не мешает воспользоваться `alignSelf` для центровки отдельного элемента

```TSX
<View
	style={{
		flexDirection: 'row',
		alignItems: 'center',
		justifyContent: 'space-between',
		height: 500,
		backgroundColor: 'yellow',
	}}
>
	<View style={{ width: 100, height: 100, backgroundColor: 'tomato' }} />
	<View
		style={{
			alignSelf: 'flex-start',
			width: 100,
			height: 100,
			backgroundColor: 'blue',
		}}
	/>
	<View style={{ width: 100, height: 100, backgroundColor: 'violet' }} />
</View>
```

![](_png/Pasted%20image%2020250209203706.png)

#### wrap






#### basis/grow/shrink







#### gap







#### dimensions







### Вёрстка логина






## События и создание компонента






## Анимация






## Отладка и lint






## Expo router






## Запросы и состояния






## Боковая панель






## Нативные возможности






## Разрешения и layout






## Списки






## Нотификации






## Сборка и публикация


















