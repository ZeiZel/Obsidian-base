
![](_png/72d2a85737d3c7dbc670f139fef056c2.jpg)

## Архивы

`du` позволяет вывести размер файла или каталога. `-sk` выведет размер файла в килобайхтах, а `-sh` выведет в удобочитаемом формате.

`ls -lh` так же выведет размеры файлов

![](_png/3bd478dba170688237663770a099989b.png)

`tar` архивирует файлы

- `-c` - используется для архивации файлов
- `-f` - используется для указания имени результирующего файла с архивом

![](_png/bd9f5bfeb66f7419a2fb27220724688f.png)

Чтобы просмотреть внутренности архива, можно воспользоваться `-tf`

Чтобы разархивировать файл, нужно воспользоваться `-xf`

Чтобы сжать архив, нужно воспользоваться опцией `-zcf` (сжатие в `gz` формате) и на выходе мы получим файл `.tar.gz`

![](_png/0a6292ba425ac841f6755fe0c448ce11.png)

Есть несколько методов сжатия и разжатия файла и все они имеют разные алгоритмы, но чем более сжатый файл, тем дольше он будет распаковываться.

Команды для `запаковки` - `распаковки` файлов:

`bzip2` - `bunzip2`
`gzip` - `zunzip`
`xz` - `unxz`

![](_png/46741089b240cdc13ce56337f607e3cc.png)

Ну и так же команды `zcat` `bzcat` `xzcat` позволяют просмотреть содержимое файлов без распаковки

![](_png/1b7e417d993bee092a5224ef34b6ed99.png)

## Поиск файлов и директорий

### поиск по директориям

Чтобы найти определённый файл в системе с помощью консоли, мы можем воспользоваться несколькими способами

`locate` - отображает пути до определённого искомого файла в системе. Ищет по файлу `mlocate.db`, в котором описаны все файлы в системе. Само собой этот файл нужно иногда обновлять, потому что новые пути туда записываются не сразу. Можно это сделать самостоятельно с помощью `updatedb`.

Так же можно воспользоваться командой `find`, которая найдёт вхождения в определённом каталоге.

![](_png/414adb7933ecc969cc41674e1acf28de.png)

### поиск по файлам

Если нам требуется вывести содержание файла целиком, то мы можем воспользоваться `cat`

Команда `grep` позволяет искать определённые строки по паттерну. Сама команда является регистрозависимой, и если нам нужно будет найти что-то вне регистра, то мы должны использовать `-i`. Если мы не помним, в каком файле находится слово, то используем `-r` и рекурсивно проверяем файлы в директории на наличие паттерна. Если нам нужно ввести сразу несколько слов в поиске, то обернуть его нужно в `""` кавычки. Если нам нужно инвертировать поиск и найти все строки, кроме определённой, то используем `-v`.

![](_png/4c36e531d3397d80c090ecfa0a4c76c3.png)

`-w` - если требуется найти как выделенное слово (ищем `Clone` и будем находить только `_Clone_`)
`-vw` - так же позволит инвертировать выделение и найти только строки, не совпадающие выделенному слову `Clone`
`-A<число>` - позволит вывести найденное и определённое количество строк ПОСЛЕ него
`-B<число>` - позволит вывести найденное и определённое количество строк ДО него

Так же `-A1 -B1` можно объединить в один запрос, чтобы вывести сразу и до и после совпадения несколько строк

![](_png/f631ab5b92bbca18966488c14df4b3fd.png)

Команда `awk` позволяет парсить большое количество текста. Можно сказать, что это целый скриптовый язык с переменными, операциями и символами.

В паттерне команды мы определяем выводимые поля. Все поля делятся по пробелу (как в csv по `;`).

Каждая переменная `$0`, `$1`, `$2` и так далее отвечают за свой участок строки, который выведет команда.

В последнем примере мы меняем разделитель с помощью опции `-F`. Поменяли мы разделитель на `:`. В самом паттерне мы скрыли второе поле (назвав его `hidden`) и вывели всю остальную строку.

 С помощью `|` мы чейним вывод (перенаправление) и передаём результат первой команды во вторую.

![](_png/566a84cf386e153cecd003a3026e5b0a.png)

## Перенаправление

В линукс все операции делятся на три потока:
- `0` - стандартный ввод
- `1` - стандартный вывод
- `2` - стандартные ошибки

Дефолтно, стандартный вывод и ошибки идут в экран пользователя на отображение, но так же эти потоки можно перенаправлять, чтобы выполнять другие операции, как, например, вывод всех данных в файлы, а не на экран

![](_png/7a8debeea6ee8fafebcfec380a4eb652.png)

Мы можем записать результат выполнения операции в несуществующий пока файл с помощью `>` либо добавить в конец существующего `>>`

![](_png/5c6761231c49e1f95bda161278e0195d.png)

Так же мы можем перенаправить результат вывода только опрделённого потока в нужный нам файл. Операция `1>` перенаправит только результат успешного выполнения в файл.

Так же стоит отметить про существование папки `/dev/null`, в которую можно положить файлы, которые сразу же пропадут (aka чёрная дыра, пожирающая всю информацию)

![](_png/77376d5a58ce9667eea2da597bae4260.png)

Так же стоит рассказать про последовательность выполнения перенаправления. 

У нас есть команда `ls -lh > name.txt`

Данные операции в bash выполняются слева направо. 
1. Сначала проверяется существование файла и его создание, при необходимости (что является быстрым способом создания файла)
2. Затём идёт обнуление файла через `>` (либо дополнение через `>>`)
3. Затем выполняется начальная операция, вывод которой заполнится в файл

Таким образом мы увидим в выводе, что в каталоге существует наш файл `name.txt` с весом в 0 байт. Именно такой размер был у этого файла во время создания, потому что результат записался в этот файл уже после того, как выполнилась операция `ls -lh` 

![](_png/4395a69a61295b4a29039bf3dd35943f.png)

Для упрощения работы и использования результатов вывода прошлой команды, используется `|`, который предоставляет стандартный вывод прошлой команды для следующей (вторая команда берёт результат первой и работает с ним)

![](_png/8d656828217cb1dc07a345901bb50662.png)

Так же в качестве команды для перенаправления вывода мы можем использовать `tee`. Разница в отличе от `>` в том, что `tee`, по прежнему печатает стандартный вывод на экране, а так же записывает его в файл

`tee -a` заменит операцию `>>` с добавлением вывода в конец файла

![](_png/4d7d20d014a050f18a79237ff40acdea.png)

Так же мы можем с помощью указателей `>&` определять движение потоков по файлам. То есть `&` позволяет указать потоку, в какой поток должен идти его вывод

Команда `ls -lh notOk result.txt 1> result.txt 2>&1`

![](_png/5ba230d6ef710c42b19858b2655a4663.png)

## Логические операторы

В результате выполнения всех команд в строке линукс мы получаем статус код, который отображает успешность или неуспешность выполнения операции.

Команда `echo $?` выводит код статуса завершения операции

- `0` - успешный выполнение операции
- `1` и отличные от нуля - неуспешное выполнение операции

![](_png/ead442bfe483213ef6067aa08c35978c.png)

Оператор `&&` выполнит обе операции, но вторую операцию выполнит только если первая выполнится со статускодом `0`. То есть, либо первая с ошибкой и вторая не выполнится, либо первая успешно и вторая, как получится. Каждая последующая команда будет выполняться только после успешной предыдущей.

Оператор `||` выполнит вторую операцию только если первая завершилась с ошибкой. Выполнится или первая, или вторая - только одна.

![](_png/0d98a8ad4e533385ce4dfc53d2a6b35a.png)

Так же есть оператор `;`, который выполнит обе команды последовательно друг за другом, даже если прошлая выполнилась с ошибкой.

![](_png/924042dab2a554abde873172e54d8f86.png)

## Текстовые редакторы

Дефолтно мы можем вывести содержимое файла с помощью `cat`, но изменить файл или как-то удобно навигироваться по нему мы не можем

![](_png/c08c0b373a3657287eddcd1c27f8e8bb.png)

Для удобной навигации по файлам обычно используют Vi, который установлен во многих дистрибутивах по-дефолту

Сам ви представляет из себя редактор с тремя режимами - команды, ввод и последняя строка.

![](_png/a2e7c6aa68b8f3166a9efe1c04a1e835.png)

Командный режим позволяет нам перемещаться по тексту, производить над ним коммандные операции.

Режим вставки позволяет изменять текст стандартными способами ввода.

Последняя строка позволяет выполнять операции над самим файлом и общаться с ви (сохрание файла, выход из ви)

![](_png/44b04b6437a49ec09bad658b5a9778c6.png)

Список сочетаний командного режима:

![](_png/cabb3ffa6a6edf3176e0bcceb2b39394.png)

![](_png/7169d0cb21609897d3bf4116ace23114.png)

Список сочетаний режима вставки:

![](_png/6f2389569427fda78672e5070e51f3fb.png)

Режим последней строки:

![](_png/ae1e06cf280fe2190ca9079e637d19b2.png)

Так же зачастую в системах `vi` установлен просто в качестве алиаса для команды `vim`, которая позволяет редактировать текст более продвинутым образом за счёт возможностей кастомизации и расширения

![](_png/7021f7d8e0f8d456dc88fe253a4f4d9e.png)

Используются ссылки как, например, вот тут с `vi` на `vim`

![](_png/709df28cdf1316225f55afca15521d29.png)

## Cron

`cron` - позволяет клонировать задания по расписанию с помощью крон в линуксе 

Чтобы добавить команду в повторяющиеся операции, её нужно запусти в крофайл через `crontab -e`. Там мы должны в звёздочках указать периодичность выполнения операции и затем команду.

![](_png/0d2d72e8dfcab530d406af7ec62c9983.png)

Сами по себе звёздочки указывают на выполнение в определённом промежутке.

`*(минута) *(час) *(день) *(месяц) *(день недели)` - выполнение операции каждую минуту, каждый день недели.

![](_png/637e8c8b9869198bdd7c4835cdfcf78f.png)

`20 19 21 11 7 <команда>` - будет выполнять команду каждое воскресенье ноября 21ого числа в 19:20

![](_png/ba139d4d1c413f275b5a21c7f9d0b5c5.png)

Если нам нужно выполнять выполнять операцию каждые 5 минут, с 7 вечера до 7 утра, с 11 по 13 число любого месяца и любого дня недели, то мы можем записать крон так: `*/5 0-7,19-23 11-13 * *`

![](_png/4f55d194fe0a5577a29bbe2458e9ad09.png)

`crontab -l` - отобразит список задач

![](_png/d09bee6aedb08e72c4047d457c8c0205.png)
